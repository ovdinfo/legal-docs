(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.substance = global.substance || {})));
}(this, (function (exports) { 'use strict';

var ChangeStore = function ChangeStore(seed) {
  this._changes = seed || {};
};


ChangeStore.prototype.getChanges = function getChanges (documentId, sinceVersion, toVersion, cb) {
  if (typeof sinceVersion === 'function') {
    cb = sinceVersion;
    sinceVersion = 0;
  } else if (typeof toVersion === 'function') {
    cb = toVersion;
    toVersion = undefined;
  }
  if (!(documentId && sinceVersion >= 0 && cb)) {
    throw new Error('Invalid arguments')
  }
  var version = this._getVersion(documentId);
  var changes = this._getChanges(documentId);
  changes = changes.slice(sinceVersion, toVersion);
  cb(null, changes, version);
};


ChangeStore.prototype.addChange = function addChange (documentId, change, cb) {
  if (!documentId || !change) {
    throw new Error('Invalid arguments')
  }
  this._addChange(documentId, change);
  var newVersion = this._getVersion(documentId);
  cb(null, newVersion);
};


ChangeStore.prototype.deleteChanges = function deleteChanges (documentId, cb) {
  var deletedChanges = this._deleteChanges(documentId);
  cb(null, deletedChanges.length);
};


ChangeStore.prototype.getVersion = function getVersion (id, cb) {
  cb(null, this._getVersion(id));
};




ChangeStore.prototype._deleteChanges = function _deleteChanges (documentId) {
  var changes = this._getChanges(documentId);
  delete this._changes[documentId];
  return changes
};

ChangeStore.prototype._getVersion = function _getVersion (documentId) {
  var changes = this._changes[documentId];
  return changes ? changes.length : 0
};

ChangeStore.prototype._getChanges = function _getChanges (documentId) {
  return this._changes[documentId] || []
};

ChangeStore.prototype._addChange = function _addChange (documentId, change) {
  if (!this._changes[documentId]) {
    this._changes[documentId] = [];
  }
  this._changes[documentId].push(change);
};

function series(tasks, cb, i) {
  i = i || 0;
  tasks[i](function(err) {
    
    if (err) { return cb(err) }
    if (i === tasks.length-1) {
      cb.apply(void 0, arguments); 
    } else {
      series(tasks, cb, i + 1);
    }
  });
}

var async = Object.freeze({
	series: series
});

var ArrayIterator = function ArrayIterator(arr) {
  this.arr = arr;
  this.pos = -1;
};

var prototypeAccessors = { _isArrayIterator: {} };

prototypeAccessors._isArrayIterator.get = function () {
  return true
};


ArrayIterator.prototype.hasNext = function hasNext () {
  return this.pos < this.arr.length - 1
};


ArrayIterator.prototype.next = function next () {
  this.pos += 1;
  var next = this.arr[this.pos];
  return next
};


ArrayIterator.prototype.back = function back () {
  if (this.pos >= 0) {
    this.pos -= 1;
  }
  return this
};

ArrayIterator.prototype.peek = function peek () {
  return this.arr[this.pos+1]
};

Object.defineProperties( ArrayIterator.prototype, prototypeAccessors );

function deleteFromArray(array, value) {
  if (!array) { return }
  for (var i = 0; i < array.length; i++) {
    if (array[i] === value) {
      array.splice(i, 1);
      i--;
    }
  }
}

var ArrayTree = function ArrayTree () {};

ArrayTree.prototype.add = function add (path, val) {
  if (!this[path]) {
    this[path] = [];
  }
  this[path].push(val);
};
ArrayTree.prototype.remove = function remove (path, val) {
  if (this[path]) {
    deleteFromArray(this[path], val);
  }
};

function checkGlobal(value) {
  return (value && value.Object === Object) ? value : null;
}

var freeGlobal = checkGlobal(typeof global == 'object' && global);


var freeSelf = checkGlobal(typeof self == 'object' && self);


var thisGlobal = checkGlobal(typeof undefined == 'object' && undefined);


var root = freeGlobal || freeSelf || thisGlobal || Function('return this')();

var Symbol = root.Symbol;

function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

var symbolTag = '[object Symbol]';


var objectProto = Object.prototype;


var objectToString = objectProto.toString;


function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

var INFINITY = 1 / 0;


var symbolProto = Symbol ? Symbol.prototype : undefined;
var symbolToString = symbolProto ? symbolProto.toString : undefined;


function baseToString(value) {
  
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

function toString(value) {
  return value == null ? '' : baseToString(value);
}

function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

var rsAstralRange = '\\ud800-\\udfff';
var rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23';
var rsComboSymbolsRange = '\\u20d0-\\u20f0';
var rsVarRange = '\\ufe0e\\ufe0f';


var rsZWJ = '\\u200d';


var reHasComplexSymbol = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');

var rsAstralRange$1 = '\\ud800-\\udfff';
var rsComboMarksRange$1 = '\\u0300-\\u036f\\ufe20-\\ufe23';
var rsComboSymbolsRange$1 = '\\u20d0-\\u20f0';
var rsVarRange$1 = '\\ufe0e\\ufe0f';


var rsAstral = '[' + rsAstralRange$1 + ']';
var rsCombo = '[' + rsComboMarksRange$1 + rsComboSymbolsRange$1 + ']';
var rsFitz = '\\ud83c[\\udffb-\\udfff]';
var rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';
var rsNonAstral = '[^' + rsAstralRange$1 + ']';
var rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}';
var rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]';
var rsZWJ$1 = '\\u200d';


var reOptMod = rsModifier + '?';
var rsOptVar = '[' + rsVarRange$1 + ']?';
var rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';


var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');


function stringToArray(string) {
  return string.match(reComplexSymbol);
}

function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = reHasComplexSymbol.test(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

var upperFirst = createCaseFirst('toUpperCase');

function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}

function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

function now() {
  return Date.now();
}

var funcTag = '[object Function]';
var genTag = '[object GeneratorFunction]';


var objectProto$1 = Object.prototype;


var objectToString$1 = objectProto$1.toString;


function isFunction(value) {
  
  
  
  var tag = isObject(value) ? objectToString$1.call(value) : '';
  return tag == funcTag || tag == genTag;
}

var NAN = 0 / 0;


var reTrim = /^\s+|\s+$/g;


var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;


var reIsBinary = /^0b[01]+$/i;


var reIsOctal = /^0o[0-7]+$/i;


var freeParseInt = parseInt;


function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = isFunction(value.valueOf) ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var FUNC_ERROR_TEXT = 'Expected a function';


var nativeMax = Math.max;
var nativeMin = Math.min;


function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    
    lastInvokeTime = time;
    
    timerId = setTimeout(timerExpired, wait);
    
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    
    
    
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    
    
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

var isArray = Array.isArray;

function isHostObject(value) {
  
  
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

var coreJsData = root['__core-js_shared__'];

var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());


function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

var funcToString$1 = Function.prototype.toString;


function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;


var reIsHostCtor = /^\[object .+?Constructor\]$/;


var objectProto$2 = Object.prototype;


var funcToString = Function.prototype.toString;


var hasOwnProperty = objectProto$2.hasOwnProperty;


var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);


function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

function getValue(object, key) {
  return object == null ? undefined : object[key];
}

function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

var nativeCreate = getNative(Object, 'create');

function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

var HASH_UNDEFINED = '__lodash_hash_undefined__';


var objectProto$3 = Object.prototype;


var hasOwnProperty$1 = objectProto$3.hasOwnProperty;


function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty$1.call(data, key) ? data[key] : undefined;
}

var objectProto$4 = Object.prototype;


var hasOwnProperty$2 = objectProto$4.hasOwnProperty;


function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty$2.call(data, key);
}

var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';


function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

function Hash(entries) {
  var this$1 = this;

  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this$1.set(entry[0], entry[1]);
  }
}


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

function listCacheClear() {
  this.__data__ = [];
}

function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

var arrayProto = Array.prototype;


var splice = arrayProto.splice;


function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

function ListCache(entries) {
  var this$1 = this;

  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this$1.set(entry[0], entry[1]);
  }
}


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

var Map$1 = getNative(root, 'Map');

function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$1 || ListCache),
    'string': new Hash
  };
}

function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

function MapCache(entries) {
  var this$1 = this;

  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this$1.set(entry[0], entry[1]);
  }
}


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

var FUNC_ERROR_TEXT$1 = 'Expected a function';


function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}


memoize.Cache = MapCache;

var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(\.|\[\])(?:\4|$))/g;


var reEscapeChar = /\\(\\)?/g;


var stringToPath = memoize(function(string) {
  var result = [];
  toString(string).replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;


function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

var INFINITY$1 = 1 / 0;


function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
}

function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

function stackClear() {
  this.__data__ = new ListCache;
}

function stackDelete(key) {
  return this.__data__['delete'](key);
}

function stackGet(key) {
  return this.__data__.get(key);
}

function stackHas(key) {
  return this.__data__.has(key);
}

var LARGE_ARRAY_SIZE = 200;


function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache && cache.__data__.length == LARGE_ARRAY_SIZE) {
    cache = this.__data__ = new MapCache(cache.__data__);
  }
  cache.set(key, value);
  return this;
}

function Stack(entries) {
  this.__data__ = new ListCache(entries);
}


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';


function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);
  return this;
}

function setCacheHas(value) {
  return this.__data__.has(value);
}

function SetCache(values) {
  var this$1 = this;

  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this$1.add(values[index]);
  }
}


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

function arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

var UNORDERED_COMPARE_FLAG$1 = 1;
var PARTIAL_COMPARE_FLAG$2 = 2;


function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG$2,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  
  var stacked = stack.get(array);
  if (stacked) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & UNORDERED_COMPARE_FLAG$1) ? new SetCache : undefined;

  stack.set(array, other);

  
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!seen.has(othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, customizer, bitmask, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  return result;
}

var Uint8Array = root.Uint8Array;

function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

var UNORDERED_COMPARE_FLAG$2 = 1;
var PARTIAL_COMPARE_FLAG$3 = 2;


var boolTag = '[object Boolean]';
var dateTag = '[object Date]';
var errorTag = '[object Error]';
var mapTag = '[object Map]';
var numberTag = '[object Number]';
var regexpTag = '[object RegExp]';
var setTag = '[object Set]';
var stringTag = '[object String]';
var symbolTag$1 = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]';
var dataViewTag = '[object DataView]';


var symbolProto$1 = Symbol ? Symbol.prototype : undefined;
var symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;


function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
      
      
      
      return +object == +other;

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case numberTag:
      
      return (object != +object) ? other != +other : object == +other;

    case regexpTag:
    case stringTag:
      
      
      
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG$3;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG$2;
      stack.set(object, other);

      
      return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);

    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

var nativeGetPrototype = Object.getPrototypeOf;


function getPrototype(value) {
  return nativeGetPrototype(Object(value));
}

var objectProto$6 = Object.prototype;


var hasOwnProperty$4 = objectProto$6.hasOwnProperty;


function baseHas(object, key) {
  
  
  
  return object != null &&
    (hasOwnProperty$4.call(object, key) ||
      (typeof object == 'object' && key in object && getPrototype(object) === null));
}

var nativeKeys = Object.keys;


function baseKeys(object) {
  return nativeKeys(Object(object));
}

function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

var getLength = baseProperty('length');

var MAX_SAFE_INTEGER = 9007199254740991;


function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

function isArrayLike(value) {
  return value != null && isLength(getLength(value)) && !isFunction(value);
}

function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

var argsTag$1 = '[object Arguments]';


var objectProto$7 = Object.prototype;


var hasOwnProperty$5 = objectProto$7.hasOwnProperty;


var objectToString$2 = objectProto$7.toString;


var propertyIsEnumerable = objectProto$7.propertyIsEnumerable;


function isArguments(value) {
  
  return isArrayLikeObject(value) && hasOwnProperty$5.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString$2.call(value) == argsTag$1);
}

var stringTag$1 = '[object String]';


var objectProto$8 = Object.prototype;


var objectToString$3 = objectProto$8.toString;


function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && objectToString$3.call(value) == stringTag$1);
}

function indexKeys(object) {
  var length = object ? object.length : undefined;
  if (isLength(length) &&
      (isArray(object) || isString(object) || isArguments(object))) {
    return baseTimes(length, String);
  }
  return null;
}

var MAX_SAFE_INTEGER$1 = 9007199254740991;


var reIsUint = /^(?:0|[1-9]\d*)$/;


function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

var objectProto$9 = Object.prototype;


function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$9;

  return value === proto;
}

function keys(object) {
  var isProto = isPrototype(object);
  if (!(isProto || isArrayLike(object))) {
    return baseKeys(object);
  }
  var indexes = indexKeys(object),
      skipIndexes = !!indexes,
      result = indexes || [],
      length = result.length;

  for (var key in object) {
    if (baseHas(object, key) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
        !(isProto && key == 'constructor')) {
      result.push(key);
    }
  }
  return result;
}

var PARTIAL_COMPARE_FLAG$4 = 2;


function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG$4,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : baseHas(other, key))) {
      return false;
    }
  }
  
  var stacked = stack.get(object);
  if (stacked) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  return result;
}

var DataView = getNative(root, 'DataView');

var Promise$1 = getNative(root, 'Promise');

var Set$1 = getNative(root, 'Set');

var WeakMap$1 = getNative(root, 'WeakMap');

var mapTag$1 = '[object Map]';
var objectTag$1 = '[object Object]';
var promiseTag = '[object Promise]';
var setTag$1 = '[object Set]';
var weakMapTag = '[object WeakMap]';

var dataViewTag$1 = '[object DataView]';


var objectProto$10 = Object.prototype;


var objectToString$4 = objectProto$10.toString;


var dataViewCtorString = toSource(DataView);
var mapCtorString = toSource(Map$1);
var promiseCtorString = toSource(Promise$1);
var setCtorString = toSource(Set$1);
var weakMapCtorString = toSource(WeakMap$1);


function getTag(value) {
  return objectToString$4.call(value);
}



if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$1) ||
    (Map$1 && getTag(new Map$1) != mapTag$1) ||
    (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
    (Set$1 && getTag(new Set$1) != setTag$1) ||
    (WeakMap$1 && getTag(new WeakMap$1) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString$4.call(value),
        Ctor = result == objectTag$1 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$1;
        case mapCtorString: return mapTag$1;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$1;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

var getTag$1 = getTag;

var argsTag$2 = '[object Arguments]';
var arrayTag$1 = '[object Array]';
var boolTag$1 = '[object Boolean]';
var dateTag$1 = '[object Date]';
var errorTag$1 = '[object Error]';
var funcTag$1 = '[object Function]';
var mapTag$2 = '[object Map]';
var numberTag$1 = '[object Number]';
var objectTag$2 = '[object Object]';
var regexpTag$1 = '[object RegExp]';
var setTag$2 = '[object Set]';
var stringTag$2 = '[object String]';
var weakMapTag$1 = '[object WeakMap]';

var arrayBufferTag$1 = '[object ArrayBuffer]';
var dataViewTag$2 = '[object DataView]';
var float32Tag = '[object Float32Array]';
var float64Tag = '[object Float64Array]';
var int8Tag = '[object Int8Array]';
var int16Tag = '[object Int16Array]';
var int32Tag = '[object Int32Array]';
var uint8Tag = '[object Uint8Array]';
var uint8ClampedTag = '[object Uint8ClampedArray]';
var uint16Tag = '[object Uint16Array]';
var uint32Tag = '[object Uint32Array]';


var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$1] =
typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] =
typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] =
typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] =
typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] =
typedArrayTags[setTag$2] = typedArrayTags[stringTag$2] =
typedArrayTags[weakMapTag$1] = false;


var objectProto$11 = Object.prototype;


var objectToString$5 = objectProto$11.toString;


function isTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString$5.call(value)];
}

var PARTIAL_COMPARE_FLAG$1 = 2;


var argsTag = '[object Arguments]';
var arrayTag = '[object Array]';
var objectTag = '[object Object]';


var objectProto$5 = Object.prototype;


var hasOwnProperty$3 = objectProto$5.hasOwnProperty;


function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag$1(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag$1(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !isHostObject(object),
      othIsObj = othTag == objectTag && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG$1)) {
    var objIsWrapped = objIsObj && hasOwnProperty$3.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$3.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

var UNORDERED_COMPARE_FLAG = 1;
var PARTIAL_COMPARE_FLAG = 2;


function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

function isStrictComparable(value) {
  return value === value && !isObject(value);
}

function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

function hasPath(object, path, hasFunc) {
  path = isKey(path, object) ? [path] : castPath(path);

  var result,
      index = -1,
      length = path.length;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result) {
    return result;
  }
  var length = object ? object.length : 0;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isString(object) || isArguments(object));
}

function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

var UNORDERED_COMPARE_FLAG$3 = 1;
var PARTIAL_COMPARE_FLAG$5 = 2;


function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG$3 | PARTIAL_COMPARE_FLAG$5);
  };
}

function identity(value) {
  return value;
}

function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

function baseIteratee(value) {
  
  
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    predicate = baseIteratee(predicate, 3);
    if (!isArrayLike(collection)) {
      var props = keys(collection);
    }
    var index = findIndexFunc(props || collection, function(value, key) {
      if (props) {
        key = value;
        value = iterable[key];
      }
      return predicate(value, key, iterable);
    }, fromIndex);
    return index > -1 ? collection[props ? props[index] : index] : undefined;
  };
}

function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

var INFINITY$2 = 1 / 0;
var MAX_INTEGER = 1.7976931348623157e+308;


function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY$2 || value === -INFINITY$2) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

var nativeMax$1 = Math.max;


function findIndex(array, predicate, fromIndex) {
  var length = array ? array.length : 0;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax$1(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

var find = createFind(findIndex);

function isMatch(object, source) {
  return object === source || baseIsMatch(object, source, getMatchData(source));
}

function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (typeof key == 'number' && value === undefined && !(key in object))) {
    object[key] = value;
  }
}

var objectProto$12 = Object.prototype;


var hasOwnProperty$6 = objectProto$12.hasOwnProperty;


function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$6.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : source[key];

    assignValue(object, key, newValue);
  }
  return object;
}

function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

function stubArray() {
  return [];
}

var getOwnPropertySymbols = Object.getOwnPropertySymbols;


function getSymbols(object) {
  
  
  return getOwnPropertySymbols(Object(object));
}


if (!getOwnPropertySymbols) {
  getSymbols = stubArray;
}

var getSymbols$1 = getSymbols;

function copySymbols(source, object) {
  return copyObject(source, getSymbols$1(source), object);
}

function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols$1);
}

var objectProto$13 = Object.prototype;


var hasOwnProperty$7 = objectProto$13.hasOwnProperty;


function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  
  if (length && typeof array[0] == 'string' && hasOwnProperty$7.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

function addMapEntry(map, pair) {
  
  map.set(pair[0], pair[1]);
  return map;
}

function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

var reFlags = /\w*$/;


function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

function addSetEntry(set, value) {
  set.add(value);
  return set;
}

function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

var symbolProto$2 = Symbol ? Symbol.prototype : undefined;
var symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;


function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}

function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

var boolTag$3 = '[object Boolean]';
var dateTag$3 = '[object Date]';
var mapTag$4 = '[object Map]';
var numberTag$3 = '[object Number]';
var regexpTag$3 = '[object RegExp]';
var setTag$4 = '[object Set]';
var stringTag$4 = '[object String]';
var symbolTag$3 = '[object Symbol]';

var arrayBufferTag$3 = '[object ArrayBuffer]';
var dataViewTag$4 = '[object DataView]';
var float32Tag$2 = '[object Float32Array]';
var float64Tag$2 = '[object Float64Array]';
var int8Tag$2 = '[object Int8Array]';
var int16Tag$2 = '[object Int16Array]';
var int32Tag$2 = '[object Int32Array]';
var uint8Tag$2 = '[object Uint8Array]';
var uint8ClampedTag$2 = '[object Uint8ClampedArray]';
var uint16Tag$2 = '[object Uint16Array]';
var uint32Tag$2 = '[object Uint32Array]';


function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$3:
      return cloneArrayBuffer(object);

    case boolTag$3:
    case dateTag$3:
      return new Ctor(+object);

    case dataViewTag$4:
      return cloneDataView(object, isDeep);

    case float32Tag$2: case float64Tag$2:
    case int8Tag$2: case int16Tag$2: case int32Tag$2:
    case uint8Tag$2: case uint8ClampedTag$2: case uint16Tag$2: case uint32Tag$2:
      return cloneTypedArray(object, isDeep);

    case mapTag$4:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag$3:
    case stringTag$4:
      return new Ctor(object);

    case regexpTag$3:
      return cloneRegExp(object);

    case setTag$4:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag$3:
      return cloneSymbol(object);
  }
}

var objectCreate = Object.create;


function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

function stubFalse() {
  return false;
}

var freeExports = typeof exports == 'object' && exports;


var freeModule = freeExports && typeof module == 'object' && module;


var moduleExports = freeModule && freeModule.exports === freeExports;


var Buffer = moduleExports ? root.Buffer : undefined;


var isBuffer = !Buffer ? stubFalse : function(value) {
  return value instanceof Buffer;
};

var argsTag$3 = '[object Arguments]';
var arrayTag$2 = '[object Array]';
var boolTag$2 = '[object Boolean]';
var dateTag$2 = '[object Date]';
var errorTag$2 = '[object Error]';
var funcTag$2 = '[object Function]';
var genTag$1 = '[object GeneratorFunction]';
var mapTag$3 = '[object Map]';
var numberTag$2 = '[object Number]';
var objectTag$3 = '[object Object]';
var regexpTag$2 = '[object RegExp]';
var setTag$3 = '[object Set]';
var stringTag$3 = '[object String]';
var symbolTag$2 = '[object Symbol]';
var weakMapTag$2 = '[object WeakMap]';

var arrayBufferTag$2 = '[object ArrayBuffer]';
var dataViewTag$3 = '[object DataView]';
var float32Tag$1 = '[object Float32Array]';
var float64Tag$1 = '[object Float64Array]';
var int8Tag$1 = '[object Int8Array]';
var int16Tag$1 = '[object Int16Array]';
var int32Tag$1 = '[object Int32Array]';
var uint8Tag$1 = '[object Uint8Array]';
var uint8ClampedTag$1 = '[object Uint8ClampedArray]';
var uint16Tag$1 = '[object Uint16Array]';
var uint32Tag$1 = '[object Uint32Array]';


var cloneableTags = {};
cloneableTags[argsTag$3] = cloneableTags[arrayTag$2] =
cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] =
cloneableTags[boolTag$2] = cloneableTags[dateTag$2] =
cloneableTags[float32Tag$1] = cloneableTags[float64Tag$1] =
cloneableTags[int8Tag$1] = cloneableTags[int16Tag$1] =
cloneableTags[int32Tag$1] = cloneableTags[mapTag$3] =
cloneableTags[numberTag$2] = cloneableTags[objectTag$3] =
cloneableTags[regexpTag$2] = cloneableTags[setTag$3] =
cloneableTags[stringTag$3] = cloneableTags[symbolTag$2] =
cloneableTags[uint8Tag$1] = cloneableTags[uint8ClampedTag$1] =
cloneableTags[uint16Tag$1] = cloneableTags[uint32Tag$1] = true;
cloneableTags[errorTag$2] = cloneableTags[funcTag$2] =
cloneableTags[weakMapTag$2] = false;


function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value),
        isFunc = tag == funcTag$2 || tag == genTag$1;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$3 || tag == argsTag$3 || (isFunc && !object)) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

var objectTag$4 = '[object Object]';


var objectProto$14 = Object.prototype;


var funcToString$2 = Function.prototype.toString;


var hasOwnProperty$8 = objectProto$14.hasOwnProperty;


var objectCtorString = funcToString$2.call(Object);


var objectToString$6 = objectProto$14.toString;


function isPlainObject(value) {
  if (!isObjectLike(value) ||
      objectToString$6.call(value) != objectTag$4 || isHostObject(value)) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$8.call(proto, 'constructor') && proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString);
}

var Reflect = root.Reflect;

function iteratorToArray(iterator) {
  var data,
      result = [];

  while (!(data = iterator.next()).done) {
    result.push(data.value);
  }
  return result;
}

var objectProto$16 = Object.prototype;


var enumerate = Reflect ? Reflect.enumerate : undefined;
var propertyIsEnumerable$1 = objectProto$16.propertyIsEnumerable;


function baseKeysIn(object) {
  object = object == null ? object : Object(object);

  var result = [];
  for (var key in object) {
    result.push(key);
  }
  return result;
}


if (enumerate && !propertyIsEnumerable$1.call({ 'valueOf': 1 }, 'valueOf')) {
  baseKeysIn = function(object) {
    return iteratorToArray(enumerate(object));
  };
}

var baseKeysIn$1 = baseKeysIn;

var objectProto$15 = Object.prototype;


var hasOwnProperty$9 = objectProto$15.hasOwnProperty;


function keysIn(object) {
  var index = -1,
      isProto = isPrototype(object),
      props = baseKeysIn$1(object),
      propsLength = props.length,
      indexes = indexKeys(object),
      skipIndexes = !!indexes,
      result = indexes || [],
      length = result.length;

  while (++index < propsLength) {
    var key = props[index];
    if (!(skipIndexes && (key == 'length' || isIndex(key, length))) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty$9.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = object[key],
      srcValue = source[key],
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    newValue = srcValue;
    if (isArray(srcValue) || isTypedArray(srcValue)) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else {
        isCommon = false;
        newValue = baseClone(srcValue, true);
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
        isCommon = false;
        newValue = baseClone(srcValue, true);
      }
      else {
        newValue = objValue;
      }
    }
    else {
      isCommon = false;
    }
  }
  stack.set(srcValue, newValue);

  if (isCommon) {
    
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
  }
  stack['delete'](srcValue);
  assignMergeValue(object, key, newValue);
}

function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  if (!(isArray(source) || isTypedArray(source))) {
    var props = keysIn(source);
  }
  arrayEach(props || source, function(srcValue, key) {
    if (props) {
      key = srcValue;
      srcValue = source[key];
    }
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  });
}

function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

function apply(func, thisArg, args) {
  var length = args.length;
  switch (length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

var FUNC_ERROR_TEXT$2 = 'Expected a function';


var nativeMax$2 = Math.max;


function rest(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  start = nativeMax$2(start === undefined ? (func.length - 1) : toInteger(start), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax$2(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, array);
      case 1: return func.call(this, args[0], array);
      case 2: return func.call(this, args[0], args[1], array);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

function createAssigner(assigner) {
  return rest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});

function baseSet(object, path, value, customizer) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]);
    if (isObject(nested)) {
      var newValue = value;
      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;
        if (newValue === undefined) {
          newValue = objValue == null
            ? (isIndex(path[index + 1]) ? [] : {})
            : objValue;
        }
      }
      assignValue(nested, key, newValue);
    }
    nested = nested[key];
  }
  return object;
}

function setWith(object, path, value, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  return object == null ? object : baseSet(object, path, value, customizer);
}

function indexOfNaN(array, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    var other = array[index];
    if (other !== other) {
      return index;
    }
  }
  return -1;
}

function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return indexOfNaN(array, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

function cacheHas(cache, key) {
  return cache.has(key);
}

function noop() {
  
}

var INFINITY$3 = 1 / 0;


var createSet = !(Set$1 && (1 / setToArray(new Set$1([,-0]))[1]) == INFINITY$3) ? noop : function(values) {
  return new Set$1(values);
};

var LARGE_ARRAY_SIZE$1 = 200;


function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE$1) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

function uniq(array) {
  return (array && array.length)
    ? baseUniq(array)
    : [];
}

function last(array) {
  var length = array ? array.length : 0;
  return length ? array[length - 1] : undefined;
}

function parent(object, path) {
  return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
}

function baseUnset(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);
  object = parent(object, path);

  var key = toKey(last(path));
  return !(object != null && baseHas(object, key)) || delete object[key];
}

function unset(object, path) {
  return object == null ? true : baseUnset(object, path);
}

function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

var LARGE_ARRAY_SIZE$2 = 200;


function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE$2) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

var without = rest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, values)
    : [];
});

function isObject$1(val) {
  var type = typeof val;
  return Boolean(val) && (type === 'object' || type === 'function')
}

function isArray$1(a) {
  return Array.isArray(a)
}

function clone(val) {
  if (isArray$1(val)) {
    return val.slice(0)
  }
  if (isObject$1(val)) {
    return Object.assign({}, val)
  }
  
  
  return val
}

function forEach(iteratee, func) {
  if (!iteratee) { return }
  if (iteratee.constructor.prototype.forEach) {
    iteratee.forEach(func);
  } else {
    Object.keys(iteratee).forEach(function(key) {
      return func(iteratee[key], key)
    });
  }
}

var platform = {

  inBrowser: false,

  
  isIE: false,
  

  isFF: false,

  isWebkit: false,

  
  version: -1,

  

  isWindows: false,

  isMac: false,

  
  
  _reset: detect
};

function detect() {

  if (typeof window !== 'undefined') {
    platform.inBrowser = true;

    
    var ua = window.navigator.userAgent;
    var msie = ua.indexOf('MSIE ');
    var trident = ua.indexOf('Trident/');
    var edge = ua.indexOf('Edge/');

    if (msie > 0) {
      
      platform.isIE = true;
      platform.version = 10;
      
      
    } else if (trident > 0) {
      
      platform.isIE = true;
      platform.version = 11;
      platform.isTrident = true;
      
      
      
    } else if (edge > 0) {
      
      platform.isIE = true;
      platform.isEdge = true;
      platform.version = 12;
      
      parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
    }

    
    platform.isFF = window.navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

    
    platform.isWebkit = !platform.isFF && !platform.isIE;
  } else {
    platform.inBrowser = false;
  }

  if (platform.inBrowser) {
    platform.isWindows = (window.navigator !== undefined && window.navigator.appVersion && window.navigator.appVersion.indexOf("Win") !== -1);
    platform.isMac = (window.navigator !== undefined && window.navigator.platform.indexOf('Mac') >= 0);
  }

  
  if (typeof process !== 'undefined') {
    platform.inNodeJS = true;
  }
}

detect();

function cloneDeep(val) {
  if (isArray$1(val)) {
    return _cloneArrayDeep(val);
  }
  
  
  
  if (platform.inBrowser && val instanceof window.File) {
    return val
  }
  if (isObject$1(val)) {
    return _cloneObjectDeep(val)
  }
  
  
  return val
}

function _cloneObjectDeep(obj) {
  var res = {};
  forEach(obj, function (val, key) {
    res[key] = cloneDeep(val);
  });
  return res
}

function _cloneArrayDeep(arr) {
  return arr.map(cloneDeep)
}

function createCountingIdGenerator() {
  var counters = {};
  return function uuid(prefix) {
    if (!counters.hasOwnProperty(prefix)) {
      counters[prefix] = 1;
    }
    var result = [prefix, '-', counters[prefix]++].join('');
    return result
  }
}

function isString$1(s) {
  return typeof s === 'string'
}

function levenshtein(a, b){
  var m = [];
  for(var i = 0; i <= b.length; i++) {
    m[i] = [i];
    if(i === 0) { continue; }
    var ib = i-1;
    for(var j = 0; j <= a.length; j++){
      m[0][j] = j;
      if(j === 0) { continue; }
      var jb = j-1;
      m[i][j] = b.charAt(ib) === a.charAt(jb) ? m[ib][jb] : Math.min(
        m[ib][jb]+1,
        m[i][jb]+1,
        m[ib][j]+1
      );
    }
  }
  return m
}

function diff(a, b, offset) {
  if (!isString$1(a) || !isString$1(b)) {
    throw new Error('Illegal arguments.')
  }
  offset = offset || 0;
  var changes = [];
  if (a || b) {
    if (!a && b) {
      changes.push({ type:'insert', start:offset, text:b });
    } else if (a && !b) {
      changes.push({ type:'delete', start:offset, end:offset+a.length });
    } else {
      var m = levenshtein(a, b);
      changes = _diff(a, b, m, offset);
    }
  }
  return changes
}

function _diff(a, b, m, offset) {
  var i = b.length;
  var j = a.length;
  var changes = [];
  var current;
  while (i>0 && j>0) {
    _next();
  }
  _commit();
  return changes

  function _next() {
    var d = m[i][j];
    var ib = i-1;
    var jb = j-1;
    
    if (m[ib][jb]<d) {
      if (current && current.type === 'replace') {
        current.start--;
        current.text.unshift(b.charAt(ib));
      } else {
        _commit();
        current = { type:'replace', start:jb, end:j, text:[b.charAt(ib)] };
      }
      i--;
      j--;
    }
    
    else if (m[ib][j]<d) {
      if (current && current.type === 'insert') {
        current.start--;
        current.text.unshift(b.charAt(ib));
      } else {
        _commit();
        current = { type:'insert', start:jb, text:[b.charAt(ib)] };
      }
      i--;
    }
    
    else if (m[i][jb]<d) {
      if (current && current.type === 'delete') {
        current.start--;
      } else {
        _commit();
        current = { type:'delete', start:jb, end:j };
      }
      j--;
    }
    
    else {
      _commit();
      i--;
      j--;
    }
  }

  function _commit() {
    if (current) {
      switch (current.type) {
        case 'insert':
          current.start += offset;
          current.text = current.text.join('');
          break
        case 'delete':
          current.start += offset;
          current.end += offset;
          break
        case 'replace':
          current.start += offset;
          current.end += offset;
          current.text = current.text.join('');
          break
        default:
          throw new Error('Invalid state')
      }
      changes.push(current);
      current = null;
    }
  }

}

function encodeXMLEntities(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
}

var DEBUG = false;
var count = 0;
var COUNT_MSG = '%s listeners registered in the whole system.';


var EventEmitter = function EventEmitter () {};

var prototypeAccessors$1 = { __events__: {} };

EventEmitter.prototype.emit = function emit (event) {
  if (event in this.__events__) {
    
    
    var bindings = this.__events__[event].slice();
    var args = Array.prototype.slice.call(arguments, 1);
    for (var i = 0, len = bindings.length; i < len; i++) {
      var binding = bindings[i];
      
      binding.method.apply(binding.context, args);
    }
    return true
  }
  return false
};


EventEmitter.prototype.on = function on (event, method, context) {
  
  _on.call(this, event, method, context);
};


EventEmitter.prototype.off = function off (event, method, context) { 
  if (arguments.length === 1 && isObject$1(arguments[0])) {
    _disconnect.call(this, arguments[0]);
  } else {
    _off.apply(this, arguments);
  }
};

EventEmitter.prototype._debugEvents = function _debugEvents () {
  
  console.log('### EventEmitter: ', this);
  forEach(this.__events__, function (handlers, name) {
    console.log("- %s listeners for %s: ", handlers.length, name, handlers);
  });
  
};

prototypeAccessors$1.__events__.get = function () {
  if (!this.___events___) {
    this.___events___ = {};
  }
  return this.___events___
};

Object.defineProperties( EventEmitter.prototype, prototypeAccessors$1 );


function _on(event, method, context) {
  
  var bindings;
  validateMethod( method, context );
  if (this.__events__.hasOwnProperty(event)) {
    bindings = this.__events__[event];
  } else {
    
    bindings = this.__events__[event] = [];
  }
  
  bindings.push({
    method: method,
    context: context || null
  });
  if (DEBUG) {
    count++;
    console.info('_on()', event, method.name, context, this);
    console.info(COUNT_MSG, count);
  }
  return this
  
}


function _off(event, method, context) {
  var this$1 = this;

  
  if (arguments.length === 0) {
    if (DEBUG) {
      forEach(this.__events__, function (bindings) {
        bindings.forEach(function (b) {
          console.info('_off()', b.method.name, b.context, this$1);
        });
        count -= bindings.length;
      });
      console.info(COUNT_MSG, count);
    }
    this.___events___ = {};
    return this
  }
  if (arguments.length === 1) {
    
    if (DEBUG) {
      count -= (this.__events__[event] || []).length;
      console.info(COUNT_MSG, count);
    }
    delete this.__events__[event];
    return this
  }
  validateMethod(method, context);
  if (!(event in this.__events__) || !this.__events__[event].length) {
    if (DEBUG) { console.info('NO MATCHING BINDINGS'); }
    
    return this
  }
  
  if (arguments.length < 3) {
    context = null;
  }
  
  var bindings = this.__events__[event];
  for (var i = bindings.length-1; i >= 0; i--) {
    var b = bindings[i];
    if (b.method === method && b.context === context) {
      bindings.splice(i, 1);
      if (DEBUG) { count--; }
    }
  }
  
  if (bindings.length === 0) {
    delete this.__events__[event];
  }
  if (DEBUG) { console.info(COUNT_MSG, count); }
  return this
  
}


function _disconnect(context) {
  var this$1 = this;

  
  
  forEach(this.__events__, function (bindings, event) {
    for (var i = bindings.length-1; i>=0; i--) {
      
      
      if (bindings[i] && bindings[i].context === context) {
        _off.call(this$1, event, bindings[i].method, context);
      }
    }
  });
  return this
  
}

function validateMethod(method, context) {
  
  if (typeof method === 'string') {
    
    if (context === undefined || context === null) {
      throw new Error( 'Method name "' + method + '" has no context.' )
    }
    if (!(method in context)) {
      
      
      throw new Error( 'Method not found: "' + method + '"' )
    }
    if (typeof context[method] !== 'function') {
      
      
      throw new Error( 'Property "' + method + '" is not a function' )
    }
  } else if (typeof method !== 'function') {
    throw new Error( 'Invalid callback. Function or method name expected.' )
  }
}

function extend() {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return Object.assign.apply(Object, args)
}

var PLAINOBJ = {};


var Registry = function Registry(entries, validator) {
  this.entries = {};
  this.names = [];
  this.validator = validator;

  if (entries) {
    forEach(entries, function(entry, name) {
      this.add(name, entry);
    }.bind(this));
  }
};


Registry.prototype.contains = function contains (name) {
  return this.entries.hasOwnProperty(name)
};


Registry.prototype.add = function add (name, entry) {
  if (this.validator) {
    this.validator(entry);
  }
  if (PLAINOBJ[name]) {
    throw new Error('Illegal key: "'+name+'" is a property of Object which is thus not allowed as a key.')
  }
  if (this.contains(name)) {
    this.remove(name);
  }
  this.entries[name] = entry;
  this.names.push(name);
};


Registry.prototype.remove = function remove (name) {
  var pos = this.names.indexOf(name);
  if (pos >= 0) {
    this.names.splice(pos, 1);
  }
  delete this.entries[name];
};


Registry.prototype.clear = function clear () {
  this.names = [];
  this.entries = {};
};


Registry.prototype.get = function get (name, strict) {
  var result = this.entries[name];
  if (strict && !result) {
    throw new Error('No entry registered for name '+name)
  }
  return result
};


Registry.prototype.forEach = function forEach$$1 (callback) {
    var this$1 = this;

  for (var i = 0; i < this.names.length; i++) {
    var name = this$1.names[i];
    var _continue = callback(this$1.entries[name], name);
    if (_continue === false) {
      break
    }
  }
};

Registry.prototype.map = function map (callback) {
  var result = [];
  this.forEach(function (entry, name) {
    result.push(callback(entry, name));
  });
  return result
};

Registry.prototype.filter = function filter (callback) {
  var result = [];
  this.forEach(function(entry, name) {
    if (callback(entry, name)) {
      result.push(entry);
    }
  });
  return result
};

Registry.prototype.values = function values () {
  return this.filter(function () { return true })
};

Registry.prototype._isRegistry = true;

var Factory = (function (Registry$$1) {
  function Factory () {
    Registry$$1.apply(this, arguments);
  }

  if ( Registry$$1 ) Factory.__proto__ = Registry$$1;
  Factory.prototype = Object.create( Registry$$1 && Registry$$1.prototype );
  Factory.prototype.constructor = Factory;

  Factory.prototype.create = function create (name) {
    var clazz = this.get(name);
    if (!clazz) {
      throw new Error( 'No class registered by that name: ' + name )
    }
    
    var args = Array.prototype.slice.call( arguments, 1 );
    var obj = Object.create( clazz.prototype );
    clazz.apply( obj, args );
    return obj
  };

  return Factory;
}(Registry));

function isFunction$1(f) {
  return typeof f === 'function'
}

function filter(iteratee, fn) {
  if (!iteratee) { return [] }
  if (iteratee.constructor.prototype.filter && isFunction$1(iteratee.constructor.prototype.filter)) {
    return iteratee.filter(fn)
  }
  var result = [];
  forEach(iteratee, function (val, key) {
    if (fn(val, key)) {
      result.push(val);
    }
  });
  return result
}

function findIndex$1(arr, predicate) {
  if (!isFunction$1(predicate)) { return arr.indexOf(predicate) }
  for (var i = 0; i < arr.length; i++) {
    if (predicate(arr[i])) { return i }
  }
  return -1
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr)
}

function flattenOften(arr, max) {
  if (!(max > 0)) { throw new Error("'max' must be a positive number") }
  var l = arr.length;
  arr = flatten(arr);
  var round = 1;
  while (round < max && l < arr.length) {
    l = arr.length;
    arr = flatten(arr);
    round++;
  }
  return arr
}

function map(iteratee, func) {
  if (!iteratee) { return [] }
  if (!func) { func = function(item) { return item }; }
  if (Array.isArray(iteratee)) {
    return iteratee.map(func)
  } else {
    return Object.keys(iteratee).map(function(key) {
      return func(iteratee[key], key)
    })
  }
}

function getRelativeBoundingRect(els, containerEl) {
  if (els.length === undefined) {
    els = [els];
  }
  var elRects = map(els, function(el) {
    return _getBoundingOffsetsRect(el, containerEl)
  });

  var elsRect = _getBoundingRect(elRects);
  var containerElRect = containerEl.getBoundingClientRect();
  return {
    left: elsRect.left,
    top: elsRect.top,
    right: containerElRect.width - elsRect.left - elsRect.width,
    bottom: containerElRect.height - elsRect.top - elsRect.height,
    width: elsRect.width,
    height: elsRect.height
  }
}


function _getBoundingRect(rects) {
  var bounds = {
    left: Number.POSITIVE_INFINITY,
    top: Number.POSITIVE_INFINITY,
    right: Number.NEGATIVE_INFINITY,
    bottom: Number.NEGATIVE_INFINITY,
    width: Number.NaN,
    height: Number.NaN
  };

  forEach(rects, function(rect) {
    if (rect.left < bounds.left) {
      bounds.left = rect.left;
    }
    if (rect.top < bounds.top) {
      bounds.top = rect.top;
    }
    if (rect.left + rect.width > bounds.right) {
      bounds.right = rect.left + rect.width;
    }
    if (rect.top + rect.height > bounds.bottom) {
      bounds.bottom = rect.top + rect.height;
    }
  });
  bounds.width = bounds.right - bounds.left;
  bounds.height = bounds.bottom - bounds.top;
  return bounds
}


function _getBoundingOffsetsRect(el, relativeParentEl) {
  var relativeParentElRect = relativeParentEl.getBoundingClientRect();
  var elRect = _getBoundingRect(el.getClientRects());

  var left = elRect.left - relativeParentElRect.left;
  var top = elRect.top - relativeParentElRect.top;
  return {
    left: left,
    top: top,
    right: relativeParentElRect.width - left - elRect.width,
    bottom: relativeParentElRect.height - top - elRect.height,
    width: elRect.width,
    height: elRect.height
  }
}

function getRelativeMouseBounds(mouseEvent, containerEl) {
  var containerElRect = containerEl.getBoundingClientRect();
  var left = mouseEvent.clientX - containerElRect.left;
  var top = mouseEvent.clientY - containerElRect.top;
  var res = {
    left: left,
    right: containerElRect.width - left,
    top: top,
    bottom: containerElRect.height - top
  };
  return res;
}

var inBrowser = platform.inBrowser;

function includes(arr, val) {
  if (!arr) { return false }
  return (arr.indexOf(val) >= 0)
}

function isArrayEqual(arr1, arr2) {
  if (arr1 === arr2) { return true }
  if (!isArray$1(arr1) || !isArray$1(arr2)) { return false }
  if (arr1.length !== arr2.length) { return false }
  var L = arr1.length;
  for (var i = 0; i < L; i++) {
    if (arr1[i] !== arr2[i]) { return false }
  }
  return true
}

function isBoolean(val) {
  return (val === true || val === false || (val && val.constructor === Boolean) )
}

function isPlainObject$1(o) {
  return Boolean(o) && o.constructor === {}.constructor
}

function isEqual(a, b) {
  if (a === b) { return true }
  if (isArray$1(a) && isArray$1(b)) {
    if (a.length !== b.length) { return false }
    for (var i = 0; i < a.length; i++) {
      if (!isEqual(a[i], b[i])) { return false }
    }
    return true
  }
  if (isPlainObject$1(a) && isPlainObject$1(b)) {
    var akeys = Object.keys(a).sort();
    var bkeys = Object.keys(b).sort();
    if (!isEqual(akeys, bkeys)) { return false }
    for (var i$1 = 0; i$1 < akeys.length; i$1++) {
      var key = akeys[i$1];
      if (!isEqual(a[key], b[key])) { return false }
    }
    return true
  }
  return false
}

function isNil(o) {
  return o === null || o === undefined
}

function isNumber(n) {
  return typeof n === 'number'
}

var keys$1 = {
  UNDEFINED: 0,
  BACKSPACE: 8,
  DELETE: 46,
  LEFT: 37,
  RIGHT: 39,
  UP: 38,
  DOWN: 40,
  ENTER: 13,
  END: 35,
  HOME: 36,
  TAB: 9,
  PAGEUP: 33,
  PAGEDOWN: 34,
  ESCAPE: 27,
  SHIFT: 16,
  SPACE: 32
};

function parseKeyEvent(event, onlyModifiers) {
  var frags = [];
  if (event.altKey) {
    if (event.code === 'AltRight') {
      frags.push('ALTGR');
    } else {
      frags.push('ALT');
    }
  }
  if (event.ctrlKey) { frags.push('CTRL'); }
  if (event.metaKey) { frags.push('META'); }
  if (event.shiftKey) { frags.push('SHIFT'); }
  if (!onlyModifiers) {
    frags.push(event.keyCode);
  }
  return frags.join('+')
}

function last$1(arr) {
  return arr[arr.length-1]
}

function makeMap(keys) {
  return keys.reduce(function(obj, key) {
    obj[key] = true;
    return obj
  }, {})
}

function merge$1(a, b, options) {
  options = options || {};
  var _with = null;
  if (options.array === 'replace') {
    _with = _replaceArrays;
  } else if (options.array === 'concat') {
    _with = _concatArrays;
  }
  if (_with) {
    return mergeWith(a, b, _with)
  } else {
    return merge(a, b)
  }
}

function _concatArrays(objValue, srcValue) {
  if (isArray$1(objValue)) {
    return objValue.concat(srcValue)
  } else {
    return null
  }
}

function _replaceArrays(objValue, srcValue) {
  if (isArray$1(objValue)) {
    return srcValue
  } else {
    return null
  }
}

var PathObject = function PathObject(root) {
  if (root) {
    this.__root__ = root;
  }
};

PathObject.prototype.contains = function contains (id) {
  return Boolean(this.getRoot()[id])
};

PathObject.prototype.getRoot = function getRoot () {
  if (this.__root__) {
    return this.__root__
  } else {
    return this
  }
};


PathObject.prototype.get = function get$1 (path) {
  if (!path) {
    return undefined
  }
  if (isString$1(path)) {
    return this.getRoot()[path]
  }
  if (arguments.length > 1) {
    path = Array.prototype.slice(arguments, 0);
  }
  if (!isArray$1(path)) {
    throw new Error('Illegal argument for PathObject.get()')
  }
  return get(this.getRoot(), path)
};

PathObject.prototype.set = function set (path, value) {
  if (!path) {
    throw new Error('Illegal argument: PathObject.set(>path<, value) - path is mandatory.')
  }
  if (isString$1(path)) {
    this.getRoot()[path] = value;
  } else {
    setWith(this.getRoot(), path, value);
  }
};

PathObject.prototype.delete = function delete$1 (path) {
  if (isString$1(path)) {
    delete this.getRoot()[path];
  } else if (path.length === 1) {
    delete this.getRoot()[path[0]];
  } else {
    var success = unset(this.getRoot(), path);
    if (!success) {
      throw new Error('Could not delete property at path' + path)
    }
  }
};

PathObject.prototype.clear = function clear () {
  var root = this.getRoot();
  for (var key in root) {
    if (root.hasOwnProperty(key)) {
      delete root[key];
    }
  }
};

PathObject.prototype._isPathObject = true;

function percentage(ratio) {
  return String(Math.floor(ratio*100*100)/100) + ' %'
}

var pluck = function(collection, prop) {
  return map(collection, function(item) { return item[prop] })
};

function printStacktrace() {
  try {
    throw new Error();
  } catch (err) {
    console.error(err.stack);
  }
}

function request(method, url, data, cb) {
  var request = new XMLHttpRequest();
  request.open(method, url, true);
  request.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
  request.onload = function() {
    if (request.status >= 200 && request.status < 400) {
      var res = request.responseText;
      if(isJson(res)) { res = JSON.parse(res); }
      cb(null, res);
    } else {
      return cb(new Error('Request failed. Returned status: ' + request.status))
    }
  };

  if (data) {
    request.send(JSON.stringify(data));
  } else {
    request.send();
  }
}

function isJson(str) {
  try {
    JSON.parse(str);
  } catch (e) {
    return false
  }
  return true
}

function sendRequest(params, cb) {
  return new Promise(function(resolve, reject) {
    var method = (params.method || 'GET').toUpperCase();
    var url = params.url;
    if (['GET', 'POST', 'PUT', 'DELETE'].indexOf(method) < 0) {
      throw new Error("Parameter 'method' must be 'GET', 'POST', 'PUT', or 'DELETE'.")
    }
    if (!url) {
      throw new Error("Parameter 'url' is required.")
    }
    var xmlhttp = new XMLHttpRequest();
    xmlhttp.onreadystatechange = function() {
      
      
      if (xmlhttp.readyState === 4) { return _done() }
    };
    xmlhttp.open(method, url, true);
    if (params.header) {
      forEach(params.header, function(val, key) {
        xmlhttp.setRequestHeader(key, val);
      });
    }
    if (params.data) {
      xmlhttp.send(JSON.stringify(params.data));
    } else {
      xmlhttp.send();
    }

    function _done() {
      if (xmlhttp.status === 200) {
        var response = xmlhttp.responseText;
        if (cb) { cb(null, response); }
        resolve(response);
      } else {
        console.error(xmlhttp.statusText);
        if (cb) { cb(xmlhttp.status); }
        reject(xmlhttp.statusText, xmlhttp.status);
      }
    }
  })
}

function startsWith(str, prefix) {
  if (!isString$1(str)) { return false }
  if (str.startsWith) { return str.startsWith(prefix) }
  if (!isString$1(prefix)) { prefix = String(prefix); }
  return str.slice(0, prefix.length) === prefix
}

var SubstanceError = (function (Error) {
  function SubstanceError(name, options) {
    Error.call(this, name, options);
    this.name = name;
    this.message = options.message;
    this.info = options.info;
    this.errorCode = options.errorCode;
    this.cause = options.cause;

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, (SubstanceError));
    }
  }

  if ( Error ) SubstanceError.__proto__ = Error;
  SubstanceError.prototype = Object.create( Error && Error.prototype );
  SubstanceError.prototype.constructor = SubstanceError;

  SubstanceError.prototype.inspect = function inspect () {
    var parts = [];

    
    parts.push(this.stack);

    
    if (this.info) {
      parts.push(this.info + '. ');
    }

    
    if (this.cause) {
      parts.push('\nCaused by: ');

      if (this.cause.inspect) {
        
        parts.push(this.cause.inspect());
      } else {
        
        parts.push(this.cause.toString());
      }
    }
    return parts.join('')
  };

  return SubstanceError;
}(Error));


SubstanceError.fromJSON = function(err) {
  if (!err) { return null }
  var error = new SubstanceError(err.name, {
    message: err.message,
    info: err.info,
    errorCode: err.errorCode,
    cause: SubstanceError.fromJSON(err.cause)
  });
  return error
};

var _global = (typeof global !== 'undefined') ? global : window;
var substanceGlobals = _global.hasOwnProperty('Substance') ? _global.Substance : _global.Substance = {
  DEBUG_RENDERING: true
};

function times(num, fn, ctx) {
  for (var i=0; i<num; i++) {
    fn.call(ctx);
  }
}

var TreeNode = function TreeNode () {};



var TreeIndex = function TreeIndex () {};

TreeIndex.prototype.get = function get$1 (path) {
  if (arguments.length > 1) {
    path = Array.prototype.slice(arguments, 0);
  }
  if (isString$1(path)) {
    path = [path];
  }
  return get(this, path);
};

TreeIndex.prototype.getAll = function getAll (path) {
  if (arguments.length > 1) {
    path = Array.prototype.slice(arguments, 0);
  }
  if (isString$1(path)) {
    path = [path];
  }
  if (!isArray$1(path)) {
    throw new Error('Illegal argument for TreeIndex.get()');
  }
  var node = get(this, path);
  return this._collectValues(node);
};

TreeIndex.prototype.set = function set (path, value) {
  if (isString$1(path)) {
    path = [path];
  }
  setWith(this, path, value, function(val) {
    if (!val) { return new TreeNode(); }
  });
};

TreeIndex.prototype.delete = function delete$1 (path) {
  if (isString$1(path)) {
    delete this[path];
  } else if(path.length === 1) {
    delete this[path[0]];
  } else {
    var key = path[path.length-1];
    path = path.slice(0, -1);
    var parent = get(this, path);
    if (parent) {
      delete parent[key];
    }
  }
};

TreeIndex.prototype.clear = function clear () {
  var root = this;
  for (var key in root) {
    if (root.hasOwnProperty(key)) {
      delete root[key];
    }
  }
};

TreeIndex.prototype.traverse = function traverse (fn) {
  this._traverse(this, [], fn);
};

TreeIndex.prototype.forEach = function forEach () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

  (ref = this).traverse.apply(ref, args);
    var ref;
};

TreeIndex.prototype._traverse = function _traverse (root, path, fn) {
    var this$1 = this;

  var id;
  for (id in root) {
    if (!root.hasOwnProperty(id)) { continue; }
    var child = root[id];
    var childPath = path.concat([id]);
    if (child instanceof TreeNode) {
      this$1._traverse(child, childPath, fn);
    } else {
      fn(child, childPath);
    }
  }
};

TreeIndex.prototype._collectValues = function _collectValues (root) {
  
  
  var vals = {};
  this._traverse(root, [], function(val, path) {
    var key = path[path.length-1];
    vals[key] = val;
  });
  return vals;
};

var TreeIndexArrays = (function (TreeIndex) {
  function TreeIndexArrays () {
    TreeIndex.apply(this, arguments);
  }

  if ( TreeIndex ) TreeIndexArrays.__proto__ = TreeIndex;
  TreeIndexArrays.prototype = Object.create( TreeIndex && TreeIndex.prototype );
  TreeIndexArrays.prototype.constructor = TreeIndexArrays;

  TreeIndexArrays.prototype.contains = function contains (path) {
    var val = TreeIndex.prototype.get.call(this, path);
    return Boolean(val)
  };

  TreeIndexArrays.prototype.get = function get$$1 (path) {
    var val = TreeIndex.prototype.get.call(this, path);
    if (val instanceof TreeNode) {
      val = val.__values__ || [];
    }
    return val;
  };

  TreeIndexArrays.prototype.set = function set (path, arr) {
    var val = TreeIndex.prototype.get.call(this, path);
    val.__values__ = arr;
  };

  TreeIndexArrays.prototype.add = function add (path, value) {
    if (isString$1(path)) {
      path = [path];
    }
    if (!isArray$1(path)) {
      throw new Error('Illegal arguments.');
    }
    var arr;

    
    
    
    
    
    
    setWith(this, path.concat(['__values__','__dummy__']), undefined, function(val, key) {
      if (key === '__values__') {
        if (!val) { val = []; }
        arr = val;
      } else if (!val) {
        val = new TreeNode();
      }
      return val;
    });
    delete arr.__dummy__;
    arr.push(value);
  };

  TreeIndexArrays.prototype.remove = function remove (path, value) {
    var arr = get(this, path);
    if (arr instanceof TreeNode) {
      if (arguments.length === 1) {
        delete arr.__values__;
      } else {
        deleteFromArray(arr.__values__, value);
      }
    }
  };

  TreeIndexArrays.prototype._collectValues = function _collectValues (root) {
    var vals = [];
    this._traverse(root, [], function(val) {
      vals.push(val);
    });
    vals = Array.prototype.concat.apply([], vals);
    return vals
  };

  return TreeIndexArrays;
}(TreeIndex));

TreeIndex.Arrays = TreeIndexArrays;

function uuid(prefix, len) {
  if (prefix && prefix[prefix.length-1] !== "-") {
    prefix = prefix.concat("-");
  }
  var chars = '0123456789abcdefghijklmnopqrstuvwxyz'.split('');
  var uuid = [];
  var radix = 16;
  var idx;
  len = len || 32;
  if (len) {
    
    for (idx = 0; idx < len; idx++) { uuid[idx] = chars[0 | Math.random()*radix]; }
  } else {
    
    var r;
    
    uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
    uuid[14] = '4';
    
    
    for (idx = 0; idx < 36; idx++) {
      if (!uuid[idx]) {
        r = 0 | Math.random()*16;
        uuid[idx] = chars[(idx === 19) ? (r & 0x3) | 0x8 : r];
      }
    }
  }
  return (prefix ? prefix : "") + uuid.join('');
}

function getDOMRangeFromEvent(evt) {
  var range, x = evt.clientX, y = evt.clientY;
  
  if (document.body.createTextRange) {
    range = document.body.createTextRange();
    range.moveToPoint(x, y);
  }
  else if (!isNil(document.createRange)) {
    
    
    if (!isNil(evt.rangeParent)) {
      range = document.createRange();
      range.setStart(evt.rangeParent, evt.rangeOffset);
      range.collapse(true);
    }
    
    else if (document.caretPositionFromPoint) {
      var pos = document.caretPositionFromPoint(x, y);
      range = document.createRange();
      range.setStart(pos.offsetNode, pos.offset);
      range.collapse(true);
    }
    
    else if (document.caretRangeFromPoint) {
      range = document.caretRangeFromPoint(x, y);
    }
  }
  return range
}


function getSelectionRect(parentRect) {
  if (platform.inBrowser) {
    var wsel = window.getSelection();
    if (wsel.rangeCount === 0) { return }
    var wrange = wsel.getRangeAt(0);
    var contentRect = parentRect;
    var selectionRect = wrange.getBoundingClientRect();
    if (selectionRect.top === 0 && selectionRect.bottom === 0) {
      selectionRect = _fixForCursorRectBug();
    }
    return getRelativeRect(contentRect, selectionRect)
  }
}

function _fixForCursorRectBug() {
  var wsel = window.getSelection();
  var el = wsel.anchorNode;
  if (!el) { return }
  while (el && el.nodeType !== 1) {
    el = el.parentNode;
  }
  var rects = el.getClientRects();
  var rect = rects[0];
  return {
    left: rect.left,
    top: rect.top,
    width: 0,
    height: rect.height,
    right: rect.width,
    bottom: rect.bottom
  }
}

function getRelativeRect(parentRect, childRect) {
  var left = childRect.left - parentRect.left;
  var top = childRect.top - parentRect.top;
  return {
    left: left,
    top: top,
    right: parentRect.width - left - childRect.width,
    bottom: parentRect.height - top - childRect.height,
    width: childRect.width,
    height: childRect.height
  }
}

function isMouseInsideDOMSelection(e) {
  var wsel = window.getSelection();
  if (wsel.rangeCount === 0) {
    return false
  }
  var wrange = wsel.getRangeAt(0);
  var selectionRect = wrange.getBoundingClientRect();
  return e.clientX >= selectionRect.left &&
         e.clientX <= selectionRect.right &&
         e.clientY >= selectionRect.top &&
         e.clientY <= selectionRect.bottom
}

var ServerRequest = function ServerRequest(message, ws) {
  this.message = message;
  this.ws = ws;
  this.isAuthenticated = false;
  this.isAuhorized = false;
};


ServerRequest.prototype.setAuthenticated = function setAuthenticated (session) {
  this.isAuthenticated = true;
  this.session = session;
};


ServerRequest.prototype.setAuthorized = function setAuthorized (authorizationData) {
  this.isAuthorized = true;
  this.authorizationData = authorizationData;
};


ServerRequest.prototype.setEnhanced = function setEnhanced () {
  this.isEnhanced = true;
};

var ServerResponse = function ServerResponse() {
  this.isReady = false; 
  this.isEnhanced = false; 
  this.isSent = false; 
  this.err = null;
  this.data = null;
};


ServerResponse.prototype.error = function error (err) {
  this.err = err;
  this.isReady = true;
};


ServerResponse.prototype.send = function send (data) {
  this.data = data;
  this.isReady = true;
};


ServerResponse.prototype.setEnhanced = function setEnhanced () {
  this.isEnhanced = true;
};

ServerResponse.prototype.setSent = function setSent () {
  this.isSent = true;
};

var Server = (function (EventEmitter$$1) {
  function Server(config) {
    EventEmitter$$1.call(this);

    this.config = config;
    this._onConnection = this._onConnection.bind(this);
  }

  if ( EventEmitter$$1 ) Server.__proto__ = EventEmitter$$1;
  Server.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  Server.prototype.constructor = Server;

  Server.prototype.bind = function bind (wss) {
    if (this.wss) {
      throw new Error('Server is already bound to a websocket')
    }
    this.wss = wss;
    this._connections = new WeakMap();
    this._collaborators = {};
    this.wss.on('connection', this._onConnection);

    var interval = this.config.heartbeat;
    if (interval) {
      this._heartbeat = setInterval(this._sendHeartbeat.bind(this), interval);
    }
    this._bound = true;
  };

  
  Server.prototype.unbind = function unbind () {
    if (this._bound) {
      this.wss.off('connection', this._onConnection);
    } else {
      throw new Error('Server is not yet bound to a websocket.')
    }
  };

  
  Server.prototype.onConnection = function onConnection () {
    
  };

  
  Server.prototype.onDisconnect = function onDisconnect () {
    
  };

  
  Server.prototype.authenticate = function authenticate (req, res) {
    req.setAuthenticated();
    this.next(req, res);
  };

  
  Server.prototype.authorize = function authorize (req, res) {
    req.setAuthorized();
    this.next(req, res);
  };


  
  Server.prototype.enhanceRequest = function enhanceRequest (req, res) {
    req.setEnhanced();
    this.next(req, res);
  };

  
  Server.prototype.execute = function execute () {
    throw new Error('This method needs to be specified')
  };

  
  Server.prototype.enhanceResponse = function enhanceResponse (req, res) {
    res.setEnhanced();
    this.next(req, res);
  };

  
  Server.prototype._onConnection = function _onConnection (ws) {
    var collaboratorId = uuid();
    var connection = {
      collaboratorId: collaboratorId
    };
    this._connections.set(ws, connection);

    
    this._collaborators[collaboratorId] = {
      connection: ws
    };

    ws.on('message', this._onMessage.bind(this, ws));
    ws.on('close', this._onClose.bind(this, ws));
  };

  
  Server.prototype._onClose = function _onClose (ws) {
    var conn = this._connections.get(ws);
    var collaboratorId = conn.collaboratorId;

    this.onDisconnect(collaboratorId);

    
    delete this._collaborators[collaboratorId];
    this._connections.delete(ws);
  };

  
  Server.prototype.__initial = function __initial (req, res) {
    return !req.isAuthenticated && !req.isAuthorized && !res.isReady
  };

  Server.prototype.__authenticated = function __authenticated (req, res) {
    return req.isAuthenticated && !req.isAuthorized && !res.isReady
  };

  Server.prototype.__authorized = function __authorized (req, res) {
    return req.isAuthenticated && req.isAuthorized && !req.isEnhanced && !res.isReady
  };

  Server.prototype.__requestEnhanced = function __requestEnhanced (req, res) {
    return req.isAuthenticated && req.isAuthorized && req.isEnhanced && !res.isReady
  };

  Server.prototype.__executed = function __executed (req, res) {
    
    return req.isAuthenticated && req.isAuthorized && res.isReady && res.data && !res.isEnhanced
  };

  Server.prototype.__enhanced = function __enhanced (req, res) {
    return res.isReady && res.isEnhanced && !res.isSent
  };

  Server.prototype.__error = function __error (req, res) {
    return res.err && !res.isSent
  };

  Server.prototype.__done = function __done (req, res) {
    return res.isSent
  };

  Server.prototype.next = function next (req, res) {
    if (this.__initial(req, res)) {
      this.authenticate(req, res);
    } else if (this.__authenticated(req, res)) {
      this.authorize(req, res);
    } else if (this.__authorized(req, res)) {
      this.enhanceRequest(req, res);
    } else if (this.__requestEnhanced(req, res)) {
      this.execute(req, res);
    } else if (this.__executed(req, res)) {
      this.enhanceResponse(req, res);
    } else if (this.__enhanced(req, res)) {
      this.sendResponse(req, res);
    } else if (this.__error(req, res)) {
      this.sendError(req, res);
    } else if (this.__done(req,res)) {
      
    }
  };

  
  Server.prototype.sendError = function sendError (req, res) {
    var collaboratorId = req.message.collaboratorId;
    var msg = res.err;
    this.send(collaboratorId, msg);
    res.setSent();
    this.next(req, res);
  };

  
  Server.prototype._sendHeartbeat = function _sendHeartbeat () {
    Object.keys(this._collaborators).forEach(function(collaboratorId) {
      this.send(collaboratorId, {
        type: 'highfive',
        scope: '_internal'
      });
    }.bind(this));
  };

  
  Server.prototype.sendResponse = function sendResponse (req, res) {
    var collaboratorId = req.message.collaboratorId;
    this.send(collaboratorId, res.data);
    res.setSent();
    this.next(req, res);
  };

  Server.prototype._isWebsocketOpen = function _isWebsocketOpen (ws) {
    return ws && ws.readyState === 1
  };

  
  Server.prototype.send = function send (collaboratorId, message) {
    if (!message.scope && this.config.scope) {
      message.scope = this.config.scope;
    }

    var ws = this._collaborators[collaboratorId].connection;
    if (this._isWebsocketOpen(ws)) {
      ws.send(this.serializeMessage(message));
    } else {
      console.error('Server#send: Websocket for collaborator', collaboratorId, 'is no longer open', message);
    }
  };

  
  Server.prototype.broadCast = function broadCast (collaborators, message) {
    collaborators.forEach(function(collaboratorId) {
      this.send(collaboratorId, message);
    }.bind(this));
  };

  
  Server.prototype._processRequest = function _processRequest (req) {
    var res = new ServerResponse();
    this.next(req, res);
  };

  
  Server.prototype._onMessage = function _onMessage (ws, msg) {
    
    var conn = this._connections.get(ws);
    msg = this.deserializeMessage(msg);

    if (msg.scope === this.scope) {
      
      msg.collaboratorId = conn.collaboratorId;
      var req = new ServerRequest(msg, ws);
      this._processRequest(req);
    }
  };

  Server.prototype.serializeMessage = function serializeMessage (msg) {
    return JSON.stringify(msg)
  };

  Server.prototype.deserializeMessage = function deserializeMessage (msg) {
    return JSON.parse(msg)
  };

  return Server;
}(EventEmitter));

var Selection = function Selection() {
  
  var _internal = {};
  Object.defineProperty(this, "_internal", {
    enumerable: false,
    value: _internal
  });
    
  _internal.doc = null;
};

var prototypeAccessors$2 = { type: {} };

Selection.prototype.clone = function clone () {
  var newSel = this._clone();
  if (this._internal.doc) {
    newSel.attach(this._internal.doc);
  }
  return newSel
};


Selection.prototype.getDocument = function getDocument () {
  var doc = this._internal.doc;
  if (!doc) {
    throw new Error('Selection is not attached to a document.')
  }
  return doc
};

Selection.prototype.isAttached = function isAttached () {
  return Boolean(this._internal.doc)
};


Selection.prototype.attach = function attach (doc) {
  this._internal.doc = doc;
  return this
};


Selection.prototype.isNull = function isNull () { return false; };


Selection.prototype.isPropertySelection = function isPropertySelection () { return false; };


Selection.prototype.isContainerSelection = function isContainerSelection () { return false; };


Selection.prototype.isNodeSelection = function isNodeSelection () { return false; };

Selection.prototype.isCustomSelection = function isCustomSelection () { return false; };


Selection.prototype.isCollapsed = function isCollapsed () { return true; };


Selection.prototype.isReverse = function isReverse () { return false; };

Selection.prototype.getType = function getType () {
  throw new Error('Selection.getType() is abstract.')
};

prototypeAccessors$2.type.get = function () {
  return this.getType()
};


Selection.prototype.equals = function equals (other) {
  if (this === other) {
    return true
  } else if (!other) {
    return false
  } else if (this.isNull() !== other.isNull()) {
    return false
  } else if (this.getType() !== other.getType()) {
    return false
  } else {
    
    
    return true
  }
};


Selection.prototype.toString = function toString () {
  return "null"
};


Selection.prototype.toJSON = function toJSON () {
  throw new Error('This method is abstract.')
};

Selection.prototype.createWith = function createWith (update) {
  var SelectionClass = this.constructor;
  var data = this.toJSON();
  Object.assign(data, update);
  return SelectionClass.fromJSON(data)
};

Object.defineProperties( Selection.prototype, prototypeAccessors$2 );


Selection.prototype._isSelection = true;


var NullSelection = (function (Selection) {
  function NullSelection () {
    Selection.apply(this, arguments);
  }

  if ( Selection ) NullSelection.__proto__ = Selection;
  NullSelection.prototype = Object.create( Selection && Selection.prototype );
  NullSelection.prototype.constructor = NullSelection;

  NullSelection.prototype.isNull = function isNull () {
    return true
  };

  NullSelection.prototype.getType = function getType () {
    return 'null'
  };

  NullSelection.prototype.toJSON = function toJSON () {
    return null
  };

  NullSelection.prototype.clone = function clone () {
    return this
  };

  return NullSelection;
}(Selection));



Selection.nullSelection = Object.freeze(new NullSelection());

var Coordinate = function Coordinate(path, offset) {
  
  if (arguments[0] === 'SKIP') { return }
  if (arguments.length === 1) {
    var data = arguments[0];
    this.path = data.path;
    this.offset = data.offset;
  } else {
    this.path = path;
    this.offset = offset;
  }
  if (!isArray$1(this.path)) {
    throw new Error('Invalid arguments: path should be an array.')
  }
  if (!isNumber(this.offset) || this.offset < 0) {
    throw new Error('Invalid arguments: offset must be a positive number.')
  }
};

Coordinate.prototype.equals = function equals (other) {
  return (other === this ||
    (isArrayEqual(other.path, this.path) && other.offset === this.offset) )
};

Coordinate.prototype.withCharPos = function withCharPos (offset) {
  return new Coordinate(this.path, offset)
};

Coordinate.prototype.getNodeId = function getNodeId () {
  return this.path[0]
};

Coordinate.prototype.getPath = function getPath () {
  return this.path
};

Coordinate.prototype.getOffset = function getOffset () {
  return this.offset
};

Coordinate.prototype.toJSON = function toJSON () {
  return {
    path: this.path.slice(),
    offset: this.offset
  }
};

Coordinate.prototype.toString = function toString () {
  return "(" + this.path.join('.') + ", " + this.offset + ")"
};

Coordinate.prototype.isPropertyCoordinate = function isPropertyCoordinate () {
  return this.path.length > 1
};

Coordinate.prototype.isNodeCoordinate = function isNodeCoordinate () {
  return this.path.length === 1
};

Coordinate.prototype.hasSamePath = function hasSamePath (other) {
  return isArrayEqual(this.path, other.path)
};

Coordinate.prototype._isCoordinate = true;

var PropertySelection = (function (Selection$$1) {
  function PropertySelection(path, startOffset, endOffset, reverse, containerId, surfaceId) {
    Selection$$1.call(this);

    if (arguments.length === 1) {
      var data = arguments[0];
      path = data.path;
      startOffset = data.startOffset;
      endOffset = data.endOffset;
      reverse = data.reverse;
      containerId = data.containerId;
      surfaceId = data.surfaceId;
    }

    if (!path || !isNumber(startOffset)) {
      throw new Error('Invalid arguments: `path` and `startOffset` are mandatory');
    }

    this.start = new Coordinate(path, startOffset);
    this.end = new Coordinate(path, isNumber(endOffset) ? endOffset : startOffset);

    
    this.reverse = Boolean(reverse);

    this.containerId = containerId;

    
    this.surfaceId = surfaceId;
  }

  if ( Selection$$1 ) PropertySelection.__proto__ = Selection$$1;
  PropertySelection.prototype = Object.create( Selection$$1 && Selection$$1.prototype );
  PropertySelection.prototype.constructor = PropertySelection;

  var prototypeAccessors = { path: {},startOffset: {},endOffset: {} };

  prototypeAccessors.path.get = function () {
    return this.start.path
  };

  prototypeAccessors.startOffset.get = function () {
    console.warn('DEPRECATED: Use sel.start.offset instead');
    return this.start.offset
  };

  prototypeAccessors.endOffset.get = function () {
    console.warn('DEPRECATED: Use sel.end.offset instead');
    return this.end.offset
  };

  
  PropertySelection.prototype.toJSON = function toJSON () {
    return {
      type: 'property',
      path: this.start.path,
      startOffset: this.start.offset,
      endOffset: this.end.offset,
      reverse: this.reverse,
      containerId: this.containerId,
      surfaceId: this.surfaceId
    }
  };

  PropertySelection.prototype.isPropertySelection = function isPropertySelection () {
    return true
  };

  PropertySelection.prototype.getType = function getType () {
    return 'property'
  };

  PropertySelection.prototype.isNull = function isNull () {
    return false
  };

  PropertySelection.prototype.isCollapsed = function isCollapsed () {
    return this.start.offset === this.end.offset;
  };

  PropertySelection.prototype.isReverse = function isReverse () {
    return this.reverse
  };

  PropertySelection.prototype.equals = function equals (other) {
    return (
      Selection$$1.prototype.equals.call(this, other) &&
      (this.start.equals(other.start) && this.end.equals(other.end))
    )
  };

  PropertySelection.prototype.toString = function toString () {
    
    return [
      "PropertySelection(", JSON.stringify(this.path), ", ",
      this.start.offset, " -> ", this.end.offset,
      (this.reverse?", reverse":""),
      (this.surfaceId?(", "+this.surfaceId):""),
      ")"
    ].join('')
  };

  
  PropertySelection.prototype.collapse = function collapse (direction) {
    var offset;
    if (direction === 'left') {
      offset = this.start.offset;
    } else {
      offset = this.end.offset;
    }
    return this.createWithNewRange(offset, offset)
  };

  
  

  
  PropertySelection.prototype.getPath = function getPath () {
    return this.start.path;
  };

  PropertySelection.prototype.getNodeId = function getNodeId () {
    return this.start.path[0];
  };

  
  PropertySelection.prototype.isInsideOf = function isInsideOf (other, strict) {
    if (other.isNull()) { return false }
    if (other.isContainerSelection()) {
      return other.contains(this, strict)
    }
    if (strict) {
      return (isArrayEqual(this.path, other.path) &&
        this.start.offset > other.start.offset &&
        this.end.offset < other.end.offset);
    } else {
      return (isArrayEqual(this.path, other.path) &&
        this.start.offset >= other.start.offset &&
        this.end.offset <= other.end.offset);
    }
  };

  
  PropertySelection.prototype.contains = function contains (other, strict) {
    if (other.isNull()) { return false }
    return other.isInsideOf(this, strict)
  };

  
  PropertySelection.prototype.overlaps = function overlaps (other, strict) {
    if (other.isNull()) { return false }
    if (other.isContainerSelection()) {
      
      return other.overlaps(this)
    }
    if (!isArrayEqual(this.path, other.path)) { return false }
    if (strict) {
      return (! (this.start.offset>=other.end.offset||this.end.offset<=other.start.offset) );
    } else {
      return (! (this.start.offset>other.end.offset||this.end.offset<other.start.offset) );
    }
  };

  
  PropertySelection.prototype.isRightAlignedWith = function isRightAlignedWith (other) {
    if (other.isNull()) { return false }
    if (other.isContainerSelection()) {
      
      return other.isRightAlignedWith(this)
    }
    return (isArrayEqual(this.path, other.path) &&
      this.end.offset === other.end.offset);
  };

  
  PropertySelection.prototype.isLeftAlignedWith = function isLeftAlignedWith (other) {
    if (other.isNull()) { return false }
    if (other.isContainerSelection()) {
      
      return other.isLeftAlignedWith(this)
    }
    return (isArrayEqual(this.path, other.path) &&
      this.start.offset === other.start.offset);
  };

  
  PropertySelection.prototype.expand = function expand (other) {
    if (other.isNull()) { return this }

    
    
    
    if (other.isContainerSelection()) {
      return other.expand(this)
    }
    if (!isArrayEqual(this.path, other.path)) {
      throw new Error('Can not expand PropertySelection to a different property.')
    }
    var newStartOffset = Math.min(this.start.offset, other.start.offset);
    var newEndOffset = Math.max(this.end.offset, other.end.offset);
    return this.createWithNewRange(newStartOffset, newEndOffset);
  };

  
  PropertySelection.prototype.truncateWith = function truncateWith (other) {
    if (other.isNull()) { return this }
    if (other.isInsideOf(this, 'strict')) {
      
      throw new Error('Can not truncate with a contained selections')
    }
    if (!this.overlaps(other)) {
      return this
    }
    var otherStartOffset, otherEndOffset;
    if (other.isPropertySelection()) {
      otherStartOffset = other.start.offset;
      otherEndOffset = other.end.offset;
    } else if (other.isContainerSelection()) {
      
      if (isArrayEqual(other.start.path, this.start.path)) {
        otherStartOffset = other.start.offset;
      } else {
        otherStartOffset = this.start.offset;
      }
      if (isArrayEqual(other.end.path, this.start.path)) {
        otherEndOffset = other.end.offset;
      } else {
        otherEndOffset = this.end.offset;
      }
    } else {
      return this
    }

    var newStartOffset;
    var newEndOffset;
    if (this.start.offset > otherStartOffset && this.end.offset > otherEndOffset) {
      newStartOffset = otherEndOffset;
      newEndOffset = this.end.offset;
    } else if (this.start.offset < otherStartOffset && this.end.offset < otherEndOffset) {
      newStartOffset = this.start.offset;
      newEndOffset = otherStartOffset;
    } else if (this.start.offset === otherStartOffset) {
      if (this.end.offset <= otherEndOffset) {
        return Selection$$1.nullSelection;
      } else {
        newStartOffset = otherEndOffset;
        newEndOffset = this.end.offset;
      }
    } else if (this.end.offset === otherEndOffset) {
      if (this.start.offset >= otherStartOffset) {
        return Selection$$1.nullSelection;
      } else {
        newStartOffset = this.start.offset;
        newEndOffset = otherStartOffset;
      }
    } else if (other.contains(this)) {
      return Selection$$1.nullSelection
    } else {
      
      throw new Error('Illegal state.')
    }
    return this.createWithNewRange(newStartOffset, newEndOffset)
  };

  
  PropertySelection.prototype.createWithNewRange = function createWithNewRange (startOffset, endOffset) {
    var sel = new PropertySelection(this.path, startOffset, endOffset, false, this.containerId, this.surfaceId);
    var doc = this._internal.doc;
    if (doc) {
      sel.attach(doc);
    }
    return sel
  };

  PropertySelection.prototype._clone = function _clone () {
    return new PropertySelection(this.start.path, this.start.offset, this.end.offset, this.reverse, this.containerId, this.surfaceId);
  };

  Object.defineProperties( PropertySelection.prototype, prototypeAccessors );

  return PropertySelection;
}(Selection));

PropertySelection.fromJSON = function(json) {
  return new PropertySelection(json)
};

var ContainerSelection = (function (Selection$$1) {
  function ContainerSelection(containerId, startPath, startOffset, endPath, endOffset, reverse, surfaceId) {
    Selection$$1.call(this);

    if (arguments.length === 1) {
      var data = arguments[0];
      containerId = data.containerId;
      startPath = data.startPath;
      startOffset = data.startOffset;
      endPath = data.endPath;
      endOffset = data.endOffset;
      reverse = data.reverse;
      surfaceId = data.surfaceId;
    }

    
    this.containerId = containerId;
    if (!this.containerId) { throw new Error('Invalid arguments: `containerId` is mandatory') }

    this.start = new Coordinate(startPath, startOffset);
    this.end = new Coordinate(isNil(endPath) ? startPath : endPath, isNil(endOffset) ? startOffset : endOffset);

    this.reverse = Boolean(reverse);

    this.surfaceId = surfaceId;
  }

  if ( Selection$$1 ) ContainerSelection.__proto__ = Selection$$1;
  ContainerSelection.prototype = Object.create( Selection$$1 && Selection$$1.prototype );
  ContainerSelection.prototype.constructor = ContainerSelection;

  var prototypeAccessors = { startPath: {},startOffset: {},endPath: {},endOffset: {},path: {} };

  

  prototypeAccessors.startPath.get = function () {
    console.warn('DEPRECATED: use sel.start.path instead.');
    return this.start.path
  };

  prototypeAccessors.startOffset.get = function () {
    console.warn('DEPRECATED: use sel.start.offset instead.');
    return this.start.offset
  };

  prototypeAccessors.endPath.get = function () {
    console.warn('DEPRECATED: use sel.end.path instead.');
    return this.end.path
  };

  prototypeAccessors.endOffset.get = function () {
    console.warn('DEPRECATED: use sel.end.offset instead.');
    return this.end.offset
  };

  

  ContainerSelection.prototype.toJSON = function toJSON () {
    return {
      type: 'container',
      containerId: this.containerId,
      startPath: this.start.path,
      startOffset: this.start.offset,
      endPath: this.end.path,
      endOffset: this.end.offset,
      reverse: this.reverse,
      surfaceId: this.surfaceId
    }
  };

  ContainerSelection.prototype.isContainerSelection = function isContainerSelection () {
    return true
  };

  ContainerSelection.prototype.getType = function getType () {
    return 'container'
  };

  ContainerSelection.prototype.isNull = function isNull () {
    return false
  };

  ContainerSelection.prototype.isCollapsed = function isCollapsed () {
    return this.start.equals(this.end)
  };

  ContainerSelection.prototype.isReverse = function isReverse () {
    return this.reverse
  };

  ContainerSelection.prototype.equals = function equals (other) {
    return (
      Selection$$1.prototype.equals.call(this, other) &&
      this.containerId === other.containerId &&
      (this.start.equals(other.start) && this.end.equals(other.end))
    )
  };

  ContainerSelection.prototype.toString = function toString () {
    
    return [
      "ContainerSelection(",
      this.containerId, ", ",
      JSON.stringify(this.start.path), ", ", this.start.offset,
      " -> ",
      JSON.stringify(this.end.path), ", ", this.end.offset,
      (this.reverse?", reverse":""),
      (this.surfaceId?(", "+this.surfaceId):""),
      ")"
    ].join('')
  };

  
  ContainerSelection.prototype.getContainer = function getContainer () {
    if (!this._internal.container) {
      this._internal.container = this.getDocument().get(this.containerId);
    }
    return this._internal.container
  };

  ContainerSelection.prototype.isInsideOf = function isInsideOf (other, strict) {
    
    
    if (other.isNull()) { return false }
    strict = Boolean(strict);
    var r1 = this._range(this);
    var r2 = this._range(other);
    return (r2.start.isBefore(r1.start, strict) &&
      r1.end.isBefore(r2.end, strict))
  };

  ContainerSelection.prototype.contains = function contains (other, strict) {
    
    
    if (other.isNull()) { return false }
    strict = Boolean(strict);
    var r1 = this._range(this);
    var r2 = this._range(other);
    return (r1.start.isBefore(r2.start, strict) &&
      r2.end.isBefore(r1.end, strict))
  };

  ContainerSelection.prototype.containsNode = function containsNode (nodeId, strict) {
    var container = this.getContainer();
    if (!container.contains(nodeId)) { return false }
    var coor = new Coordinate([nodeId], 0);
    var address = container.getAddress(coor);
    var r = this._range(this);
    
    var contained = r.start.isBefore(address, strict);
    if (contained) {
      address.offset = 1;
      contained = r.end.isAfter(address, strict);
    }
    return contained
  };

  ContainerSelection.prototype.overlaps = function overlaps (other) {
    var r1 = this._range(this);
    var r2 = this._range(other);
    
    return !(r1.end.isBefore(r2.start, false) ||
      r2.end.isBefore(r1.start, false))
  };

  ContainerSelection.prototype.isLeftAlignedWith = function isLeftAlignedWith (other) {
    var r1 = this._range(this);
    var r2 = this._range(other);
    return r1.start.isEqual(r2.start)
  };

  ContainerSelection.prototype.isRightAlignedWith = function isRightAlignedWith (other) {
    var r1 = this._range(this);
    var r2 = this._range(other);
    return r1.end.isEqual(r2.end)
  };

  
  ContainerSelection.prototype.collapse = function collapse (direction) {
    var coor;
    if (direction === 'left') {
      coor = this.start;
    } else {
      coor = this.end;
    }
    return _createNewSelection(this, coor, coor)
  };

  ContainerSelection.prototype.expand = function expand (other) {
    var r1 = this._range(this);
    var r2 = this._range(other);
    var start;
    var end;

    if (r1.start.isEqual(r2.start)) {
      start = new Coordinate(this.start.path, Math.min(this.start.offset, other.start.offset));
    } else if (r1.start.isAfter(r2.start)) {
      start = new Coordinate(other.start.path, other.start.offset);
    } else {
      start = this.start;
    }
    if (r1.end.isEqual(r2.end)) {
      end = new Coordinate(this.end.path, Math.max(this.end.offset, other.end.offset));
    } else if (r1.end.isBefore(r2.end, false)) {
      end = new Coordinate(other.end.path, other.end.offset);
    } else {
      end = this.end;
    }

    return _createNewSelection(this, start, end)
  };

  ContainerSelection.prototype.truncateWith = function truncateWith (other) {
    if (other.isInsideOf(this, 'strict')) {
      
      throw new Error('Can not truncate with a contained selections')
    }
    if (!this.overlaps(other)) {
      return this
    }
    var r1 = this._range(this);
    var r2 = this._range(other);
    var start, end;
    if (r2.start.isBefore(r1.start, 'strict') && r2.end.isBefore(r1.end, 'strict')) {
      start = other.end;
      end = this.end;
    } else if (r1.start.isBefore(r2.start, 'strict') && r1.end.isBefore(r2.end, 'strict')) {
      start = this.start;
      end = other.start;
    } else if (r1.start.isEqual(r2.start)) {
      if (r2.end.isBefore(r1.end, 'strict')) {
        start = other.end;
        end = this.end;
      } else {
        
        return Selection$$1.nullSelection
      }
    } else if (r1.end.isEqual(r2.end)) {
      if (r1.start.isBefore(r2.start, 'strict')) {
        start = this.start;
        end = other.start;
      } else {
        
        return Selection$$1.nullSelection
      }
    } else if (this.isInsideOf(other)) {
      return Selection$$1.nullSelection
    } else {
      throw new Error('Could not determine coordinates for truncate. Check input')
    }
    return _createNewSelection(this, start, end)
  };

  
  ContainerSelection.prototype.getNodeIds = function getNodeIds () {
    var container = this.getContainer();
    var startPos = container.getPosition(this.start.path[0]);
    var endPos = container.getPosition(this.end.path[0]);
    return container.nodes.slice(startPos, endPos+1)
  };

  
  ContainerSelection.prototype.splitIntoPropertySelections = function splitIntoPropertySelections () {
    var sels = [];
    var fragments = this.getFragments();
    fragments.forEach(function(fragment) {
      if (fragment instanceof Selection$$1.Fragment) {
        sels.push(
          new PropertySelection(fragment.path, fragment.startOffset,
            fragment.endOffset, false, this.containerId, this.surfaceId)
        );
      }
    }.bind(this));
    return sels
  };

  ContainerSelection.prototype._clone = function _clone () {
    return new ContainerSelection(this)
  };

  ContainerSelection.prototype._range = function _range (sel) {
    
    
    
    if (sel._internal.addressRange) {
      return sel._internal.addressRange
    }

    var container = this.getContainer();
    var startAddress = container.getAddress(sel.start);
    var endAddress;
    if (sel.isCollapsed()) {
      endAddress = startAddress;
    } else {
      endAddress = container.getAddress(sel.end);
    }
    var addressRange = {
      start: startAddress,
      end: endAddress
    };
    if (sel._isContainerSelection) {
      sel._internal.addressRange = addressRange;
    }
    return addressRange
  };

  prototypeAccessors.path.get = function () {
    throw new Error('ContainerSelection has no path property. Use startPath and endPath instead')
  };

  Object.defineProperties( ContainerSelection.prototype, prototypeAccessors );

  return ContainerSelection;
}(Selection));

ContainerSelection.prototype._isContainerSelection = true;

ContainerSelection.fromJSON = function(properties) {
  var sel = new ContainerSelection(properties);
  return sel
};

function _createNewSelection(containerSel, start, end) {
  var newSel;

  if (start === end) {
    newSel = new PropertySelection({
      path: start.path,
      startOffset: start.offset,
      endOffset: start.offset,
      containerId: containerSel.containerId,
      surfaceId: containerSel.surfaceId
    });
  } else {
    newSel = new ContainerSelection(containerSel.containerId,
    start.path, start.offset, end.path, end.offset, false, containerSel.surfaceId);
  }
  
  var doc = containerSel._internal.doc;
  if (doc) {
    newSel.attach(doc);
  }
  return newSel
}

var NodeSelection = (function (Selection$$1) {
  function NodeSelection(containerId, nodeId, mode, reverse, surfaceId) {
    Selection$$1.call(this);

    if (arguments.length === 1) {
      var data = arguments[0];
      containerId = data.containerId;
      nodeId = data.nodeId;
      mode = data.mode;
      reverse = data.reverse;
      surfaceId = data.surfaceId;
    }

    if (!isString$1(containerId)) {
      throw new Error("'containerId' is mandatory.");
    }
    if (!isString$1(nodeId)) {
      throw new Error("'nodeId' is mandatory.");
    }
    mode = mode || "full";

    this.containerId = containerId;
    this.nodeId = nodeId;
    this.mode = mode;
    this.reverse = Boolean(reverse);
    this.surfaceId = surfaceId;

    this.start = new Coordinate([nodeId], 0);
    this.end = new Coordinate([nodeId], 1);
  }

  if ( Selection$$1 ) NodeSelection.__proto__ = Selection$$1;
  NodeSelection.prototype = Object.create( Selection$$1 && Selection$$1.prototype );
  NodeSelection.prototype.constructor = NodeSelection;

  NodeSelection.prototype.equals = function equals (other) {
    return (
      Selection$$1.prototype.equals.call(this, other) &&
      this.nodeId === other.nodeId &&
      this.mode === other.mode
    )
  };

  NodeSelection.prototype.isNodeSelection = function isNodeSelection () {
    return true;
  };

  NodeSelection.prototype.getType = function getType () {
    return 'node';
  };

  NodeSelection.prototype.getNodeId = function getNodeId () {
    return this.nodeId;
  };

  NodeSelection.prototype.isFull = function isFull () {
    return this.mode === 'full';
  };

  NodeSelection.prototype.isBefore = function isBefore () {
    return this.mode === 'before';
  };

  NodeSelection.prototype.isAfter = function isAfter () {
    return this.mode === 'after';
  };

  NodeSelection.prototype.isCollapsed = function isCollapsed () {
    return this.mode !== 'full';
  };

  NodeSelection.prototype.toJSON = function toJSON () {
    return {
      type: 'node',
      nodeId: this.nodeId,
      mode: this.mode,
      reverse: this.reverse,
      containerId: this.containerId,
      surfaceId: this.surfaceId
    };
  };

  NodeSelection.prototype.toString = function toString () {
    
    return [
      "NodeSelection(",
      this.containerId, ".", this.nodeId, ", ",
      this.mode, ", ",
      (this.reverse?", reverse":""),
      (this.surfaceId?(", "+this.surfaceId):""),
      ")"
    ].join('');
  };

  NodeSelection.prototype.collapse = function collapse (direction) {
    if (direction === 'left') {
      if (this.isBefore()) {
        return this;
      } else {
        return new NodeSelection(this.containerId, this.nodeId, 'before', this.reverse, this.surfaceId);
      }
    } else if (direction === 'right') {
      if (this.isAfter()) {
        return this;
      } else {
        return new NodeSelection(this.containerId, this.nodeId, 'after', this.reverse, this.surfaceId);
      }
    } else {
      throw new Error("'direction' must be either 'left' or 'right'");
    }
  };

  NodeSelection.prototype._getCoordinate = function _getCoordinate () {
    if (this.mode === 'before') {
      return new Coordinate([this.nodeId], 0);
    } else if (this.mode === 'after') {
      return new Coordinate([this.nodeId], 1);
    }
  };

  NodeSelection.prototype._clone = function _clone () {
    return new NodeSelection(this);
  };

  return NodeSelection;
}(Selection));

NodeSelection.prototype._isNodeSelection = true;

NodeSelection.fromJSON = function(json) {
  return new NodeSelection(json);
};


NodeSelection._createFromCoordinate = function(coor) {
  var containerId = coor.containerId;
  var nodeId = coor.getNodeId();
  var mode = coor.offset === 0 ? 'before' : 'after';
  return new NodeSelection(containerId, nodeId, mode, false);
};

var CustomSelection = (function (Selection$$1) {
  function CustomSelection(customType, data, surfaceId) {
    Selection$$1.call(this);

    if (arguments.length === 1) {
      var _data = arguments[0];
      customType = _data.customType;
      data = _data.data;
      surfaceId = _data.surfaceId;
    }

    this.customType = customType;
    this.data = data || {};
    this.surfaceId = surfaceId;
  }

  if ( Selection$$1 ) CustomSelection.__proto__ = Selection$$1;
  CustomSelection.prototype = Object.create( Selection$$1 && Selection$$1.prototype );
  CustomSelection.prototype.constructor = CustomSelection;

  CustomSelection.prototype.isCustomSelection = function isCustomSelection () {
    return true;
  };

  CustomSelection.prototype.getType = function getType () {
    return 'custom';
  };

  CustomSelection.prototype.getCustomType = function getCustomType () {
    return this.customType;
  };

  CustomSelection.prototype.toJSON = function toJSON () {
    return {
      type: 'custom',
      customType: this.customType,
      data: cloneDeep(this.data),
      surfaceId: this.surfaceId
    };
  };

  CustomSelection.prototype.toString = function toString () {
    
    return [
      'CustomSelection(',
      this.customType,', ',
      JSON.stringify(this.data),
      ")"
    ].join('');
  };

  CustomSelection.prototype.equals = function equals (other) {
    return (
      Selection$$1.prototype.equals.call(this, other) &&
      other.isCustomSelection() &&
      isEqual(this.data, other.data)
    );
  };

  CustomSelection.prototype._clone = function _clone () {
    return new CustomSelection(this)
  };

  return CustomSelection;
}(Selection));

CustomSelection.prototype._isCustomSelection = true;

CustomSelection.fromJSON = function(json) {
  return new CustomSelection(json);
};

function fromJSON(json) {
  if (!json) { return Selection.nullSelection }
  var type = json.type;
  switch(type) {
    case 'property':
      return PropertySelection.fromJSON(json)
    case 'container':
      return ContainerSelection.fromJSON(json)
    case 'node':
      return NodeSelection.fromJSON(json)
    case 'custom':
      return CustomSelection.fromJSON(json)
    default:
      
      return Selection.nullSelection
  }
}


function isFirst(doc, coor) {
  if (coor.isNodeCoordinate() && coor.offset === 0) { return true }
  var node = doc.get(coor.path[0]).getRoot();
  if (node.isText() && coor.offset === 0) { return true }
  if (node.isList()) {
    var itemId = coor.path[0];
    if (node.items[0] === itemId && coor.offset === 0) { return true }
  }
}


function isLast(doc, coor) {
  if (coor.isNodeCoordinate() && coor.offset > 0) { return true }
  var node = doc.get(coor.path[0]).getRoot();
  if (node.isText() && coor.offset >= node.getLength()) { return true }
  if (node.isList()) {
    var itemId = coor.path[0];
    var item = doc.get(itemId);
    if (last$1(node.items) === itemId && coor.offset === item.getLength()) { return true }
  }
}

function isEntirelySelected(doc, node, start, end) {
  var ref = getRangeInfo(doc, node, start, end);
  var isEntirelySelected = ref.isEntirelySelected;
  return isEntirelySelected
}

function getRangeInfo(doc, node, start, end) {
  var isFirst = true;
  var isLast = true;
  if (node.isText()) {
    if (start && start.offset !== 0) { isFirst = false; }
    if (end && end.offset < node.getLength()) { isLast = false; }
  } else if (node.isList()) {
    if (start) {
      var itemId = start.path[0];
      var itemPos = node.getItemPosition(itemId);
      if (itemPos > 0 || start.offset !== 0) { isFirst = false; }
    }
    if (end) {
      var itemId$1 = end.path[0];
      var itemPos$1 = node.getItemPosition(itemId$1);
      var item = doc.get(itemId$1);
      if (itemPos$1 < node.items.length-1 || end.offset < item.getLength()) { isLast = false; }
    }
  }
  var isEntirelySelected = isFirst && isLast;
  return {isFirst: isFirst, isLast: isLast, isEntirelySelected: isEntirelySelected}
}

function setCursor(tx, node, containerId, mode) {
  if (node.isText()) {
    var offset = 0;
    if (mode === 'after') {
      var text = node.getText();
      offset = text.length;
    }
    tx.setSelection({
      type: 'property',
      path: node.getTextPath(),
      startOffset: offset,
      containerId: containerId
    });
  } else if (node.isList()) {
    var item, offset$1;
    if (mode === 'after') {
      item = node.getLastItem();
      offset$1 = item.getLength();
    } else {
      item = node.getFirstItem();
      offset$1 = 0;
    }
    tx.setSelection({
      type: 'property',
      path: item.getTextPath(),
      startOffset: offset$1,
      containerId: containerId
    });
  } else {
    tx.setSelection({
      type: 'node',
      containerId: containerId,
      nodeId: node.id,
      
      
      
    });
  }
}

function selectNode(tx, nodeId, containerId) {
  tx.setSelection(createNodeSelection({ doc: tx, nodeId: nodeId, containerId: containerId }));
}

function createNodeSelection(ref) {
  var doc = ref.doc;
  var nodeId = ref.nodeId;
  var containerId = ref.containerId;
  var mode = ref.mode;
  var reverse = ref.reverse;
  var surfaceId = ref.surfaceId;

  var node = doc.get(nodeId);
  if (!node) { return Selection.nullSelection }
  node = node.getRoot();
  if (node.isText()) {
    return new PropertySelection({
      path: node.getTextPath(),
      startOffset: mode === 'after' ? node.getLength() : 0,
      endOffset: mode === 'before' ? 0 : node.getLength(),
      reverse: reverse,
      containerId: containerId,
      surfaceId: surfaceId
    })
  } else if (node.isList() && node.getLength()>0) {
    var first = node.getFirstItem();
    var last$$1 = node.getLastItem();
    var start = {
      path: first.getTextPath(),
      offset: 0
    };
    var end = {
      path: last$$1.getTextPath(),
      offset: last$$1.getLength()
    };
    if (mode === 'after') { start = end; }
    else if (mode === 'before') { end = start; }
    return new ContainerSelection({
      startPath: start.path,
      startOffset: start.offset,
      endPath: end.path,
      endOffset: end.offset,
      reverse: reverse,
      containerId: containerId,
      surfaceId: surfaceId
    })
  } else {
    return new NodeSelection({ nodeId: nodeId, mode: mode, reverse: reverse, containerId: containerId, surfaceId: surfaceId })
  }
}

function stepIntoIsolatedNode(editorSession, comp) {
  
  
  if (comp.grabFocus()) { return true }

  
  var surface = comp.find('.sc-surface');
  if (surface) {
    if (surface._isTextPropertyEditor) {
      var doc = editorSession.getDocument();
      var path = surface.getPath();
      var text = doc.get(path, 'strict');
      editorSession.setSelection({
        type: 'property',
        path: path,
        startOffset: text.length,
        surfaceId: surface.id
      });
      return true
    } else if (surface._isContainerEditor) {
      var container = surface.getContainer();
      if (container.length > 0) {
        var first = container.getChildAt(0);
        setCursor(editorSession, first, container.id, 'after');
      }
      return true
    }
  }
  return false
}


var selectionHelpers = Object.freeze({
	fromJSON: fromJSON,
	isFirst: isFirst,
	isLast: isLast,
	isEntirelySelected: isEntirelySelected,
	getRangeInfo: getRangeInfo,
	setCursor: setCursor,
	selectNode: selectNode,
	createNodeSelection: createNodeSelection,
	stepIntoIsolatedNode: stepIntoIsolatedNode
});

var Conflict = (function (Error) {
  function Conflict(a, b) {
    Error.call(this, "Conflict: " + JSON.stringify(a) +" vs " + JSON.stringify(b));
    this.a = a;
    this.b = b;
  }

  if ( Error ) Conflict.__proto__ = Error;
  Conflict.prototype = Object.create( Error && Error.prototype );
  Conflict.prototype.constructor = Conflict;

  return Conflict;
}(Error));

var INSERT = "insert";
var DELETE$1 = "delete";

var TextOperation = function TextOperation(data) {
  if (!data || data.type === undefined || data.pos === undefined || data.str === undefined) {
    throw new Error("Illegal argument: insufficient data.")
  }
  
  this.type = data.type;
  
  this.pos = data.pos;
  
  this.str = data.str;
  
  if(!this.isInsert() && !this.isDelete()) {
    throw new Error("Illegal type.")
  }
  if (!isString$1(this.str)) {
    throw new Error("Illegal argument: expecting string.")
  }
  if (!isNumber(this.pos) || this.pos < 0) {
    throw new Error("Illegal argument: expecting positive number as pos.")
  }
};

TextOperation.prototype.apply = function apply (str) {
  if (this.isEmpty()) { return str }
  if (this.type === INSERT) {
    if (str.length < this.pos) {
      throw new Error("Provided string is too short.")
    }
    if (str.splice) {
      return str.splice(this.pos, 0, this.str)
    } else {
      return str.slice(0, this.pos).concat(this.str).concat(str.slice(this.pos))
    }
  }
  else  {
    if (str.length < this.pos + this.str.length) {
      throw new Error("Provided string is too short.")
    }
    if (str.splice) {
      return str.splice(this.pos, this.str.length)
    } else {
      return str.slice(0, this.pos).concat(str.slice(this.pos + this.str.length))
    }
  }
};

TextOperation.prototype.clone = function clone$$1 () {
  return new TextOperation(this)
};

TextOperation.prototype.isNOP = function isNOP () {
  return this.type === "NOP" || this.str.length === 0
};

TextOperation.prototype.isInsert = function isInsert () {
  return this.type === INSERT
};

TextOperation.prototype.isDelete = function isDelete () {
  return this.type === DELETE$1
};

TextOperation.prototype.getLength = function getLength () {
  return this.str.length
};

TextOperation.prototype.invert = function invert () {
  var data = {
    type: this.isInsert() ? DELETE$1 : INSERT,
    pos: this.pos,
    str: this.str
  };
  return new TextOperation(data)
};

TextOperation.prototype.hasConflict = function hasConflict (other) {
  return _hasConflict(this, other)
};

TextOperation.prototype.isEmpty = function isEmpty () {
  return this.str.length === 0
};

TextOperation.prototype.toJSON = function toJSON () {
  return {
    type: this.type,
    pos: this.pos,
    str: this.str
  }
};

TextOperation.prototype.toString = function toString () {
  return ["(", (this.isInsert() ? INSERT : DELETE$1), ",", this.pos, ",'", this.str, "')"].join('')
};

TextOperation.prototype._isOperation = true;
TextOperation.prototype._isTextOperation = true;

function _hasConflict(a, b) {
  
  
  
  if (a.type === INSERT && b.type === INSERT) { return (a.pos === b.pos) }
  
  
  
  if (a.type === DELETE$1 && b.type === DELETE$1) {
    
    return !(a.pos >= b.pos + b.str.length || b.pos >= a.pos + a.str.length)
  }
  
  
  
  var del, ins;
  if (a.type === DELETE$1) {
    del = a; ins = b;
  } else {
    del = b; ins = a;
  }
  return (ins.pos >= del.pos && ins.pos < del.pos + del.str.length)
}




function transform_insert_insert(a, b) {
  if (a.pos === b.pos) {
    b.pos += a.str.length;
  }
  else if (a.pos < b.pos) {
    b.pos += a.str.length;
  }
  else {
    a.pos += b.str.length;
  }
}





function transform_delete_delete$1(a, b, first) {
  
  if (a.pos > b.pos) {
    return transform_delete_delete$1(b, a, !first)
  }
  if (a.pos === b.pos && a.str.length > b.str.length) {
    return transform_delete_delete$1(b, a, !first)
  }
  
  if (b.pos < a.pos + a.str.length) {
    var s = b.pos - a.pos;
    var s1 = a.str.length - s;
    var s2 = s + b.str.length;
    a.str = a.str.slice(0, s) + a.str.slice(s2);
    b.str = b.str.slice(s1);
    b.pos -= s;
  } else {
    b.pos -= a.str.length;
  }
}





function transform_insert_delete(a, b) {
  if (a.type === DELETE$1) {
    return transform_insert_delete(b, a)
  }
  
  
  if (a.pos <= b.pos) {
    b.pos += a.str.length;
  }
  
  else if (a.pos >= b.pos + b.str.length) {
    a.pos -= b.str.length;
  }
  
  
  
  else {
    var s = a.pos - b.pos;
    b.str = b.str.slice(0, s) + a.str + b.str.slice(s);
    a.str = "";
  }
}

function transform$1(a, b, options) {
  options = options || {};
  if (options["no-conflict"] && _hasConflict(a, b)) {
    throw new Conflict(a, b)
  }
  if (!options.inplace) {
    a = a.clone();
    b = b.clone();
  }
  if (a.type === INSERT && b.type === INSERT) {
    transform_insert_insert(a, b);
  }
  else if (a.type === DELETE$1 && b.type === DELETE$1) {
    transform_delete_delete$1(a, b, true);
  }
  else {
    transform_insert_delete(a,b);
  }
  return [a, b]
}

TextOperation.transform = function() {
  return transform$1.apply(null, arguments)
};



TextOperation.Insert = function(pos, str) {
  return new TextOperation({ type: INSERT, pos: pos, str: str })
};

TextOperation.Delete = function(pos, str) {
  return new TextOperation({ type: DELETE$1, pos: pos, str: str })
};

TextOperation.INSERT = INSERT;
TextOperation.DELETE = DELETE$1;

TextOperation.fromJSON = function(data) {
  return new TextOperation(data)
};

var NOP$1 = "NOP";
var DELETE$2 = "delete";
var INSERT$1 = "insert";

var ArrayOperation = function ArrayOperation(data) {
  if (!data || !data.type) {
    throw new Error("Illegal argument: insufficient data.")
  }
  this.type = data.type;
  if (this.type === NOP$1) { return }

  if (this.type !== INSERT$1 && this.type !== DELETE$2) {
    throw new Error("Illegal type.")
  }
  
  this.pos = data.pos;
  
  this.val = data.val;
  if (!isNumber(this.pos) || this.pos < 0) {
    throw new Error("Illegal argument: expecting positive number as pos.")
  }
};

ArrayOperation.prototype.apply = function apply (array) {
  if (this.type === NOP$1) {
    return array
  }
  if (this.type === INSERT$1) {
    if (array.length < this.pos) {
      throw new Error("Provided array is too small.")
    }
    array.splice(this.pos, 0, this.val);
    return array
  }
  
  else  {
    if (array.length < this.pos) {
      throw new Error("Provided array is too small.")
    }
    if (!isEqual(array[this.pos], this.val)) {
      throw Error("Unexpected value at position " + this.pos + ". Expected " + this.val + ", found " + array[this.pos])
    }
    array.splice(this.pos, 1);
    return array
  }
};

ArrayOperation.prototype.clone = function clone$$1 () {
  var data = {
    type: this.type,
    pos: this.pos,
    val: cloneDeep(this.val)
  };
  return new ArrayOperation(data)
};

ArrayOperation.prototype.invert = function invert () {
  var data = this.toJSON();
  if (this.type === NOP$1) { data.type = NOP$1; }
  else if (this.type === INSERT$1) { data.type = DELETE$2; }
  else  { data.type = INSERT$1; }
  return new ArrayOperation(data)
};

ArrayOperation.prototype.hasConflict = function hasConflict (other) {
  return ArrayOperation.hasConflict(this, other)
};

ArrayOperation.prototype.toJSON = function toJSON () {
  var result = {
    type: this.type,
  };
  if (this.type === NOP$1) { return result }
  result.pos = this.pos;
  result.val = cloneDeep(this.val);
  return result
};

ArrayOperation.prototype.isInsert = function isInsert () {
  return this.type === INSERT$1
};

ArrayOperation.prototype.isDelete = function isDelete () {
  return this.type === DELETE$2
};

ArrayOperation.prototype.getOffset = function getOffset () {
  return this.pos
};

ArrayOperation.prototype.getValue = function getValue () {
  return this.val
};

ArrayOperation.prototype.isNOP = function isNOP () {
  return this.type === NOP$1
};

ArrayOperation.prototype.toString = function toString () {
  return ["(", (this.isInsert() ? INSERT$1 : DELETE$2), ",", this.getOffset(), ",'", this.getValue(), "')"].join('')
};

ArrayOperation.prototype._isOperation = true;
ArrayOperation.prototype._isArrayOperation = true;

function hasConflict$1(a, b) {
  if (a.type === NOP$1 || b.type === NOP$1) { return false }
  if (a.type === INSERT$1 && b.type === INSERT$1) {
    return a.pos === b.pos
  } else {
    return false
  }
}

function transform_insert_insert$1(a, b) {
  if (a.pos === b.pos) {
    b.pos += 1;
  }
  
  else if (a.pos < b.pos) {
    b.pos += 1;
  }
  
  else {
    a.pos += 1;
  }
}

function transform_delete_delete$2(a, b) {
  
  if (a.pos === b.pos) {
    b.type = NOP$1;
    a.type = NOP$1;
    return
  }
  if (a.pos < b.pos) {
    b.pos -= 1;
  } else {
    a.pos -= 1;
  }
}

function transform_insert_delete$1(a, b) {
  
  if (a.type === DELETE$2) {
    var tmp = a;
    a = b;
    b = tmp;
  }
  if (a.pos <= b.pos) {
    b.pos += 1;
  } else {
    a.pos -= 1;
  }
}

var transform$2 = function(a, b, options) {
  options = options || {};
  
  
  if (options['no-conflict'] && hasConflict$1(a, b)) {
    throw new Conflict(a, b)
  }
  
  if (!options.inplace) {
    a = a.clone();
    b = b.clone();
  }
  if (a.type === NOP$1 || b.type === NOP$1) {
    
  }
  else if (a.type === INSERT$1 && b.type === INSERT$1) {
    transform_insert_insert$1(a, b);
  }
  else if (a.type === DELETE$2 && b.type === DELETE$2) {
    transform_delete_delete$2(a, b);
  }
  else {
    transform_insert_delete$1(a, b);
  }
  return [a, b]
};

ArrayOperation.transform = transform$2;
ArrayOperation.hasConflict = hasConflict$1;



ArrayOperation.Insert = function(pos, val) {
  return new ArrayOperation({type:INSERT$1, pos: pos, val: val})
};

ArrayOperation.Delete = function(pos, val) {
  return new ArrayOperation({ type:DELETE$2, pos: pos, val: val })
};

ArrayOperation.fromJSON = function(data) {
  return new ArrayOperation(data)
};

ArrayOperation.NOP = NOP$1;
ArrayOperation.DELETE = DELETE$2;
ArrayOperation.INSERT = INSERT$1;

var SHIFT = 'shift';

var CoordinateOperation = function CoordinateOperation(data) {
  if (!data || data.type === undefined) {
    throw new Error("Illegal argument: insufficient data.")
  }
  
  this.type = data.type;
  
  this.val = data.val;
  
  if(!this.isShift()) {
    throw new Error("Illegal type.")
  }
  if (!isNumber(this.val)) {
    throw new Error("Illegal argument: expecting number as shift value.")
  }
};

CoordinateOperation.prototype.apply = function apply (coor) {
  coor.offset = coor.offset + this.val;
};

CoordinateOperation.prototype.isShift = function isShift () {
  return this.type === SHIFT
};

CoordinateOperation.prototype.isNOP = function isNOP () {
  switch (this.type) {
    case SHIFT: {
      return this.val === 0
    }
    default:
      return false
  }
};

CoordinateOperation.prototype.clone = function clone$$1 () {
  return new CoordinateOperation(this)
};

CoordinateOperation.prototype.invert = function invert () {
  var data;
  switch (this.type) {
    case SHIFT:
      data = {
        type: SHIFT,
        val: -this.val
      };
      break
    default:
      throw new Error('Invalid type.')
  }
  return new CoordinateOperation(data)
};

CoordinateOperation.prototype.hasConflict = function hasConflict () {
  
  return false
};

CoordinateOperation.prototype.toJSON = function toJSON () {
  return {
    type: this.type,
    val: this.val
  }
};

CoordinateOperation.prototype.toString = function toString () {
  return ["(", (this.type), ",", this.val, "')"].join('')
};

CoordinateOperation.prototype._isOperation = true;
CoordinateOperation.prototype._isCoordinateOperation = true;

function transform_shift_shift(a, b) {
  a.val += b.val;
  b.val += a.val;
}

function transform$3(a, b, options) {
  options = options || {};
  
  if (!options.inplace) {
    a = a.clone();
    b = b.clone();
  }
  if (a.type === SHIFT && b.type === SHIFT) {
    transform_shift_shift(a, b);
  }
  else {
    throw new Error('Illegal type')
  }
  return [a, b]
}

CoordinateOperation.transform = function() {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return transform$3.apply(void 0, args)
};

CoordinateOperation.fromJSON = function(json) {
  return new CoordinateOperation(json)
};

CoordinateOperation.Shift = function(val) {
  return new CoordinateOperation({
    type: SHIFT,
    val: val
  })
};

var NOP = "NOP";
var CREATE = "create";
var DELETE = 'delete';
var UPDATE = 'update';
var SET = 'set';

var ObjectOperation = function ObjectOperation(data) {
  
  if (!data) {
    throw new Error('Data of ObjectOperation is missing.')
  }
  
  if (!data.type) {
    throw new Error('Invalid data: type is mandatory.')
  }
  this.type = data.type;
  if (data.type === NOP) {
    return
  }
  this.path = data.path;
  if (!data.path) {
    throw new Error('Invalid data: path is mandatory.')
  }
  if (this.type === CREATE || this.type === DELETE) {
    if (!data.val) {
      throw new Error('Invalid data: value is missing.')
    }
    this.val = data.val;
  }
  else if (this.type === UPDATE) {
    if (data.diff) {
      this.diff = data.diff;
      if (data.diff._isTextOperation) {
        this.propertyType = 'string';
      } else if (data.diff._isArrayOperation) {
        this.propertyType = 'array';
      } else if (data.diff._isCoordinateOperation) {
        this.propertyType = 'coordinate';
      } else {
        throw new Error('Invalid data: diff must be a TextOperation or an ArrayOperation.')
      }
    } else {
      throw new Error("Invalid data: diff is mandatory for update operation.")
    }
  }
  else if (this.type === SET) {
    this.val = data.val;
    this.original = data.original;
  } else {
    throw new Error('Invalid type: '+ data.type)
  }
};

ObjectOperation.prototype.apply = function apply (obj) {
  if (this.type === NOP) { return obj }
  var adapter;
  if (obj._isPathObject) {
    adapter = obj;
  } else {
    adapter = new PathObject(obj);
  }
  if (this.type === CREATE) {
    adapter.set(this.path, cloneDeep(this.val));
    return obj
  }
  if (this.type === DELETE) {
    adapter.delete(this.path, "strict");
  }
  else if (this.type === UPDATE) {
    var diff$$1 = this.diff;
    switch (this.propertyType) {
      case 'array': {
        var arr = adapter.get(this.path);
        diff$$1.apply(arr);
        break
      }
      case 'string': {
        var str = adapter.get(this.path);
        if (isNil(str)) { str = ''; }
        str = diff$$1.apply(str);
        adapter.set(this.path, str);
        break
      }
      case 'coordinate': {
        var coor = adapter.get(this.path);
        if (!coor) { throw new Error('No coordinate with path '+this.path) }
        diff$$1.apply(coor);
        break
      }
      default:
        throw new Error('Invalid state.')
    }
  }
  else if (this.type === SET) {
    
    adapter.set(this.path, cloneDeep(this.val));
  }
  else {
    throw new Error('Invalid type.')
  }
  return obj
};

ObjectOperation.prototype.clone = function clone$$1 () {
  var data = {
    type: this.type,
    path: this.path,
  };
  if (this.val) {
    data.val = cloneDeep(this.val);
  }
  if (this.diff) {
    data.diff = this.diff.clone();
  }
  return new ObjectOperation(data)
};

ObjectOperation.prototype.isNOP = function isNOP () {
  if (this.type === NOP) { return true }
  else if (this.type === UPDATE) { return this.diff.isNOP() }
};

ObjectOperation.prototype.isCreate = function isCreate () {
  return this.type === CREATE
};

ObjectOperation.prototype.isDelete = function isDelete () {
  return this.type === DELETE
};

ObjectOperation.prototype.isUpdate = function isUpdate (propertyType) {
  if (propertyType) {
    return (this.type === UPDATE && this.propertyType === propertyType)
  } else {
    return this.type === UPDATE
  }
};

ObjectOperation.prototype.isSet = function isSet () {
  return this.type === SET
};

ObjectOperation.prototype.invert = function invert () {
  if (this.type === NOP) {
    return new ObjectOperation({ type: NOP })
  }
  var result = new ObjectOperation(this);
  if (this.type === CREATE) {
    result.type = DELETE;
  }
  else if (this.type === DELETE) {
    result.type = CREATE;
  }
  else if (this.type === UPDATE) {
    var invertedDiff;
    if (this.diff._isTextOperation) {
      invertedDiff = TextOperation.fromJSON(this.diff.toJSON()).invert();
    } else if (this.diff._isArrayOperation) {
      invertedDiff = ArrayOperation.fromJSON(this.diff.toJSON()).invert();
    } else if (this.diff._isCoordinateOperation) {
      invertedDiff = CoordinateOperation.fromJSON(this.diff.toJSON()).invert();
    } else {
      throw new Error('Illegal type')
    }
    result.diff = invertedDiff;
  }
  else  {
    result.val = this.original;
    result.original = this.val;
  }
  return result
};

ObjectOperation.prototype.hasConflict = function hasConflict (other) {
  return ObjectOperation.hasConflict(this, other)
};

ObjectOperation.prototype.toJSON = function toJSON () {
  if (this.type === NOP) {
    return { type: NOP }
  }
  var data = {
    type: this.type,
    path: this.path,
  };
  if (this.type === CREATE || this.type === DELETE) {
    data.val = this.val;
  }
  else if (this.type === UPDATE) {
    if (this.diff._isTextOperation) {
      data.propertyType = "string";
    } else if (this.diff._isArrayOperation) {
      data.propertyType = "array";
    } else if (this.diff._isCoordinateOperation) {
      data.propertyType = "coordinate";
    } else {
      throw new Error('Invalid property type.')
    }
    data.diff = this.diff.toJSON();
  }
  else  {
    data.val = this.val;
    data.original = this.original;
  }
  return data
};

ObjectOperation.prototype.getType = function getType () {
  return this.type
};

ObjectOperation.prototype.getPath = function getPath () {
  return this.path
};

ObjectOperation.prototype.getValue = function getValue () {
  return this.val
};

ObjectOperation.prototype.getOldValue = function getOldValue () {
  return this.original
};

ObjectOperation.prototype.getValueOp = function getValueOp () {
  return this.diff
};


ObjectOperation.prototype.toString = function toString () {
  switch (this.type) {
    case CREATE:
      return ["(+,", JSON.stringify(this.path), JSON.stringify(this.val), ")"].join('')
    case DELETE:
      return ["(-,", JSON.stringify(this.path), JSON.stringify(this.val), ")"].join('')
    case UPDATE:
      return ["(>>,", JSON.stringify(this.path), this.propertyType, this.diff.toString(), ")"].join('')
    case SET:
      return ["(=,", JSON.stringify(this.path), this.val, this.original, ")"].join('')
    case NOP:
      return "NOP"
    default:
      throw new Error('Invalid type')
  }
};

ObjectOperation.prototype._isOperation = true;
ObjectOperation.prototype._isObjectOperation = true;



function hasConflict(a, b) {
  if (a.type === NOP || b.type === NOP) { return false }
  return isEqual(a.path, b.path)
}

function transform_delete_delete(a, b) {
  
  
  a.type = NOP;
  b.type = NOP;
}

function transform_create_create() {
  throw new Error("Can not transform two concurring creates of the same property")
}

function transform_delete_create() {
  throw new Error('Illegal state: can not create and delete a value at the same time.')
}

function transform_delete_update(a, b, flipped) {
  if (a.type !== DELETE) {
    return transform_delete_update(b, a, true)
  }
  var op;
  switch (b.propertyType) {
    case 'string':
      op = TextOperation.fromJSON(b.diff);
      break
    case 'array':
      op = ArrayOperation.fromJSON(b.diff);
      break
    case 'coordinate':
      op = CoordinateOperation.fromJSON(b.diff);
      break
    default:
      throw new Error('Illegal type')
  }
  
  if (!flipped) {
    a.type = NOP;
    b.type = CREATE;
    b.val = op.apply(a.val);
  }
  
  else {
    a.val = op.apply(a.val);
    b.type = NOP;
  }
}

function transform_create_update() {
  
  throw new Error("Can not transform a concurring create and update of the same property")
}

function transform_update_update(a, b) {
  
  var op_a, op_b, t;
  switch(b.propertyType) {
    case 'string':
      op_a = TextOperation.fromJSON(a.diff);
      op_b = TextOperation.fromJSON(b.diff);
      t = TextOperation.transform(op_a, op_b, {inplace: true});
      break
    case 'array':
      op_a = ArrayOperation.fromJSON(a.diff);
      op_b = ArrayOperation.fromJSON(b.diff);
      t = ArrayOperation.transform(op_a, op_b, {inplace: true});
      break
    case 'coordinate':
      op_a = CoordinateOperation.fromJSON(a.diff);
      op_b = CoordinateOperation.fromJSON(b.diff);
      t = CoordinateOperation.transform(op_a, op_b, {inplace: true});
      break
    default:
      throw new Error('Illegal type')
  }
  a.diff = t[0];
  b.diff = t[1];
}

function transform_create_set() {
  throw new Error('Illegal state: can not create and set a value at the same time.')
}

function transform_delete_set(a, b, flipped) {
  if (a.type !== DELETE) { return transform_delete_set(b, a, true) }
  if (!flipped) {
    a.type = NOP;
    b.type = CREATE;
    b.original = undefined;
  } else {
    a.val = b.val;
    b.type = NOP;
  }
}

function transform_update_set() {
  throw new Error("Unresolvable conflict: update + set.")
}

function transform_set_set(a, b) {
  a.type = NOP;
  b.original = a.val;
}

var _NOP = 0;
var _CREATE = 1;
var _DELETE = 2;
var _UPDATE = 4;
var _SET = 8;

var CODE = (function () {
  var c = {};
  c[NOP] =_NOP;
  c[CREATE] = _CREATE;
  c[DELETE] = _DELETE;
  c[UPDATE] = _UPDATE;
  c[SET] = _SET;
  return c
})();

var __transform__ = (function () {
  
  var t = {};
  t[_DELETE | _DELETE] = transform_delete_delete;
  t[_DELETE | _CREATE] = transform_delete_create;
  t[_DELETE | _UPDATE] = transform_delete_update;
  t[_CREATE | _CREATE] = transform_create_create;
  t[_CREATE | _UPDATE] = transform_create_update;
  t[_UPDATE | _UPDATE] = transform_update_update;
  t[_CREATE | _SET   ] = transform_create_set;
  t[_DELETE | _SET   ] = transform_delete_set;
  t[_UPDATE | _SET   ] = transform_update_set;
  t[_SET    | _SET   ] = transform_set_set;
  
  return t
})();

function transform(a, b, options) {
  options = options || {};
  if (options['no-conflict'] && hasConflict(a, b)) {
    throw new Conflict(a, b)
  }
  if (!options.inplace) {
    a = a.clone();
    b = b.clone();
  }
  if (a.isNOP() || b.isNOP()) {
    return [a, b]
  }
  var sameProp = isEqual(a.path, b.path);
  
  if (sameProp) {
    __transform__[CODE[a.type] | CODE[b.type]](a,b);
  }
  return [a, b]
}

ObjectOperation.transform = transform;
ObjectOperation.hasConflict = hasConflict;



ObjectOperation.Create = function(idOrPath, val) {
  var path;
  if (isString$1(idOrPath)) {
    path = [idOrPath];
  } else {
    path = idOrPath;
  }
  return new ObjectOperation({type: CREATE, path: path, val: val})
};

ObjectOperation.Delete = function(idOrPath, val) {
  var path;
  if (isString$1(idOrPath)) {
    path = [idOrPath];
  } else {
    path = idOrPath;
  }
  return new ObjectOperation({type: DELETE, path: path, val: val})
};

ObjectOperation.Update = function(path, op) {
  return new ObjectOperation({
    type: UPDATE,
    path: path,
    diff: op
  })
};

ObjectOperation.Set = function(path, oldVal, newVal) {
  return new ObjectOperation({
    type: SET,
    path: path,
    val: cloneDeep(newVal),
    original: cloneDeep(oldVal)
  })
};

ObjectOperation.fromJSON = function(data) {
  data = cloneDeep(data);
  if (data.type === "update") {
    switch (data.propertyType) {
      case "string":
        data.diff = TextOperation.fromJSON(data.diff);
        break
      case "array":
        data.diff = ArrayOperation.fromJSON(data.diff);
        break
      case "coordinate":
        data.diff = CoordinateOperation.fromJSON(data.diff);
        break
      default:
        throw new Error("Unsupported update diff:" + JSON.stringify(data.diff))
    }
  }
  var op = new ObjectOperation(data);
  return op
};

ObjectOperation.NOP = NOP;
ObjectOperation.CREATE = CREATE;
ObjectOperation.DELETE = DELETE;
ObjectOperation.UPDATE = UPDATE;
ObjectOperation.SET = SET;

function transformDocumentChange(A, B) {
  _transformInplaceBatch(A, B);
}

function transformSelection(sel, a) {
  var newSel = sel.clone();
  var hasChanged = _transformSelectionInplace(newSel, a);
  if (hasChanged) {
    return newSel
  } else {
    return sel
  }
}

function _transformInplaceSingle(a, b) {
  for (var i = 0; i < a.ops.length; i++) {
    var a_op = a.ops[i];
    for (var j = 0; j < b.ops.length; j++) {
      var b_op = b.ops[j];
      
      
      ObjectOperation.transform(a_op, b_op, {inplace: true});
    }
  }
  if (a.before) {
    _transformSelectionInplace(a.before.selection, b);
  }
  if (a.after) {
    _transformSelectionInplace(a.after.selection, b);
  }
  if (b.before) {
    _transformSelectionInplace(b.before.selection, a);
  }
  if (b.after) {
    _transformSelectionInplace(b.after.selection, a);
  }
}

function _transformInplaceBatch(A, B) {
  if (!isArray$1(A)) {
    A = [A];
  }
  if (!isArray$1(B)) {
    B = [B];
  }
  for (var i = 0; i < A.length; i++) {
    var a = A[i];
    for (var j = 0; j < B.length; j++) {
      var b = B[j];
      _transformInplaceSingle(a,b);
    }
  }
}

function _transformSelectionInplace(sel, a) {
  if (!sel || (!sel.isPropertySelection() && !sel.isContainerSelection()) ) {
    return false
  }
  var ops = a.ops;
  var hasChanged = false;
  var isCollapsed = sel.isCollapsed();
  for(var i=0; i<ops.length; i++) {
    var op = ops[i];
    hasChanged |= _transformCoordinateInplace(sel.start, op);
    if (!isCollapsed) {
      hasChanged |= _transformCoordinateInplace(sel.end, op);
    } else {
      if (sel.isContainerSelection()) {
        sel.end.path = sel.start.path;
      }
      sel.end.offset = sel.start.offset;
    }
  }
  return hasChanged
}

function _transformCoordinateInplace(coor, op) {
  if (!isEqual(op.path, coor.path)) { return false }
  var hasChanged = false;
  if (op.type === 'update' && op.propertyType === 'string') {
    var diff$$1 = op.diff;
    var newOffset;
    if (diff$$1.isInsert() && diff$$1.pos <= coor.offset) {
      newOffset = coor.offset + diff$$1.str.length;
      
      coor.offset = newOffset;
      hasChanged = true;
    } else if (diff$$1.isDelete() && diff$$1.pos <= coor.offset) {
      newOffset = Math.max(diff$$1.pos, coor.offset - diff$$1.str.length);
      
      coor.offset = newOffset;
      hasChanged = true;
    }
  }
  return hasChanged
}


var operationHelpers = Object.freeze({
	transformDocumentChange: transformDocumentChange,
	transformSelection: transformSelection
});

var Property = function Property(definition) {
  this.definition = definition;
};

var prototypeAccessors$3 = { type: {},name: {} };

Property.prototype.isArray = function isArray$1$$1 () {
  return isArray$1(this.definition.type)
};

Property.prototype.isReference = function isReference () {
  if (this.isArray()) {
    return last$1(this.definition.type) === 'id'
  } else {
    return this.definition.type === 'id'
  }
};

Property.prototype.isText = function isText () {
  return Boolean(this.definition._isText)
};

Property.prototype.isOwned = function isOwned () {
  return Boolean(this.definition.owned)
};

Property.prototype.isOptional = function isOptional () {
  return Boolean(this.definition.optional)
};

Property.prototype.isNotNull = function isNotNull () {
  return Boolean(this.definition.notNull)
};

Property.prototype.hasDefault = function hasDefault () {
  return this.definition.hasOwnProperty('default')
};

Property.prototype.getDefault = function getDefault () {
  return this.definition.default
};

Property.prototype.createDefaultValue = function createDefaultValue () {
  if (isArray$1(this.definition.type)) {
    return []
  }
  switch(this.definition.type) {
    case 'object':
      return {}
    case 'number':
      return -1
    case 'coordinate':
      return new Coordinate([], 0)
    case 'boolean':
      return false
    case 'id':
      return null
    case 'string':
      return ''
    default:
      return null
  }
};

prototypeAccessors$3.type.get = function () {
  return this.definition.type
};

prototypeAccessors$3.name.get = function () {
  return this.definition.name
};

Object.defineProperties( Property.prototype, prototypeAccessors$3 );

var Node = (function (EventEmitter$$1) {
  function Node() {
    EventEmitter$$1.call(this);

    
    
    this._initialize.apply(this, arguments);
  }

  if ( EventEmitter$$1 ) Node.__proto__ = EventEmitter$$1;
  Node.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  Node.prototype.constructor = Node;

  var prototypeAccessors = { type: {} };

  Node.prototype._initialize = function _initialize (data) {
    var this$1 = this;

    var NodeClass = this.constructor;

    var schema = NodeClass.schema;
    for (var name in schema) {
      if (!schema.hasOwnProperty(name)) { continue }
      var prop = schema[name];
      
      
      var propIsGiven = (data[name] !== undefined);
      var hasDefault = prop.hasDefault();
      var isOptional = prop.isOptional();
      if ( (!isOptional && !hasDefault) && !propIsGiven) {
        throw new Error('Property ' + name + ' is mandatory for node type ' + this$1.type)
      }
      if (propIsGiven) {
        this$1[name] = _checked(prop, data[name]);
      } else if (hasDefault) {
        this$1[name] = cloneDeep(_checked(prop, prop.getDefault()));
      } else {
        
      }
    }
  };

  Node.prototype.dispose = function dispose () {
    
  };

  
  Node.prototype.isInstanceOf = function isInstanceOf (typeName) {
    return Node.isInstanceOf(this.constructor, typeName)
  };

  Node.prototype.getSchema = function getSchema () {
    return this.constructor.schema
  };

  
  Node.prototype.getTypeNames = function getTypeNames () {
    var typeNames = [];
    var NodeClass = this.constructor;
    while (NodeClass.type !== "node") {
      typeNames.push(NodeClass.type);
      NodeClass = Object.getPrototypeOf(NodeClass);
    }
    return typeNames
  };

  
  Node.prototype.getPropertyType = function getPropertyType (propertyName) {
    var schema = this.constructor.schema;
    return schema[propertyName].type
  };

  
  Node.prototype.toJSON = function toJSON () {
    var this$1 = this;

    var data = {
      type: this.type
    };
    var schema = this.getSchema();
    forEach(schema, function (prop, name) {
      var val = this$1[name];
      if (prop.isOptional() && val === undefined) { return }
      if (isArray$1(val) || isObject$1(val)) {
        val = cloneDeep(val);
      }
      data[prop.name] = val;
    });
    return data
  };

  prototypeAccessors.type.get = function () {
    return this.constructor.type
  };

  Object.defineProperties( Node.prototype, prototypeAccessors );

  return Node;
}(EventEmitter));

Node.prototype._isNode = true;


Object.defineProperty(Node, 'schema', {
  get: function get() { return this._schema },
  set: function set(schema) {
    var NodeClass = this;
    
    
    if (schema.type) {
      NodeClass.type = schema.type;
    }
    
    
    
    NodeClass._schema = compileSchema(NodeClass, schema);
  }
});

Node.define = Node.defineSchema = function define(schema) {
  this.schema = schema;
};

Node.schema = {
  type: "node",
  id: 'string'
};


Node.isInstanceOf = function(NodeClass, typeName) {
  var type = NodeClass.type;
  while (type !== "node") {
    if (type === typeName) { return true }
    var _super = Object.getPrototypeOf(NodeClass.prototype).constructor;
    if (_super && _super.type) {
      NodeClass = _super;
      type = NodeClass.type;
    } else {
      break
    }
  }
  return false
};



function compileSchema(NodeClass, schema) {
  var compiledSchema = _compileSchema(schema);
  var schemas = [compiledSchema];
  var clazz = NodeClass;
  while(clazz) {
    var parentProto = Object.getPrototypeOf(clazz.prototype);
    if (!parentProto) {
      break
    }
    clazz = parentProto.constructor;
    if (clazz && clazz._schema) {
      schemas.unshift(clazz._schema);
    }
  }
  schemas.unshift({});
  return Object.assign.apply(null, schemas)
}

function _compileSchema(schema) {
  var compiledSchema = {};
  forEach(schema, function(definition, name) {
    
    if (name === 'type') {
      return
    }
    if (isString$1(definition) || isArray$1(definition)) {
      definition = { type: definition };
    }
    definition = _compileDefintion(definition);
    definition.name = name;
    compiledSchema[name] = new Property(definition);
  });
  return compiledSchema
}

function _compileDefintion(definition) {
  var result = definition;
  if (isArray$1(definition.type) && definition.type[0] !== "array") {
    definition.type = [ "array", definition.type[0] ];
  } else if (definition.type === 'text') {
    result = {
      type: "string",
      default: '',
      _isText: true
    };
  }
  return result
}

function _checked(prop, value) {
  var type;
  var name = prop.name;
  if (prop.isArray()) {
    type = "array";
  } else {
    type = prop.type;
  }
  if (value === null) {
    if (prop.isNotNull()) {
      throw new Error('Value for property ' + name + ' is null.')
    } else {
      return value
    }
  }
  if (value === undefined) {
    throw new Error('Value for property ' + name + ' is undefined.')
  }
  if (type === "string" && !isString$1(value) ||
      type === "boolean" && !isBoolean(value) ||
      type === "number" && !isNumber(value) ||
      type === "array" && !isArray$1(value) ||
      type === "id" && !isString$1(value) ||
      type === "object" && !isObject$1(value)) {
    throw new Error('Illegal value type for property ' + name + ': expected ' + type + ', was ' + (typeof value))
  }
  return value
}

var DocumentNode = (function (DataNode) {
  function DocumentNode(doc, props) {
    DataNode.call(this, doc, props);
  }

  if ( DataNode ) DocumentNode.__proto__ = DataNode;
  DocumentNode.prototype = Object.create( DataNode && DataNode.prototype );
  DocumentNode.prototype.constructor = DocumentNode;

  DocumentNode.prototype._initialize = function _initialize (doc, props) {
    this.document = doc;
    DataNode.prototype._initialize.call(this, props);
  };

  
  DocumentNode.prototype.getDocument = function getDocument () {
    return this.document
  };

  
  DocumentNode.prototype.hasParent = function hasParent () {
    return Boolean(this.parent)
  };

  
  DocumentNode.prototype.getParent = function getParent () {
    return this.document.get(this.parent)
  };

  
  DocumentNode.prototype.getRoot = function getRoot () {
    var node = this;
    while(node.parent) {
      node = node.parent;
    }
    return node
  };

  
  DocumentNode.prototype.hasChildren = function hasChildren () {
    return false
  };

  
  DocumentNode.prototype.getChildIndex = function getChildIndex (child) { 
    return -1
  };

  
  DocumentNode.prototype.getChildAt = function getChildAt (idx) { 
    return null
  };

  
  DocumentNode.prototype.getChildCount = function getChildCount () {
    return 0
  };

  
  
  
  DocumentNode.prototype.setHighlighted = function setHighlighted (highlighted, scope) {
    if (this.highlighted !== highlighted) {
      this.highlightedScope = scope;
      this.highlighted = highlighted;
      this.emit('highlighted', highlighted);
    }
  };

  
  
  DocumentNode.prototype.on = function on (eventName, handler, ctx) {
    var match = _matchPropertyEvent(eventName);
    if (match) {
      var propertyName = match[1];
      if (this.constructor.schema[propertyName]) {
        var doc = this.getDocument();
        doc.getEventProxy('path')
          .on([this.id, propertyName], handler, ctx);
      }
    }
    EventEmitter.prototype.on.apply(this, arguments);
  };

  DocumentNode.prototype.off = function off (ctx, eventName, handler) {
    var doc = this.getDocument();
    var match = false;
    if (!eventName) {
      doc.getEventProxy('path').off(ctx);
    } else {
      match = _matchPropertyEvent(eventName);
    }
    if (match) {
      var propertyName = match[1];
      doc.getEventProxy('path')
        .off(ctx, [this.id, propertyName], handler);
    }
    EventEmitter.prototype.off.apply(this, arguments);
  };

  DocumentNode.prototype._onPropertyChange = function _onPropertyChange (propertyName) {
    var args = [propertyName + ':changed']
      .concat(Array.prototype.slice.call(arguments, 1));
    this.emit.apply(this, args);
  };

  
  

  
  DocumentNode.prototype.isBlock = function isBlock () {
    return Boolean(this.constructor.isBlock)
  };

  
  DocumentNode.prototype.isText = function isText () {
    return Boolean(this.constructor.isText)
  };

  
  DocumentNode.prototype.isInline = function isInline () {
    return Boolean(this.constructor.isInline)
  };

  DocumentNode.prototype.isList = function isList () {
    return Boolean(this.constructor.isList)
  };

  DocumentNode.prototype.isIsolatedNode = function isIsolatedNode () {
    return !this.isText() && !this.isList()
  };

  return DocumentNode;
}(Node));

DocumentNode.prototype._isDocumentNode = true;


DocumentNode.isBlock = false;


DocumentNode.isText = false;


DocumentNode.isPropertyAnnotation = false;


DocumentNode.isContainerAnnotation = false;


DocumentNode.isInline = false;

function _matchPropertyEvent(eventName) {
  return /([a-zA-Z_0-9]+):changed/.exec(eventName)
}

var NodeIndex = function NodeIndex () {};

NodeIndex.prototype.select = function select (node) { 
  throw new Error('This method is abstract.')
};


NodeIndex.prototype.create = function create (node) { 
  throw new Error('This method is abstract.')
};


NodeIndex.prototype.delete = function delete$1 (node) { 
  throw new Error('This method is abstract.')
};

NodeIndex.prototype.set = function set (node, path, newValue, oldValue) {
  this.update(node, path, newValue, oldValue);
};


NodeIndex.prototype.update = function update (node, path, newValue, oldValue) { 
  throw new Error('This method is abstract.')
};


NodeIndex.prototype.reset = function reset (data) {
  this._clear();
  this._initialize(data);
};


NodeIndex.prototype.clone = function clone$$1 () {
  var NodeIndexClass = this.constructor;
  var clone$$1 = new NodeIndexClass();
  return clone$$1
};

NodeIndex.prototype._clear = function _clear () {
  throw new Error('This method is abstract')
};

NodeIndex.prototype._initialize = function _initialize (data) {
  forEach(data.getNodes(), function(node) {
    if (this.select(node)) {
      this.create(node);
    }
  }.bind(this));
};


NodeIndex.create = function(prototype) {
  var index = Object.assign(new NodeIndex(), prototype);
  index.clone = function() {
    return NodeIndex.create(prototype)
  };
  return index
};


NodeIndex.filterByType = function(type) {
  return function(node) {
    return node.isInstanceOf(type)
  }
};

var DocumentIndex = (function (NodeIndex$$1) {
	function DocumentIndex () {
		NodeIndex$$1.apply(this, arguments);
	}if ( NodeIndex$$1 ) DocumentIndex.__proto__ = NodeIndex$$1;
	DocumentIndex.prototype = Object.create( NodeIndex$$1 && NodeIndex$$1.prototype );
	DocumentIndex.prototype.constructor = DocumentIndex;

	

	return DocumentIndex;
}(NodeIndex));

var annotationHelpers = {
  insertedText: insertedText,
  deletedText: deletedText,
  transferAnnotations: transferAnnotations,
  expandAnnotation: expandAnnotation,
  fuseAnnotation: fuseAnnotation,
  truncateAnnotation: truncateAnnotation
};

function insertedText(doc, coordinate, length) {
  if (!length) { return; }
  var index = doc.getIndex('annotations');
  var annotations = index.get(coordinate.path);
  for (var i = 0; i < annotations.length; i++) {
    var anno = annotations[i];
    var pos = coordinate.offset;
    var start = anno.start.offset;
    var end = anno.end.offset;
    var newStart = start;
    var newEnd = end;
    if ( (pos < start) ||
         (pos === start) ) {
      newStart += length;
    }
    
    if ( (pos < end) ||
         (pos === end && !anno.isInline()) ) {
      newEnd += length;
    }
    
    if (newStart !== start) {
      doc.set([anno.id, 'start', 'offset'], newStart);
    }
    if (newEnd !== end) {
      doc.set([anno.id, 'end', 'offset'], newEnd);
    }
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
}

function deletedText(doc, path, startOffset, endOffset) {
  if (startOffset === endOffset) { return; }
  var index = doc.getIndex('annotations');
  var annotations = index.get(path);
  var length = endOffset - startOffset;
  for (var i = 0; i < annotations.length; i++) {
    var anno = annotations[i];
    var pos1 = startOffset;
    var pos2 = endOffset;
    var start = anno.start.offset;
    var end = anno.end.offset;
    var newStart = start;
    var newEnd = end;
    if (pos2 <= start) {
      newStart -= length;
      newEnd -= length;
      doc.set([anno.id, 'start', 'offset'], newStart);
      doc.set([anno.id, 'end', 'offset'], newEnd);
    } else {
      if (pos1 <= start) {
        newStart = start - Math.min(pos2-pos1, start-pos1);
      }
      if (pos1 <= end) {
        newEnd = end - Math.min(pos2-pos1, end-pos1);
      }
      
      if (start !== end && newStart === newEnd) {
        doc.delete(anno.id);
      } else {
        
        if (start !== newStart) {
          doc.set([anno.id, 'start', 'offset'], newStart);
        }
        if (end !== newEnd) {
          doc.set([anno.id, 'end', 'offset'], newEnd);
        }
      }
    }
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
}


function transferAnnotations(doc, path, offset, newPath, newOffset) {
  var index = doc.getIndex('annotations');
  var annotations = index.get(path, offset);
  for (var i = 0; i < annotations.length; i++) {
    var a = annotations[i];
    var isInside = (offset > a.start.offset && offset < a.end.offset);
    var start = a.start.offset;
    var end = a.end.offset;
    
    if (isInside) {
      
      if (a.canSplit()) {
        var newAnno = a.toJSON();
        newAnno.id = uuid(a.type + "_");
        newAnno.start.path = newPath;
        newAnno.start.offset = newOffset;
        newAnno.end.path = newPath;
        newAnno.end.offset = newOffset + a.end.offset - offset;
        doc.create(newAnno);
      }
      
      var newStartOffset = a.start.offset;
      var newEndOffset = offset;
      
      if (newEndOffset === newStartOffset) {
        doc.delete(a.id);
      }
      
      else {
        
        if (newStartOffset !== start) {
          doc.set([a.id, 'start', 'offset'], newStartOffset);
        }
        if (newEndOffset !== end) {
          doc.set([a.id, 'end', 'offset'], newEndOffset);
        }
      }
    }
    
    else if (a.start.offset >= offset) {
      
      
      
      doc.set([a.id, 'start', 'path'], newPath);
      doc.set([a.id, 'start', 'offset'], newOffset + a.start.offset - offset);
      doc.set([a.id, 'end', 'path'], newPath);
      doc.set([a.id, 'end', 'offset'], newOffset + a.end.offset - offset);
    }
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
}


function truncateAnnotation(tx, anno, sel) {
  if (!sel || !sel._isSelection) { throw new Error('Argument "selection" is required.') }
  if (!anno || !anno._isAnnotation) { throw new Error('Argument "anno" is required.') }
  var annoSel = anno.getSelection();
  var newAnnoSel = annoSel.truncateWith(sel);
  anno._updateRange(tx, newAnnoSel);
  return anno
}


function expandAnnotation(tx, anno, sel) {
  if (!sel || !sel._isSelection) { throw new Error('Argument "selection" is required.') }
  if (!anno || !anno._isAnnotation) { throw new Error('Argument "anno" is required.') }
  var annoSel = anno.getSelection();
  var newAnnoSel = annoSel.expand(sel);
  anno._updateRange(tx, newAnnoSel);
  return anno
}


function fuseAnnotation(tx, annos) {
  if (!isArray$1(annos) || annos.length < 2) {
    throw new Error('fuseAnnotation(): at least two annotations are necessary.')
  }
  var sel, annoType;
  annos.forEach(function(anno, idx) {
    if (idx === 0) {
      sel = anno.getSelection();
      annoType = anno.type;
    } else {
      if (anno.type !== annoType) {
        throw new Error('fuseAnnotation(): all annotations must be of the same type.')
      }
      sel = sel.expand(anno.getSelection());
    }
  });
  
  for (var i = 1; i < annos.length; i++) {
    tx.delete(annos[i].id);
  }
  expandAnnotation(tx, annos[0], sel);
  tx.setSelection(sel);
}

var PropertyIndex = (function (NodeIndex$$1) {
  function PropertyIndex(property) {
    NodeIndex$$1.call(this);

    this._property = property || 'id';
    this.index = new TreeIndex();
  }

  if ( NodeIndex$$1 ) PropertyIndex.__proto__ = NodeIndex$$1;
  PropertyIndex.prototype = Object.create( NodeIndex$$1 && NodeIndex$$1.prototype );
  PropertyIndex.prototype.constructor = PropertyIndex;

  
  PropertyIndex.prototype.get = function get (path) {
    return this.index.get(path) || {}
  };

  
  PropertyIndex.prototype.getAll = function getAll (path) {
    return this.index.getAll(path)
  };

  
  PropertyIndex.prototype.select = function select (node) { 
    return true
  };

  
  PropertyIndex.prototype.create = function create (node) {
    var values = node[this._property];
    if (!isArray$1(values)) {
      values = [values];
    }
    forEach(values, function(value) {
      this.index.set([value, node.id], node);
    }.bind(this));
  };

  
  PropertyIndex.prototype.delete = function delete$1 (node) {
    var values = node[this._property];
    if (!isArray$1(values)) {
      values = [values];
    }
    forEach(values, function(value) {
      this.index.delete([value, node.id]);
    }.bind(this));
  };

  
  PropertyIndex.prototype.update = function update (node, path, newValue, oldValue) {
    if (!this.select(node) || path[1] !== this._property) { return }
    var values = oldValue;
    if (!isArray$1(values)) {
      values = [values];
    }
    forEach(values, function(value) {
      this.index.delete([value, node.id]);
    }.bind(this));
    values = newValue;
    if (!isArray$1(values)) {
      values = [values];
    }
    forEach(values, function(value) {
      this.index.set([value, node.id], node);
    }.bind(this));
  };

  PropertyIndex.prototype.set = function set (node, path, newValue, oldValue) {
    this.update(node, path, newValue, oldValue);
  };

  PropertyIndex.prototype._clear = function _clear () {
    this.index.clear();
  };

  PropertyIndex.prototype._initialize = function _initialize (data) {
    forEach(data.getNodes(), function(node) {
      if (this.select(node)) {
        this.create(node);
      }
    }.bind(this));
  };

  return PropertyIndex;
}(NodeIndex));

var AnnotationIndex = (function (DocumentIndex$$1) {
  function AnnotationIndex() {
    DocumentIndex$$1.call(this);

    this.byPath = new TreeIndex();
    this.byType = new TreeIndex();
  }

  if ( DocumentIndex$$1 ) AnnotationIndex.__proto__ = DocumentIndex$$1;
  AnnotationIndex.prototype = Object.create( DocumentIndex$$1 && DocumentIndex$$1.prototype );
  AnnotationIndex.prototype.constructor = AnnotationIndex;

  AnnotationIndex.prototype.select = function select (node) {
    return Boolean(node._isPropertyAnnotation)
  };

  AnnotationIndex.prototype.reset = function reset (data) {
    this.byPath.clear();
    this.byType.clear();
    this._initialize(data);
  };

  
  AnnotationIndex.prototype.get = function get (path, start, end, type) {
    var annotations;
    if (isString$1(path) || path.length === 1) {
      annotations = this.byPath.getAll(path) || {};
    } else {
      annotations = this.byPath.get(path);
    }
    annotations = map(annotations);
    if (isNumber(start)) {
      annotations = filter(annotations, AnnotationIndex.filterByRange(start, end));
    }
    if (type) {
      annotations = filter(annotations, DocumentIndex$$1.filterByType(type));
    }
    return annotations
  };

  AnnotationIndex.prototype.create = function create (anno) {
    this.byType.set([anno.type, anno.id], anno);
    this.byPath.set(anno.start.path.concat([anno.id]), anno);
  };

  AnnotationIndex.prototype.delete = function delete$1 (anno) {
    this._delete(anno.type, anno.id, anno.start.path);
  };

  AnnotationIndex.prototype._delete = function _delete (type, id, path) {
    this.byType.delete([type, id]);
    this.byPath.delete(path.concat([id]));
  };

  AnnotationIndex.prototype.update = function update (node, path, newValue, oldValue) {
    
    if (this.select(node) && path[1] === 'start' && path[2] === "path") {
      this._delete(node.type, node.id, oldValue);
      this.create(node);
    }
  };

  return AnnotationIndex;
}(DocumentIndex));

AnnotationIndex.filterByRange = function(start, end) {
  return function(anno) {
    var aStart = anno.start.offset;
    var aEnd = anno.end.offset;
    var overlap = (aEnd >= start);
    
    if (isNumber(end)) {
      overlap = overlap && (aStart <= end);
    }
    return overlap
  }
};

var ContainerAnnotationIndex = (function (DocumentIndex$$1) {
  function ContainerAnnotationIndex() {
    DocumentIndex$$1.call(this);
    this.byId = new TreeIndex();
  }

  if ( DocumentIndex$$1 ) ContainerAnnotationIndex.__proto__ = DocumentIndex$$1;
  ContainerAnnotationIndex.prototype = Object.create( DocumentIndex$$1 && DocumentIndex$$1.prototype );
  ContainerAnnotationIndex.prototype.constructor = ContainerAnnotationIndex;

  ContainerAnnotationIndex.prototype.select = function select (node) {
    return Boolean(node._isContainerAnnotation)
  };

  ContainerAnnotationIndex.prototype.reset = function reset (data) {
    this.byId.clear();
    this._initialize(data);
  };

  ContainerAnnotationIndex.prototype.get = function get (containerId, type) {
    var annotations = map(this.byId.get(containerId));
    if (isString$1(type)) {
      annotations = filter(annotations, DocumentIndex$$1.filterByType);
    }
    return annotations
  };

  ContainerAnnotationIndex.prototype.create = function create (anno) {
    this.byId.set([anno.containerId, anno.id], anno);
  };

  ContainerAnnotationIndex.prototype.delete = function delete$1 (anno) {
    this.byId.delete([anno.containerId, anno.id]);
  };

  ContainerAnnotationIndex.prototype.update = function update (node, path, newValue, oldValue) { 
    
  };

  return ContainerAnnotationIndex;
}(DocumentIndex));

var OperationSerializer = function OperationSerializer() {
  this.SEPARATOR = '\t';
};

OperationSerializer.prototype.serialize = function serialize (op) {
  var out = [];
  switch (op.type) {
    case 'create':
      out.push('c');
      out.push(op.val.id);
      out.push(op.val);
      break
    case 'delete':
      out.push('d');
      out.push(op.val.id);
      out.push(op.val);
      break
    case 'set':
      out.push('s');
      out.push(op.path.join('.'));
      out.push(op.val);
      out.push(op.original);
      break
    case 'update':
      out.push('u');
      out.push(op.path.join('.'));
      Array.prototype.push.apply(out, this.serializePrimitiveOp(op.diff));
      break
    default:
      throw new Error('Unsupported operation type.')
  }
  return out
};

OperationSerializer.prototype.serializePrimitiveOp = function serializePrimitiveOp (op) {
  var out = [];
  if (op._isTextOperation) {
    if (op.isInsert()) {
      out.push('t+');
    } else if (op.isDelete()) {
      out.push('t-');
    }
    out.push(op.pos);
    out.push(op.str);
  } else if (op._isArrayOperation) {
    if (op.isInsert()) {
      out.push('a+');
    } else if (op.isDelete()) {
      out.push('a-');
    }
    out.push(op.pos);
    out.push(op.val);
  } else if (op._isCoordinateOperation) {
    if (op.isShift()) {
      out.push('c>>');
    } else {
      throw new Error('Unsupported CoordinateOperation type.')
    }
    out.push(op.pos);
    out.push(op.val);
  } else {
    throw new Error('Unsupported operation type.')
  }
  return out
};

OperationSerializer.prototype.deserialize = function deserialize (str, tokenizer) {
  if (!tokenizer) {
    tokenizer = new Tokenizer(str, this.SEPARATOR);
  }
  var type = tokenizer.getString();
  var op, path, val, oldVal, diff$$1;
  switch (type) {
    case 'c':
      path = tokenizer.getPath();
      val = tokenizer.getObject();
      op = ObjectOperation.Create(path, val);
      break
    case 'd':
      path = tokenizer.getPath();
      val = tokenizer.getObject();
      op = ObjectOperation.Delete(path, val);
      break
    case 's':
      path = tokenizer.getPath();
      val = tokenizer.getAny();
      oldVal = tokenizer.getAny();
      op = ObjectOperation.Set(path, oldVal, val);
      break
    case 'u':
      path = tokenizer.getPath();
      diff$$1 = this.deserializePrimitiveOp(str, tokenizer);
      op = ObjectOperation.Update(path, diff$$1);
      break
    default:
      throw new Error('Illegal type for ObjectOperation: '+ type)
  }
  return op
};

OperationSerializer.prototype.deserializePrimitiveOp = function deserializePrimitiveOp (str, tokenizer) {
  if (!tokenizer) {
    tokenizer = new Tokenizer(str, this.SEPARATOR);
  }
  var type = tokenizer.getString();
  var op, pos, val;
  switch (type) {
    case 't+':
      pos = tokenizer.getNumber();
      val = tokenizer.getString();
      op = TextOperation.Insert(pos, val);
      break
    case 't-':
      pos = tokenizer.getNumber();
      val = tokenizer.getString();
      op = TextOperation.Delete(pos, val);
      break
    case 'a+':
      pos = tokenizer.getNumber();
      val = tokenizer.getAny();
      op = ArrayOperation.Insert(pos, val);
      break
    case 'a-':
      pos = tokenizer.getNumber();
      val = tokenizer.getAny();
      op = ArrayOperation.Delete(pos, val);
      break
    case 'c>>':
      val = tokenizer.getNumber();
      op = CoordinateOperation.Shift(val);
      break
    default:
      throw new Error('Unsupported operation type: ' + type)
  }
  return op
};

var Tokenizer = function Tokenizer(str, sep) {
  if (isArray$1(arguments[0])) {
    this.tokens = arguments[0];
  } else {
    this.tokens = str.split(sep);
  }
  this.pos = -1;
};

Tokenizer.prototype.error = function error (msg) {
  throw new Error('Parsing error: ' + msg + '\n' + this.tokens[this.pos])
};

Tokenizer.prototype.getString = function getString () {
  this.pos++;
  var str = this.tokens[this.pos];
  if (str[0] === '"') {
    str = str.slice(1, -1);
  }
  return str
};

Tokenizer.prototype.getNumber = function getNumber () {
  this.pos++;
  var number;
  var token = this.tokens[this.pos];
  try {
    if (isNumber(token)) {
      number = token;
    } else {
      number = parseInt(this.tokens[this.pos], 10);
    }
    return number
  } catch (err) {
    this.error('expected number');
  }
};

Tokenizer.prototype.getObject = function getObject () {
  this.pos++;
  var obj;
  var token = this.tokens[this.pos];
  try {
    if (isObject$1(token)) {
      obj = token;
    } else {
      obj = JSON.parse(this.tokens[this.pos]);
    }
    return obj
  } catch (err) {
    this.error('expected object');
  }
};

Tokenizer.prototype.getAny = function getAny () {
  this.pos++;
  var token = this.tokens[this.pos];
  return token
};

Tokenizer.prototype.getPath = function getPath () {
  var str = this.getString();
  return str.split('.')
};

OperationSerializer.Tokenizer = Tokenizer;

var DocumentChange = function DocumentChange(ops, before, after) {
  if (arguments.length === 1 && isPlainObject$1(arguments[0])) {
    var data = arguments[0];
    
    this.sha = data.sha;
    
    this.timestamp = data.timestamp;
    
    this.before = data.before || {};
    
    this.ops = data.ops;
    this.info = data.info; 
    
    this.after = data.after || {};
  } else if (arguments.length === 3) {
    this.sha = uuid();
    this.info = {};
    this.timestamp = Date.now();
    this.ops = ops.slice(0);
    this.before = before || {};
    this.after = after || {};
  } else {
    throw new Error('Illegal arguments.')
  }
  
  this.updated = null;
  
  this.created = null;
  
  this.deleted = null;
};


DocumentChange.prototype._extractInformation = function _extractInformation (doc) {
  var ops = this.ops;
  var created = {};
  var deleted = {};
  var updated = {};
  var affectedContainerAnnos = [];

  
  function _checkAnnotation(op) {
    switch (op.type) {
      case "create":
      case "delete": {
        var node = op.val;
        if (node.hasOwnProperty('start')) {
          updated[node.start.path] = true;
        }
        if (node.hasOwnProperty('end')) {
          updated[node.end.path] = true;
        }
        break
      }
      case "update":
      case "set": {
        
        var node$1 = doc.get(op.path[0]);
        if (node$1) {
          if (node$1._isPropertyAnnotation) {
            updated[node$1.start.path] = true;
          } else if (node$1._isContainerAnnotation) {
            affectedContainerAnnos.push(node$1);
          }
        }
        break
      }
      default:
        
        throw new Error('Illegal state')
    }
  }

  for (var i = 0; i < ops.length; i++) {
    var op = ops[i];
    if (op.type === "create") {
      created[op.val.id] = op.val;
      delete deleted[op.val.id];
    }
    if (op.type === "delete") {
      delete created[op.val.id];
      deleted[op.val.id] = op.val;
    }
    if (op.type === "set" || op.type === "update") {
      updated[op.path] = true;
      
      updated[op.path[0]] = true;
    }
    _checkAnnotation(op);
  }

  affectedContainerAnnos.forEach(function(anno) {
    var container = doc.get(anno.containerId, 'strict');
    var startPos = container.getPosition(anno.start.path[0]);
    var endPos = container.getPosition(anno.end.path[0]);
    for (var pos = startPos; pos <= endPos; pos++) {
      var node = container.getChildAt(pos);
      var path = (void 0);
      if (node.isText()) {
        path = [node.id, 'content'];
      } else {
        path = [node.id];
      }
      if (!deleted[node.id]) {
        updated[path] = true;
      }
    }
  });

  
  if(Object.keys(deleted).length > 0) {
    forEach(updated, function(_, key) {
      var nodeId = key.split(',')[0];
      if (deleted[nodeId]) {
        delete updated[key];
      }
    });
  }

  this.created = created;
  this.deleted = deleted;
  this.updated = updated;
};

DocumentChange.prototype.invert = function invert () {
    var this$1 = this;

  
  var copy = this.toJSON();
  copy.ops = [];
  
  var tmp = copy.before;
  copy.before = copy.after;
  copy.after = tmp;
  var inverted = DocumentChange.fromJSON(copy);
  var ops = [];
  for (var i = this.ops.length - 1; i >= 0; i--) {
    ops.push(this$1.ops[i].invert());
  }
  inverted.ops = ops;
  return inverted
};


DocumentChange.prototype.isAffected = function isAffected (path) {
  //console.error('DEPRECATED: use change.hasUpdated() instead');
  return this.hasUpdated(path)
};

DocumentChange.prototype.isUpdated = function isUpdated (path) {
  //console.error('DEPRECATED: use change.hasUpdated() instead');
  return this.hasUpdated(path)
};


DocumentChange.prototype.hasUpdated = function hasUpdated (path) {
  return this.updated[path]
};

DocumentChange.prototype.hasDeleted = function hasDeleted (id) {
  return this.deleted[id]
};

DocumentChange.prototype.serialize = function serialize () {
  
  

  var opSerializer = new OperationSerializer();
  var data = this.toJSON();
  data.ops = this.ops.map(function(op) {
    return opSerializer.serialize(op)
  });
  return JSON.stringify(data)
};

DocumentChange.prototype.clone = function clone$$1 () {
  return DocumentChange.fromJSON(this.toJSON())
};

DocumentChange.prototype.toJSON = function toJSON () {
  var data = {
    
    sha: this.sha,
    
    before: clone(this.before),
    ops: map(this.ops, function(op) {
      return op.toJSON()
    }),
    info: this.info,
    
    after: clone(this.after),
  };

  
  
  data.after.selection = undefined;
  data.before.selection = undefined;

  var sel = this.before.selection;
  if (sel && sel._isSelection) {
    data.before.selection = sel.toJSON();
  }
  sel = this.after.selection;
  if (sel && sel._isSelection) {
    data.after.selection = sel.toJSON();
  }
  return data
};

DocumentChange.deserialize = function(str) {
  var opSerializer = new OperationSerializer();
  var data = JSON.parse(str);
  data.ops = data.ops.map(function(opData) {
    return opSerializer.deserialize(opData)
  });
  if (data.before.selection) {
    data.before.selection = fromJSON(data.before.selection);
  }
  if (data.after.selection) {
    data.after.selection = fromJSON(data.after.selection);
  }
  return new DocumentChange(data)
};

DocumentChange.fromJSON = function(data) {
  
  var change = cloneDeep(data);
  change.ops = data.ops.map(function(opData) {
    return ObjectOperation.fromJSON(opData)
  });
  change.before.selection = fromJSON(data.before.selection);
  change.after.selection = fromJSON(data.after.selection);
  return new DocumentChange(change)
};

var PathEventProxy = function PathEventProxy(doc) {
  this.listeners = new TreeIndex.Arrays();
  this._list = [];
  this.doc = doc;
};

PathEventProxy.prototype.on = function on (path, method, context) {
  this._add(context, path, method);
};




PathEventProxy.prototype.off = function off (context, path, method) {
  this._remove(context, path, method);
};

PathEventProxy.prototype.connect = function connect (listener, path, method) {
  console.warn('DEPRECATED: use proxy.on(path, this.onPropertyChange, this) instead');
  this.on(path, method, listener);
};

PathEventProxy.prototype.disconnect = function disconnect (listener) {
  console.warn('DEPRECATED: use proxy.off(this) instead');
  this.off(listener);
};

PathEventProxy.prototype.onDocumentChanged = function onDocumentChanged (change, info, doc) {
  
  if (this._list.length === 0) {
    return
  }
  var listeners = this.listeners;
  forEach(change.updated, function(_, pathStr) {
    var scopedListeners = listeners.get(pathStr.split(','));
    if (isArray$1(scopedListeners)) { scopedListeners = scopedListeners.slice(0); }
    forEach(scopedListeners, function(entry) {
      entry.method.call(entry.listener, change, info, doc);
    });
  });
};

PathEventProxy.prototype._add = function _add (listener, path, method) {
  if (!method) {
    throw new Error('Invalid argument: expected function but got ' + method)
  }
  var entry = { listener: listener, path: path, method: method };
  this.listeners.add(path, entry);
  this._list.push(entry);
};

PathEventProxy.prototype._remove = function _remove (listener, path, method) {
    var this$1 = this;

  for (var i = 0; i < this._list.length; i++) {
    var item = this$1._list[i];
    var match = (
      (!path || isEqual(item.path, path)) &&
      (!listener || item.listener === listener) &&
      (!method || item.method !== method)
    );
    if (match) {
      var entry = this$1._list[i];
      this$1._list.splice(i, 1);
      this$1.listeners.remove(entry.path, entry);
    }
  }
};

var Data = (function (EventEmitter$$1) {
  function Data(schema, nodeFactory) {
    EventEmitter$$1.call(this);

    
    if (!schema) {
      throw new Error('schema is mandatory')
    }
    if (!nodeFactory) {
      throw new Error('nodeFactory is mandatory')
    }
   

    this.schema = schema;
    this.nodeFactory = nodeFactory;
    this.nodes = {};
    this.indexes = {};

    
    
    this.__QUEUE_INDEXING__ = false;
    this.queue = [];
  }

  if ( EventEmitter$$1 ) Data.__proto__ = EventEmitter$$1;
  Data.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  Data.prototype.constructor = Data;

  
  Data.prototype.contains = function contains (id) {
    return Boolean(this.nodes[id])
  };

  
  Data.prototype.get = function get (path, strict) {
    var result = this._get(path);
    if (strict && result === undefined) {
      if (isString$1(path)) {
        throw new Error("Could not find node with id '"+path+"'.")
      } else if (!this.contains(path[0])) {
        throw new Error("Could not find node with id '"+path[0]+"'.")
      } else {
        throw new Error("Property for path '"+path+"' us undefined.")
      }
    }
    return result
  };

  Data.prototype._get = function _get (path) {
    if (!path) { return undefined }
    var result;
    if (isString$1(path)) {
      result = this.nodes[path];
    } else if (path.length === 1) {
      result = this.nodes[path[0]];
    } else if (path.length > 1) {
      var context = this.nodes[path[0]];
      for (var i = 1; i < path.length-1; i++) {
        if (!context) { return undefined }
        context = context[path[i]];
      }
      if (!context) { return undefined }
      result = context[path[path.length-1]];
    }
    return result
  };

  
  Data.prototype.getNodes = function getNodes () {
    return this.nodes
  };

  
  Data.prototype.create = function create (nodeData) {
    var node = this.nodeFactory.create(nodeData.type, nodeData);
    if (!node) {
      throw new Error('Illegal argument: could not create node for data:', nodeData)
    }
    if (this.contains(node.id)) {
      throw new Error("Node already exists: " + node.id)
    }
    if (!node.id || !node.type) {
      throw new Error("Node id and type are mandatory.")
    }
    this.nodes[node.id] = node;

    var change = {
      type: 'create',
      node: node
    };

    if (this.__QUEUE_INDEXING__) {
      this.queue.push(change);
    } else {
      this._updateIndexes(change);
    }

    return node
  };

  
  Data.prototype.delete = function delete$1 (nodeId) {
    var node = this.nodes[nodeId];
    if (!node) { return }
    node.dispose();
    delete this.nodes[nodeId];

    var change = {
      type: 'delete',
      node: node,
    };

    if (this.__QUEUE_INDEXING__) {
      this.queue.push(change);
    } else {
      this._updateIndexes(change);
    }

    return node
  };

  
  Data.prototype.set = function set (path, newValue) {
    var node = this.get(path[0]);
    var oldValue = this._set(path, newValue);
    var change = {
      type: 'set',
      node: node,
      path: path,
      newValue: newValue,
      oldValue: oldValue
    };
    if (this.__QUEUE_INDEXING__) {
      this.queue.push(change);
    } else {
      this._updateIndexes(change);
    }
    return oldValue
  };

  Data.prototype._set = function _set (path, newValue) {
    var oldValue = _setValue(this.nodes, path, newValue);
    return oldValue
  };

  
  Data.prototype.update = function update (path, diff$$1) {
    var realPath = this.getRealPath(path);
    if (!realPath) {
      console.error('Could not resolve path', path);
      return
    }
    var node = this.get(realPath[0]);
    var oldValue = this._get(realPath);
    var newValue;
    if (diff$$1.isOperation) {
      newValue = diff$$1.apply(oldValue);
    } else {
      diff$$1 = this._normalizeDiff(oldValue, diff$$1);
      if (isString$1(oldValue)) {
        switch (diff$$1.type) {
          case 'delete': {
            newValue = oldValue.split('').splice(diff$$1.start, diff$$1.end-diff$$1.start).join('');
            break
          }
          case 'insert': {
            newValue = [oldValue.substring(0, diff$$1.start), diff$$1.text, oldValue.substring(diff$$1.start)].join('');
            break
          }
          default:
            throw new Error('Unknown diff type')
        }
      } else if (isArray$1(oldValue)) {
        newValue = oldValue.slice(0);
        switch (diff$$1.type) {
          case 'delete': {
            newValue.splice(diff$$1.pos, 1);
            break
          }
          case 'insert': {
            newValue.splice(diff$$1.pos, 0, diff$$1.value);
            break
          }
          default:
            throw new Error('Unknown diff type')
        }
      } else if (oldValue._isCoordinate) {
        switch (diff$$1.type) {
          case 'shift': {
            
            oldValue = { path: oldValue.path, offset: oldValue.offset };
            newValue = oldValue;
            newValue.offset += diff$$1.value;
            break
          }
          default:
            throw new Error('Unknown diff type')
        }
      } else {
        throw new Error('Diff is not supported:', JSON.stringify(diff$$1))
      }
    }
    this._set(realPath, newValue);

    var change = {
      type: 'update',
      node: node,
      path: realPath,
      newValue: newValue,
      oldValue: oldValue
    };

    if (this.__QUEUE_INDEXING__) {
      this.queue.push(change);
    } else {
      this._updateIndexes(change);
    }

    return oldValue
  };

  
  Data.prototype._normalizeDiff = function _normalizeDiff (value, diff$$1) {
    if (isString$1(value)) {
      
      if (diff$$1['delete']) {
        console.warn('DEPRECATED: use doc.update(path, {type:"delete", start:s, end: e}) instead');
        diff$$1 = {
          type: 'delete',
          start: diff$$1['delete'].start,
          end: diff$$1['delete'].end
        };
      } else if (diff$$1['insert']) {
        console.warn('DEPRECATED: use doc.update(path, {type:"insert", start:s, text: t}) instead');
        diff$$1 = {
          type: 'insert',
          start: diff$$1['insert'].offset,
          text: diff$$1['insert'].value
        };
      }
    } else if (isArray$1(value)) {
      
      if (diff$$1['delete']) {
        console.warn('DEPRECATED: use doc.update(path, {type:"delete", pos:1}) instead');
        diff$$1 = {
          type: 'delete',
          pos: diff$$1['delete'].offset
        };
      } else if (diff$$1['insert']) {
        console.warn('DEPRECATED: use doc.update(path, {type:"insert", pos:1, value: "foo"}) instead');
        diff$$1 = {
          type: 'insert',
          pos: diff$$1['insert'].offset,
          value: diff$$1['insert'].value
        };
      }
    } else if (value._isCoordinate) {
      if (diff$$1.hasOwnProperty('shift')) {
        console.warn('DEPRECATED: use doc.update(path, {type:"shift", value:2}) instead');
        diff$$1 = {
          type: 'shift',
          value: diff$$1['shift']
        };
      }
    }
    return diff$$1
  };

  
  Data.prototype.toJSON = function toJSON () {
    var nodes = {};
    forEach(this.nodes, function (node){
      nodes[node.id] = node.toJSON();
    });
    return {
      schema: [this.schema.id, this.schema.version],
      nodes: nodes
    }
  };

  
  Data.prototype.reset = function reset () {
    this.nodes.clear();
  };

  
  Data.prototype.addIndex = function addIndex (name, index) {
    if (this.indexes[name]) {
      console.error('Index with name %s already exists.', name);
    }
    index.reset(this);
    this.indexes[name] = index;
    return index
  };

  
  Data.prototype.getIndex = function getIndex (name) {
    return this.indexes[name]
  };

  
  Data.prototype._updateIndexes = function _updateIndexes (change) {
    if (!change || this.__QUEUE_INDEXING__) { return }
    forEach(this.indexes, function(index) {
      if (index.select(change.node)) {
        if (!index[change.type]) {
          console.error('Contract: every NodeIndex must implement ' + change.type);
        }
        index[change.type](change.node, change.path, change.newValue, change.oldValue);
      }
    });
  };

  
  Data.prototype._stopIndexing = function _stopIndexing () {
    this.__QUEUE_INDEXING__ = true;
  };

  
  Data.prototype._startIndexing = function _startIndexing () {
    var this$1 = this;

    this.__QUEUE_INDEXING__ = false;
    while(this.queue.length >0) {
      var change = this$1.queue.shift();
      this$1._updateIndexes(change);
    }
  };

  return Data;
}(EventEmitter));

function _setValue(root, path, newValue) {
  var ctx = root;
  var L = path.length;
  for (var i = 0; i < L-1; i++) {
    ctx = ctx[path[i]];
    if (!ctx) { throw new Error('Can not set value.') }
  }
  var oldValue = ctx[path[L-1]];
  ctx[path[L-1]] = newValue;
  return oldValue
}

var IncrementalData = (function (Data$$1) {
  function IncrementalData () {
    Data$$1.apply(this, arguments);
  }

  if ( Data$$1 ) IncrementalData.__proto__ = Data$$1;
  IncrementalData.prototype = Object.create( Data$$1 && Data$$1.prototype );
  IncrementalData.prototype.constructor = IncrementalData;

  IncrementalData.prototype.create = function create (nodeData) {
    if (nodeData._isNode) {
      nodeData = nodeData.toJSON();
    }
    var op = ObjectOperation.Create([nodeData.id], nodeData);
    this.apply(op);
    return op
  };

  
  IncrementalData.prototype.delete = function delete$1 (nodeId) {
    var op = null;
    var node = this.get(nodeId);
    if (node) {
      var nodeData = node.toJSON();
      op = ObjectOperation.Delete([nodeId], nodeData);
      this.apply(op);
    }
    return op
  };

  
  IncrementalData.prototype.update = function update (path, diff$$1) {
    var diffOp = this._getDiffOp(path, diff$$1);
    var op = ObjectOperation.Update(path, diffOp);
    this.apply(op);
    return op
  };

  
  IncrementalData.prototype.set = function set (path, newValue) {
    var oldValue = this.get(path);
    var op = ObjectOperation.Set(path, oldValue, newValue);
    this.apply(op);
    return op
  };

  
  IncrementalData.prototype.apply = function apply (op) {
    if (op.type === ObjectOperation.NOP) { return }
    else if (op.type === ObjectOperation.CREATE) {
      
      Data$$1.prototype.create.call(this, cloneDeep(op.val));
    } else if (op.type === ObjectOperation.DELETE) {
      Data$$1.prototype.delete.call(this, op.val.id);
    } else if (op.type === ObjectOperation.UPDATE) {
      var oldVal = this.get(op.path);
      var diff$$1 = op.diff;
      if (op.propertyType === 'array') {
        if (! (diff$$1._isArrayOperation) ) {
          diff$$1 = ArrayOperation.fromJSON(diff$$1);
        }
        
        diff$$1.apply(oldVal);
      } else if (op.propertyType === 'string') {
        if (!(diff$$1._isTextOperation) ) {
          diff$$1 = TextOperation.fromJSON(diff$$1);
        }
        var newVal = diff$$1.apply(oldVal);
        Data$$1.prototype.set.call(this, op.path, newVal);
      } else if (op.propertyType === 'coordinate') {
        if (!(diff$$1._isCoordinateOperation) ) {
          diff$$1 = CoordinateOperation.fromJSON(diff$$1);
        }
        diff$$1.apply(oldVal);
      } else {
        throw new Error("Unsupported type for operational update.")
      }
    } else if (op.type === ObjectOperation.SET) {
      Data$$1.prototype.set.call(this, op.path, op.val);
    } else {
      throw new Error("Illegal state.")
    }
    this.emit('operation:applied', op, this);
  };

  
  IncrementalData.prototype._getDiffOp = function _getDiffOp (path, diff$$1) {
    var diffOp = null;
    if (diff$$1.isOperation) {
      diffOp = diff$$1;
    } else {
      var value = this.get(path);
      diff$$1 = this._normalizeDiff(value, diff$$1);
      if (value === null || value === undefined) {
        throw new Error('Property has not been initialized: ' + JSON.stringify(path))
      } else if (isString$1(value)) {
        switch (diff$$1.type) {
          case 'delete': {
            diffOp = TextOperation.Delete(diff$$1.start, value.substring(diff$$1.start, diff$$1.end));
            break
          }
          case 'insert': {
            diffOp = TextOperation.Insert(diff$$1.start, diff$$1.text);
            break
          }
          default:
            throw new Error('Unknown diff type')
        }
      } else if (isArray$1(value)) {
        switch (diff$$1.type) {
          case 'delete': {
            diffOp = ArrayOperation.Delete(diff$$1.pos, value[diff$$1.pos]);
            break
          }
          case 'insert': {
            diffOp = ArrayOperation.Insert(diff$$1.pos, diff$$1.value);
            break
          }
          default:
            throw new Error('Unknown diff type')
        }
      } else if (value._isCoordinate) {
        switch (diff$$1.type) {
          case 'shift': {
            diffOp = CoordinateOperation.Shift(diff$$1.value);
            break
          }
          default:
            throw new Error('Unknown diff type')
        }
      }
    }
    if (!diffOp) {
      throw new Error('Unsupported diff: ' + JSON.stringify(diff$$1))
    }
    return diffOp
  };

  return IncrementalData;
}(Data));

var DocumentNodeFactory = function DocumentNodeFactory(doc) {
  this.doc = doc;
};

DocumentNodeFactory.prototype.create = function create (nodeType, nodeData) {
  var NodeClass = this.doc.schema.getNodeClass(nodeType);
  if (!NodeClass) {
    throw new Error('No node registered by that name: ' + nodeType)
  }
  return new NodeClass(this.doc, nodeData)
};

var JSONConverter = function JSONConverter () {};

JSONConverter.prototype.importDocument = function importDocument (doc, json) {
  if (!json.nodes) {
    throw new Error('Invalid JSON format.')
  }
  var schema = doc.getSchema();
  if (json.schema && schema.name !== json.schema.name) {
    throw new Error('Incompatible schema.')
  }
  
  var nodes = json.nodes;
  
  
  
  doc.import(function(tx) {
    forEach(nodes, function(node) {
      
      if (tx.get(node.id)) {
        tx.delete(node.id);
      }
      tx.create(node);
    });
  });
  return doc
};

JSONConverter.prototype.exportDocument = function exportDocument (doc) {
  var schema = doc.getSchema();
  var json = {
    schema: {
      name: schema.name
    },
    nodes: {}
  };
  forEach(doc.getNodes(), function(node) {
    if (node._isDocumentNode) {
      json.nodes[node.id] = node.toJSON();
    }
  });
  return json
};

var ParentNodeHook = function ParentNodeHook(doc) {
  this.doc = doc;
  this.table = {};
  doc.data.on('operation:applied', this._onOperationApplied, this);
};

ParentNodeHook.prototype._onOperationApplied = function _onOperationApplied (op) {
  var doc = this.doc;
  var table = this.table;
  var node = doc.get(op.path[0]);
  
  
  switch(op.type) {
    case 'create': {
      switch (node.type) {
        case 'list':
          _setParent(node, node.items);
          break
        case 'list-item': {
          _setRegisteredParent(node);
          break
        }
        case 'table':
          _setParent(node, node.cells);
          break
        case 'table-cell': {
          _setRegisteredParent(node);
          break
        }
        default:
          
      }
      break
    }
    case 'update': {
      
      
      var update = op.diff;
      switch(node.type) {
        case 'list':
          if (op.path[1] === 'items') {
            if (update.isInsert()) {
              _setParent(node, update.getValue());
            }
          }
          break
        case 'table':
          if (op.path[1] === 'cells') {
            if (update.isInsert()) {
              _setParent(node, update.getValue());
            }
          }
          break
        default:
          
      }
      break
    }
    case 'set': {
      switch(node.type) {
        case 'list':
          if (op.path[1] === 'items') {
            _setParent(node, op.getValue());
          }
          break
        case 'table':
          if (op.path[1] === 'cells') {
            _setParent(node, op.getValue());
          }
          break
        default:
          
      }
      break
    }
    default:
      
  }

  function _setParent(parent, ids) {
    if (ids) {
      if (isArray$1(ids)) {
        ids.forEach(_set);
      } else {
        _set(ids);
      }
    }
    function _set(id) {
      
      
      
      table[id] = parent;
      var child = doc.get(id);
      if (child) {
        child.parent = parent;
      }
    }
  }
  function _setRegisteredParent(child) {
    var parent = table[child.id];
    if (parent) {
      child.parent = parent;
    }
  }
};

ParentNodeHook.register = function(doc) {
  return new ParentNodeHook(doc)
};

var converter = new JSONConverter();



var Document = (function (EventEmitter$$1) {
  function Document(schema) {
    EventEmitter$$1.call(this);

    
    if (arguments[0] === 'SKIP') { return }

    this.__id__ = uuid();

    
    if (!schema) {
      throw new Error('A document needs a schema for reflection.')
    }

    this.schema = schema;
    this.nodeFactory = new DocumentNodeFactory(this);
    this.data = new IncrementalData(schema, this.nodeFactory);

    
    this.addIndex('type', new PropertyIndex('type'));

    
    this.addIndex('annotations', new AnnotationIndex());

    
    
    
    this.addIndex('container-annotations', new ContainerAnnotationIndex());

    
    
    
    
    
    
    
    this.eventProxies = {
      'path': new PathEventProxy(this),
    };
    this.on('document:changed', this._updateEventProxies, this);
    
    
    ParentNodeHook.register(this);
  }

  if ( EventEmitter$$1 ) Document.__proto__ = EventEmitter$$1;
  Document.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  Document.prototype.constructor = Document;

  var prototypeAccessors = { id: {} };

  Document.prototype.dispose = function dispose () {
    this.off();
    this.data.off();
  };

  prototypeAccessors.id.get = function () {
    return this.__id__
  };

  
  Document.prototype.getSchema = function getSchema () {
    return this.schema
  };

  
  Document.prototype.contains = function contains (id) {
    return this.data.contains(id)
  };

  
  Document.prototype.get = function get (path, strict) {
    return this.data.get(path, strict)
  };

  
  Document.prototype.getNodes = function getNodes () {
    return this.data.getNodes()
  };

  
  Document.prototype.import = function import$1 (importer) {
    try {
      this.data._stopIndexing();
      importer(this);
      this.data._startIndexing();
    } finally {
      this.data.queue = [];
      this.data._startIndexing();
    }
  };

  
  Document.prototype.create = function create (nodeData) {
    if (!nodeData.id) {
      nodeData.id = uuid(nodeData.type);
    }
    var op = this._create(nodeData);
    var change = new DocumentChange([op], {}, {});
    change._extractInformation(this);
    this._notifyChangeListeners(change, { hidden: true });
    return this.data.get(nodeData.id)
  };

  
  Document.prototype.delete = function delete$1 (nodeId) {
    var node = this.get(nodeId);
    var op = this._delete(nodeId);
    var change = new DocumentChange([op], {}, {});
    change._extractInformation(this);
    this._notifyChangeListeners(change, { hidden: true });
    return node
  };

  
  Document.prototype.set = function set (path, value) {
    var oldValue = this.get(path);
    var op = this._set(path, value);
    var change = new DocumentChange([op], {}, {});
    change._extractInformation(this);
    this._notifyChangeListeners(change, { hidden: true });
    return oldValue
  };

  
  Document.prototype.update = function update (path, diff$$1) {
    var op = this._update(path, diff$$1);
    var change = new DocumentChange([op], {}, {});
    change._extractInformation(this);
    this._notifyChangeListeners(change, { hidden: true });
    return op
  };

  
  Document.prototype.addIndex = function addIndex (name, index) {
    return this.data.addIndex(name, index)
  };

  
  Document.prototype.getIndex = function getIndex (name) {
    return this.data.getIndex(name)
  };

  
  Document.prototype.createSelection = function createSelection (data) {
    var sel;
    if (isNil(data)) { return Selection.nullSelection }
    if (arguments.length !== 1 || !isPlainObject$1(data)) {
      throw new Error('Illegal argument: call createSelection({ type: ... }')
    } else {
      switch (data.type) {
        case 'property': {
          if (isNil(data.endOffset)) {
            data.endOffset = data.startOffset;
          }
          if (!data.hasOwnProperty('reverse')) {
            if (data.startOffset>data.endOffset) {
              var assign;
              (assign = [data.endOffset, data.startOffset], data.startOffset = assign[0], data.endOffset = assign[1]);
              data.reverse = !data.reverse;
            }
          }
          
          var text = this.get(data.path, 'strict');
          if (data.startOffset < 0 || data.startOffset > text.length) {
            throw new Error('Invalid startOffset: target property has length '+text.length+', given startOffset is ' + data.startOffset)
          }
          if (data.endOffset < 0 || data.endOffset > text.length) {
            throw new Error('Invalid startOffset: target property has length '+text.length+', given endOffset is ' + data.endOffset)
          }
          sel = new PropertySelection(data);
          break
        }
        case 'container': {
          var container = this.get(data.containerId, 'strict');
          if (!container) { throw new Error('Can not create ContainerSelection: container "'+data.containerId+'" does not exist.') }
          var start = this._normalizeCoor({ path: data.startPath, offset: data.startOffset});
          var end = this._normalizeCoor({ path: data.endPath, offset: data.endOffset});
          var startAddress = container.getAddress(start);
          var endAddress = container.getAddress(end);
          if (!startAddress) {
            throw new Error('Invalid arguments for ContainerSelection: ', start.toString())
          }
          if (!endAddress) {
            throw new Error('Invalid arguments for ContainerSelection: ', end.toString())
          }
          if (!data.hasOwnProperty('reverse')) {
            if (endAddress.isBefore(startAddress, 'strict')) {
              var assign$1;
              (assign$1 = [end, start], start = assign$1[0], end = assign$1[1]);
              data.reverse = true;
            }
          }
          sel = new ContainerSelection(container.id, start.path, start.offset, end.path, end.offset, data.reverse, data.surfaceId);
          break
        }
        case 'node': {
          sel = createNodeSelection({
            doc: this,
            nodeId: data.nodeId,
            mode: data.mode,
            containerId: data.containerId,
            reverse: data.reverse,
            surfaceId: data.surfaceId
          });
          break
        }
        case 'custom': {
          sel = CustomSelection.fromJSON(data);
          break
        }
        default:
          throw new Error('Illegal selection type', data)
      }
    }
    if (!sel.isNull()) {
      sel.attach(this);
    }
    return sel
  };

  Document.prototype.getEventProxy = function getEventProxy (name) {
    return this.eventProxies[name]
  };

  Document.prototype.newInstance = function newInstance () {
    var DocumentClass = this.constructor;
    return new DocumentClass(this.schema)
  };

  
  Document.prototype.createSnippet = function createSnippet () {
    var snippet = this.newInstance();
    var snippetContainer = snippet.create({
      type: 'container',
      id: Document.SNIPPET_ID
    });
    snippet.getContainer = function() {
      return snippetContainer
    };
    return snippet
  };

  Document.prototype._apply = function _apply (documentChange) {
    forEach(documentChange.ops, function(op) {
      this.data.apply(op);
      this.emit('operation:applied', op);
    }.bind(this));
    
    documentChange._extractInformation(this);
  };

  Document.prototype._notifyChangeListeners = function _notifyChangeListeners (change, info) {
    info = info || {};
    this.emit('document:changed', change, info, this);
  };

  Document.prototype._updateEventProxies = function _updateEventProxies (change, info) {
    forEach(this.eventProxies, function(proxy) {
      proxy.onDocumentChanged(change, info, this);
    }.bind(this));
  };

  Document.prototype.createFromDocument = function createFromDocument (doc) {
    var this$1 = this;

    var nodes = doc.getNodes();
    var annotations = [];
    var contentNodes = [];
    var containers = [];
    forEach(nodes, function (node) {
      if (node._isAnnotation) {
        annotations.push(node);
      } else if (node._isContainer) {
        containers.push(node);
      } else {
        contentNodes.push(node);
      }
    });
    contentNodes.concat(annotations).concat(containers).forEach(function (n){ return this$1.create(n); });
  };

  
  Document.prototype.toJSON = function toJSON () {
    return converter.exportDocument(this)
  };

  Document.prototype.getAnnotations = function getAnnotations (path) {
    return this.getIndex('annotations').get(path)
  };

  Document.prototype._create = function _create (nodeData) {
    var op = this.data.create(nodeData);
    return op
  };

  Document.prototype._delete = function _delete (nodeId) {
    var op = this.data.delete(nodeId);
    return op
  };

  Document.prototype._update = function _update (path, diff$$1) {
    var op = this.data.update(path, diff$$1);
    return op
  };

  Document.prototype._set = function _set (path, value) {
    var op = this.data.set(path, value);
    return op
  };

  
  Document.prototype._createSelectionFromRange = function _createSelectionFromRange (range) {
    if (!range) { return Selection.nullSelection }
    var inOneNode = isEqual(range.start.path, range.end.path);
    if (inOneNode) {
      if (range.start.isNodeCoordinate()) {
        
        
        return new NodeSelection(range.containerId, range.start.getNodeId(), 'full', range.reverse, range.surfaceId)
      } else {
        return this.createSelection({
          type: 'property',
          path: range.start.path,
          startOffset: range.start.offset,
          endOffset: range.end.offset,
          reverse: range.reverse,
          containerId: range.containerId,
          surfaceId: range.surfaceId
        })
      }
    } else {
      return this.createSelection({
        type: 'container',
        startPath: range.start.path,
        startOffset: range.start.offset,
        endPath: range.end.path,
        endOffset: range.end.offset,
        reverse: range.reverse,
        containerId: range.containerId,
        surfaceId: range.surfaceId
      })
    }
  };

  Document.prototype._normalizeCoor = function _normalizeCoor (ref) {
    var path = ref.path;
    var offset = ref.offset;

    
    if (path.length === 1) {
      var node = this.get(path[0]).getRoot();
      if (node.isText()) {
        
        return new Coordinate(node.getTextPath(), offset === 0 ? 0 : node.getLength())
      } else if (node.isList()) {
        
        if (offset === 0) {
          var item = node.getItemAt(0);
          return new Coordinate(item.getTextPath(), 0)
        } else {
          var item$1 = this.get(last$1(node.items));
          return new Coordinate(item$1.getTextPath(), item$1.getLength())
        }
      }
    }
    return new Coordinate(path, offset)
  };

  Object.defineProperties( Document.prototype, prototypeAccessors );

  return Document;
}(EventEmitter));

Document.prototype._isDocument = true;



Document.SNIPPET_ID = "snippet";

Document.TEXT_SNIPPET_ID = "text-snippet";

var TransactionDocument = (function (Document$$1) {
  function TransactionDocument(document) {
    Document$$1.call(this, 'SKIP');

    this.schema = document.schema;
    this.nodeFactory = new DocumentNodeFactory(this);
    this.data = new IncrementalData(this.schema, this.nodeFactory);

    this.document = document;

    
    this.ops = [];
    this.lastOp = null;

    
    forEach(document.data.indexes, function(index, name) {
      this.data.addIndex(name, index.clone());
    }.bind(this));

    
    ParentNodeHook.register(this);

    this.createFromDocument(document);

    
    document.on('document:changed', this._onDocumentChanged, this);
    this._skipNextDocumentChange = false;
  }

  if ( Document$$1 ) TransactionDocument.__proto__ = Document$$1;
  TransactionDocument.prototype = Object.create( Document$$1 && Document$$1.prototype );
  TransactionDocument.prototype.constructor = TransactionDocument;

  TransactionDocument.prototype.dispose = function dispose () {
    this.document.off(this);
    this.data.off();
  };

  TransactionDocument.prototype.create = function create (nodeData) {
    if (!nodeData.id) {
      nodeData.id = uuid(nodeData.type);
    }
    if (!nodeData.type) {
      throw new Error('No node type provided')
    }
    this.lastOp = this.data.create(nodeData);
    if (this.lastOp) {
      this.ops.push(this.lastOp);
      return this.data.get(nodeData.id)
    }
  };

  TransactionDocument.prototype.createDefaultTextNode = function createDefaultTextNode (text, dir) {
    return this.create({
      type: this.getSchema().getDefaultTextType(),
      content: text || '',
      direction: dir
    })
  };

  TransactionDocument.prototype.delete = function delete$1 (nodeId) {
    this.lastOp = this.data.delete(nodeId);
    if (this.lastOp) {
      this.ops.push(this.lastOp);
    }
  };

  TransactionDocument.prototype.set = function set (path, value) {
    this.lastOp = this.data.set(path, value);
    if (this.lastOp) {
      this.ops.push(this.lastOp);
    }
  };

  TransactionDocument.prototype.update = function update (path, diffOp) {
    var op = this.lastOp = this.data.update(path, diffOp);
    if (op) {
      this.ops.push(op);
      return op
    }
  };

  TransactionDocument.prototype._onDocumentChanged = function _onDocumentChanged (change) {
    if (this._skipNextDocumentChange) {
      this._skipNextDocumentChange = false;
    } else {
      
      
      this._apply(change);
    }
  };

  TransactionDocument.prototype._apply = function _apply (documentChange) {
    documentChange.ops.forEach(function(op) {
      this.data.apply(op);
    }.bind(this));
  };

  TransactionDocument.prototype._reset = function _reset () {
    this.ops = [];
    this.lastOp = null;
  };

  TransactionDocument.prototype._rollback = function _rollback () {
    var this$1 = this;

    for (var i = this.ops.length - 1; i >= 0; i--) {
      this$1.data.apply(this$1.ops[i].invert());
    }
    this.ops = [];
    this.lastOp = null;
  };

  TransactionDocument.prototype.newInstance = function newInstance () {
    return this.document.newInstance()
  };

  return TransactionDocument;
}(Document));

TransactionDocument.prototype._isTransactionDocument = true;

function copySelection(doc, selection) {
  if (!selection) { throw new Error("'selection' is mandatory.") }
  var copy = null;
  if (!selection.isNull() && !selection.isCollapsed()) {
    
    if (selection.isPropertySelection()) {
      copy = _copyPropertySelection(doc, selection);
    }
    else if (selection.isContainerSelection()) {
      copy = _copyContainerSelection(doc, selection);
    }
    else if (selection.isNodeSelection()) {
      copy = _copyNodeSelection(doc, selection);
    }
    else {
      console.error('Copy is not yet supported for selection type.');
    }
  }
  return copy
}

function _copyPropertySelection(doc, selection) {
  var path = selection.start.path;
  var offset = selection.start.offset;
  var endOffset = selection.end.offset;
  var text = doc.get(path);
  var snippet = doc.createSnippet();
  var containerNode = snippet.getContainer();
  snippet.create({
    type: doc.schema.getDefaultTextType(),
    id: Document.TEXT_SNIPPET_ID,
    content: text.substring(offset, endOffset)
  });
  containerNode.show(Document.TEXT_SNIPPET_ID);
  var annotations = doc.getIndex('annotations').get(path, offset, endOffset);
  forEach(annotations, function(anno) {
    var data = cloneDeep(anno.toJSON());
    var path = [Document.TEXT_SNIPPET_ID, 'content'];
    data.start = {
      path: path,
      offset: Math.max(offset, anno.start.offset)-offset
    };
    data.end = {
      path: path,
      offset: Math.min(endOffset, anno.end.offset)-offset
    };
    snippet.create(data);
  });
  return snippet
}

function _copyContainerSelection(tx, sel) {
  var snippet = tx.createSnippet();
  var container = snippet.getContainer();

  var nodeIds = sel.getNodeIds();
  var L = nodeIds.length;
  if (L === 0) { return snippet }

  var start = sel.start;
  var end = sel.end;

  var skippedFirst = false;
  var skippedLast = false;

  
  var created = {};
  for(var i = 0; i<L; i++) {
    var id = nodeIds[i];
    var node = tx.get(id);
    
    if (i===0 && isLast(tx, start)) {
      skippedFirst = true;
      continue
    }
    if (i===L-1 && isFirst(tx, end)) {
      skippedLast = true;
      continue
    }
    if (!created[id]) {
      documentHelpers.copyNode(node).forEach(function (nodeData) {
        var copy = snippet.create(nodeData);
        created[copy.id] = true;
      });
      container.show(id);
    }
  }
  if (!skippedFirst) {
    
    var startNode = snippet.get(start.getNodeId()).getRoot();
    if (startNode.isText()) {
      documentHelpers.deleteTextRange(snippet, null, start);
    } else if (startNode.isList()) {
      documentHelpers.deleteListRange(snippet, startNode, null, start);
    }
  }
  if (!skippedLast) {
    
    var endNode = snippet.get(end.getNodeId()).getRoot();
    if (endNode.isText()) {
      documentHelpers.deleteTextRange(snippet, end, null);
    } else if (endNode.isList()) {
      documentHelpers.deleteListRange(snippet, endNode, end, null);
    }
  }
  return snippet
}

function _copyNodeSelection(doc, selection) {
  var snippet = doc.createSnippet();
  var containerNode = snippet.getContainer();
  var nodeId = selection.getNodeId();
  var node = doc.get(nodeId);
  documentHelpers.copyNode(node).forEach(function (nodeData) {
    snippet.create(nodeData);
  });
  containerNode.show(node.id);
  return snippet
}

function paste(tx, args) {
  var sel = tx.selection;
  if (!sel || sel.isNull()) {
    throw new Error("Can not paste, without selection.")
  }
  args = args || {};
  args.text = args.text || '';
  var pasteDoc = args.doc;
  
  
  var inContainer = Boolean(sel.containerId);

  
  
  
  if (!pasteDoc && !inContainer) {
    tx.insertText(args.text);
    return
  }
  if (!pasteDoc) {
    pasteDoc = _convertPlainTextToDocument(tx, args);
  }
  if (!sel.isCollapsed()) {
    tx.deleteSelection();
  }
  var nodes = pasteDoc.get(Document.SNIPPET_ID).nodes;
  var schema = tx.getSchema();
  if (nodes.length > 0) {
    var first = pasteDoc.get(nodes[0]);
    if (schema.isInstanceOf(first.type, 'text')) {
      _pasteAnnotatedText(tx, pasteDoc);
      
      
      nodes.shift();
    }
    
    if (nodes.length > 0) {
      _pasteDocument(tx, pasteDoc);
    }
  }
  return args
}


function _convertPlainTextToDocument(tx, args) {
  var lines = args.text.split(/\s*\n\s*\n/);
  var pasteDoc = tx.getDocument().newInstance();
  var defaultTextType = pasteDoc.getSchema().getDefaultTextType();
  var container = pasteDoc.create({
    type: 'container',
    id: Document.SNIPPET_ID,
    nodes: []
  });
  var node;
  if (lines.length === 1) {
    node = pasteDoc.create({
      id: Document.TEXT_SNIPPET_ID,
      type: defaultTextType,
      content: lines[0]
    });
    container.show(node.id);
  } else {
    for (var i = 0; i < lines.length; i++) {
      node = pasteDoc.create({
        id: uuid(defaultTextType),
        type: defaultTextType,
        content: lines[i]
      });
      container.show(node.id);
    }
  }
  return pasteDoc
}

function _pasteAnnotatedText(tx, copy) {
  var sel = tx.selection;
  var nodes = copy.get(Document.SNIPPET_ID).nodes;
  var textPath = [nodes[0], 'content'];
  var text = copy.get(textPath);
  var annotations = copy.getIndex('annotations').get(textPath);
  
  var path = sel.start.path;
  var offset = sel.start.offset;
  tx.insertText(text);
  
  forEach(annotations, function(anno) {
    var data = anno.toJSON();
    data.start.path = path.slice(0);
    data.start.offset += offset;
    data.end.offset += offset;
    
    if (tx.get(data.id)) { data.id = uuid(data.type); }
    tx.create(data);
  });
}

function _pasteDocument(tx, pasteDoc) {
  var sel = tx.selection;
  var containerId = sel.containerId;
  var container = tx.get(containerId);
  var insertPos;
  if (sel.isPropertySelection()) {
    var startPath = sel.start.path;
    var nodeId = sel.start.getNodeId();
    var startPos = container.getPosition(nodeId, 'strict');
    var text = tx.get(startPath);
    
    
    if (text.length === 0) {
      insertPos = startPos;
      container.hide(nodeId);
      documentHelpers.deleteNode(tx, tx.get(nodeId));
    } else if ( text.length === sel.start.offset ) {
      insertPos = startPos + 1;
    } else {
      tx.break();
      insertPos = startPos + 1;
    }
  } else if (sel.isNodeSelection()) {
    var nodePos = container.getPosition(sel.getNodeId(), 'strict');
    if (sel.isBefore()) {
      insertPos = nodePos;
    } else if (sel.isAfter()) {
      insertPos = nodePos+1;
    } else {
      throw new Error('Illegal state: the selection should be collapsed.')
    }
  }
  
  var nodeIds = pasteDoc.get(Document.SNIPPET_ID).nodes;
  var insertedNodes = [];
  var visited = {};
  for (var i = 0; i < nodeIds.length; i++) {
    var node = pasteDoc.get(nodeIds[i]);
    
    
    
    
    
    var newId = _transferWithDisambiguatedIds(node.getDocument(), tx, node.id, visited);
    
    node = tx.get(newId);
    container.show(newId, insertPos++);
    insertedNodes.push(node);
  }

  if (insertedNodes.length > 0) {
    var lastNode = last$1(insertedNodes);
    setCursor(tx, lastNode, containerId, 'after');
  }
}






function _transferWithDisambiguatedIds(sourceDoc, targetDoc, id, visited) {
  if (visited[id]) { throw new Error('FIXME: dont call me twice') }
  var node = sourceDoc.get(id, 'strict');
  var oldId = node.id;
  var newId;
  if (targetDoc.contains(node.id)) {
    
    newId = uuid(node.type);
    node.id = newId;
  }
  visited[id] = node.id;
  var annotationIndex = sourceDoc.getIndex('annotations');
  var nodeSchema = node.getSchema();
  
  var annos = [];
  
  
  
  for (var key in nodeSchema) {
    if (key === 'id' || key === 'type' || !nodeSchema.hasOwnProperty(key)) { continue }
    var prop = nodeSchema[key];
    var name = prop.name;
    
    if ((prop.isReference() && prop.isOwned()) || (prop.type === 'file')) {
      
      
      var val = node[prop.name];
      if (prop.isArray()) {
        _transferArrayOfReferences(sourceDoc, targetDoc, val, visited);
      } else {
        var id$1 = val;
        if (!visited[id$1]) {
          node[name] = _transferWithDisambiguatedIds(sourceDoc, targetDoc, id$1, visited);
        }
      }
    }
    
    else if (prop.isText()) {
      var _annos = annotationIndex.get([node.id]);
      for (var i = 0; i < _annos.length; i++) {
        var anno = _annos[i];
        if (anno.start.path[0] === oldId) {
          anno.start.path[0] = newId;
        }
        if (anno.end.path[0] === oldId) {
          anno.end.path[0] = newId;
        }
        annos.push(anno);
      }
    }
  }
  targetDoc.create(node);
  for (var i$1 = 0; i$1 < annos.length; i$1++) {
    _transferWithDisambiguatedIds(sourceDoc, targetDoc, annos[i$1].id, visited);
  }
  return node.id
}

function _transferArrayOfReferences(sourceDoc, targetDoc, arr, visited) {
  for (var i = 0; i < arr.length; i++) {
    var val = arr[i];
    
    if (isArray$1(val)) {
      _transferArrayOfReferences(sourceDoc, targetDoc, val, visited);
    } else {
      var id = val;
      if (id && !visited[id]) {
        arr[i] = _transferWithDisambiguatedIds(sourceDoc, targetDoc, id, visited);
      }
    }
  }
}

var Editing = function Editing () {};

Editing.prototype.annotate = function annotate (tx, annotation) {
  var sel = tx.selection;
  var schema = tx.getSchema();
  var AnnotationClass = schema.getNodeClass(annotation.type);
  if (!AnnotationClass) { throw new Error('Unknown annotation type', annotation) }
  var start = sel.start;
  var end = sel.end;
  var containerId = sel.containerId;
  var nodeData = { start: start, end: end, containerId: containerId };
  
  if (sel.isPropertySelection()) {
    if (!AnnotationClass.prototype._isAnnotation) {
      throw new Error('Annotation can not be created for a selection.')
    }
  } else if (sel.isContainerSelection()) {
    if (AnnotationClass.prototype._isPropertyAnnotation) {
      console.warn('NOT SUPPORTED YET: creating property annotations for a non collapsed container selection.');
    }
  }
  Object.assign(nodeData, annotation);
  return tx.create(nodeData)
};

Editing.prototype.break = function break$1 (tx) {
  var sel = tx.selection;
  if (sel.isNodeSelection()) {
    var containerId = sel.containerId;
    var container = tx.get(containerId);
    var nodeId = sel.getNodeId();
    var nodePos = container.getPosition(nodeId, 'strict');
    var textNode = tx.createDefaultTextNode();
    if (sel.isBefore()) {
      tx.update(container.getContentPath(), { type: 'insert', pos: nodePos, value: textNode.id });
      
    } else {
      tx.update(container.getContentPath(), { type: 'insert', pos: nodePos+1, value: textNode.id });
      setCursor(tx, textNode, containerId, 'before');
    }
  }
  else if (sel.isCustomSelection()) {
    
  }
  else if (sel.isCollapsed() || sel.isPropertySelection()) {
    var containerId$1 = sel.containerId;
    if (!sel.isCollapsed()) {
      
      this._deletePropertySelection(tx, sel);
      tx.setSelection(sel.collapse('left'));
    }
    
    if (containerId$1) {
      var container$1 = tx.get(containerId$1);
      var nodeId$1 = sel.start.path[0];
      var node = tx.get(nodeId$1);
      this._breakNode(tx, node, sel.start, container$1);
    }
  }
  else if (sel.isContainerSelection()) {
    var start = sel.start;
    var containerId$2 = sel.containerId;
    var container$2 = tx.get(containerId$2);
    var startNodeId = start.path[0];
    var nodePos$1 = container$2.getPosition(startNodeId, 'strict');
    this._deleteContainerSelection(tx, sel, {noMerge: true });
    setCursor(tx, container$2.getNodeAt(nodePos$1+1), containerId$2, 'before');
  }
};

Editing.prototype.delete = function delete$1 (tx, direction) {
  var sel = tx.selection;
  
  
  
  
  if (sel.isNodeSelection()) {
    this._deleteNodeSelection(tx, sel, direction);
  }
  
  else if (sel.isCustomSelection()) {}
  
  
  else if (sel.isCollapsed()) {
    
    
    
    var path = sel.start.path;
    var node = tx.get(path[0]);
    var text = tx.get(path);
    var offset = sel.start.offset;
    var needsMerge = (sel.containerId && (
      (offset === 0 && direction === 'left') ||
      (offset === text.length && direction === 'right')
    ));
    if (needsMerge) {
      
      
      
      var root = node.getRoot();
      if (root.isList() && offset === 0 && direction === 'left') {
        return this.toggleList(tx)
      } else {
        var container = tx.get(sel.containerId);
        this._merge(tx, root, sel.start, direction, container);
      }
    } else {
      var startOffset = (direction === 'left') ? offset-1 : offset;
      var endOffset = startOffset+1;
      var start = { path: path, offset: startOffset };
      var end = { path: path, offset: endOffset };
      documentHelpers.deleteTextRange(tx, start, end);
      tx.setSelection({
        type: 'property',
        path: path,
        startOffset: startOffset,
        containerId: sel.containerId
      });
    }
  }
  
  else if (sel.isPropertySelection()) {
    documentHelpers.deleteTextRange(tx, sel.start, sel.end);
    tx.setSelection(sel.collapse('left'));
  }
  
  else if (sel.isContainerSelection()) {
    this._deleteContainerSelection(tx, sel);
  }
  else {
    console.warn('Unsupported case: tx.delete(%)', direction, sel);
  }
};

Editing.prototype._deleteNodeSelection = function _deleteNodeSelection (tx, sel, direction) {
  var nodeId = sel.getNodeId();
  var container = tx.get(sel.containerId);
  var nodePos = container.getPosition(nodeId, 'strict');
  if (sel.isFull() ||
      sel.isBefore() && direction === 'right' ||
      sel.isAfter() && direction === 'left' ) {
    
    var contentPath = container.getContentPath();
    tx.update(contentPath, { type: 'delete', pos: nodePos });
    documentHelpers.deleteNode(tx, tx.get(nodeId));
    var newNode = tx.createDefaultTextNode();
    tx.update(contentPath, { type: 'insert', pos: nodePos, value: newNode.id });
    tx.setSelection({
      type: 'property',
      path: newNode.getTextPath(),
      startOffset: 0,
      containerId: container.id,
    });
  } else {
    
    if (sel.isBefore() && direction === 'left') {
      if (nodePos > 0) {
        var previous = container.getNodeAt(nodePos-1);
        if (previous.isText()) {
          tx.setSelection({
            type: 'property',
            path: previous.getTextPath(),
            startOffset: previous.getLength()
          });
          this.delete(tx, direction);
        } else {
          tx.setSelection({
            type: 'node',
            nodeId: previous.id,
            containerId: container.id
          });
        }
      } else {
        
      }
    } else if (sel.isAfter() && direction === 'right') {
      if (nodePos < container.getLength()-1) {
        var next = container.getNodeAt(nodePos+1);
        if (next.isText()) {
          tx.setSelection({
            type: 'property',
            path: next.getTextPath(),
            startOffset: 0
          });
          this.delete(tx, direction);
        } else {
          tx.setSelection({
            type: 'node',
            nodeId: next.id,
            containerId: container.id
          });
        }
      } else {
        
      }
    } else {
      console.warn('Unsupported case: delete(%s)', direction, sel);
    }
  }
};

Editing.prototype._deletePropertySelection = function _deletePropertySelection (tx, sel) {
  var path = sel.start.path;
  var start = sel.start.offset;
  var end = sel.end.offset;
  tx.update(path, { type: 'delete', start: start, end: end });
  annotationHelpers.deletedText(tx, path, start, end);
};


Editing.prototype._deleteContainerSelection = function _deleteContainerSelection (tx, sel, options) {
    if ( options === void 0 ) options = {};

  var containerId = sel.containerId;
  var container = tx.get(containerId);
  var start = sel.start;
  var end = sel.end;
  var startId = start.getNodeId();
  var endId = end.getNodeId();
  var startPos = container.getPosition(startId, 'strict');
  var endPos = container.getPosition(endId, 'strict');

  
  if (startPos === endPos) {
    
    var node = tx.get(startId).getRoot();
    
    if (node.isText()) {
      documentHelpers.deleteTextRange(tx, start, end);
    } else if (node.isList()) {
      documentHelpers.deleteListRange(tx, node, start, end);
    } else {
      throw new Error('Not supported yet.')
    }
    tx.setSelection(sel.collapse('left'));
    return
  }

  

  var firstNode = tx.get(start.getNodeId());
  var lastNode = tx.get(end.getNodeId());
  var firstEntirelySelected = isEntirelySelected(tx, firstNode, start, null);
  var lastEntirelySelected = isEntirelySelected(tx, lastNode, null, end);

  
  if (lastEntirelySelected) {
    tx.update([container.id, 'nodes'], { type: 'delete', pos: endPos });
    documentHelpers.deleteNode(tx, lastNode);
  } else {
    
    var node$1 = lastNode.getRoot();
    
    if (node$1.isText()) {
      documentHelpers.deleteTextRange(tx, null, end);
    } else if (node$1.isList()) {
      documentHelpers.deleteListRange(tx, node$1, null, end);
    } else {
      
    }
  }

  
  for (var i = endPos-1; i > startPos; i--) {
    var nodeId = container.nodes[i];
    tx.update([container.id, 'nodes'], { type: 'delete', pos: i });
    documentHelpers.deleteNode(tx, tx.get(nodeId));
  }

  
  if (firstEntirelySelected) {
    tx.update([container.id, 'nodes'], { type: 'delete', pos: startPos });
    documentHelpers.deleteNode(tx, firstNode);
  } else {
    
    var node$2 = firstNode.getRoot();
    
    if (node$2.isText()) {
      documentHelpers.deleteTextRange(tx, start, null);
    } else if (node$2.isList()) {
      documentHelpers.deleteListRange(tx, node$2, start, null);
    } else {
      
    }
  }

  
  if (firstEntirelySelected && lastEntirelySelected) {
    
    var textNode = tx.createDefaultTextNode();
    tx.update([container.id, 'nodes'], { type: 'insert', pos: startPos, value: textNode.id });
    tx.setSelection({
      type: 'property',
      path: textNode.getTextPath(),
      startOffset: 0,
      containerId: containerId
    });
  } else if (!firstEntirelySelected && !lastEntirelySelected) {
    if (!options.noMerge) {
      this._merge(tx, firstNode, sel.start, 'right', container);
    }
    tx.setSelection(sel.collapse('left'));
  } else if (firstEntirelySelected) {
    setCursor(tx, lastNode, container.id, 'before');
  } else {
    setCursor(tx, firstNode, container.id, 'after');
  }
};

Editing.prototype.insertInlineNode = function insertInlineNode (tx, nodeData) {
  var sel = tx.selection;
  var text = "\uFEFF";
  this.insertText(tx, text);
  sel = tx.selection;
  var endOffset = tx.selection.end.offset;
  var startOffset = endOffset - text.length;
  nodeData = Object.assign({}, nodeData, {
    start: {
      path: sel.path,
      offset: startOffset
    },
    end: {
      path: sel.path,
      offset: endOffset
    }
  });
  return tx.create(nodeData)
};

Editing.prototype.insertBlockNode = function insertBlockNode (tx, nodeData) {
  var sel = tx.selection;
  
  var blockNode;
  if (!nodeData._isNode || !tx.get(nodeData.id)) {
    blockNode = tx.create(nodeData);
  } else {
    blockNode = tx.get(nodeData.id);
  }
  
  if (sel.isNodeSelection()) {
    var containerId = sel.containerId;
    var container = tx.get(containerId);
    var nodeId = sel.getNodeId();
    var nodePos = container.getPosition(nodeId, 'strict');
    
    if (sel.isBefore()) {
      tx.update(container.getContentPath(), { type: 'insert', pos: nodePos, value: blockNode.id });
    }
    
    else if (sel.isAfter()) {
      tx.update(container.getContentPath(), { type: 'insert', pos: nodePos+1, value: blockNode.id });
      tx.setSelection({
        type: 'node',
        containerId: containerId,
        nodeId: blockNode.id,
        mode: 'after'
      });
    } else {
      tx.update(container.getContentPath(), { type: 'delete', pos: nodePos });
      documentHelpers.deleteNode(tx, tx.get(nodeId));
      tx.update([container.id, 'nodes'], { type: 'insert', pos: nodePos, value: blockNode.id });
      tx.setSelection({
        type: 'node',
        containerId: containerId,
        nodeId: blockNode.id,
        mode: 'after'
      });
    }
  } else if (sel.isPropertySelection()) {
    
    if (!sel.containerId) { throw new Error('insertBlockNode can only be used within a container.') }
    var container$1 = tx.get(sel.containerId);
    if (!sel.isCollapsed()) {
      this._deletePropertySelection(tx, sel);
      tx.setSelection(sel.collapse('left'));
    }
    var node = tx.get(sel.path[0]);
    
    if (!node) { throw new Error('Invalid selection.') }
    var nodePos$1 = container$1.getPosition(node.id, 'strict');
    
    if (node.isText()) {
      var text = node.getText();
      
      if (text.length === 0) {
        tx.update(container$1.getContentPath(), { type: 'delete', pos: nodePos$1 });
        documentHelpers.deleteNode(tx, node);
        tx.update([container$1.id, 'nodes'], { type: 'insert', pos: nodePos$1, value: blockNode.id });
        setCursor(tx, blockNode, container$1.id, 'after');
      }
      
      else if (sel.start.offset === 0) {
        tx.update(container$1.getContentPath(), { type: 'insert', pos: nodePos$1, value: blockNode.id });
      }
      
      else if (sel.start.offset === text.length) {
        tx.update(container$1.getContentPath(), { type: 'insert', pos: nodePos$1+1, value: blockNode.id });
        setCursor(tx, blockNode, container$1.id, 'before');
      }
      
      else {
        this.break(tx);
        tx.update(container$1.getContentPath(), { type: 'insert', pos: nodePos$1+1, value: blockNode.id });
        setCursor(tx, blockNode, container$1.id, 'after');
      }
    } else {
      console.error('Not supported: insertBlockNode() on a custom node');
    }
  } else if (sel.isContainerSelection()) {
    if (sel.isCollapsed()) {
      var start = sel.start;
      
      if (start.isPropertyCoordinate()) {
        tx.setSelection({
          type: 'property',
          path: start.path,
          startOffset: start.offset,
          containerId: sel.containerId,
        });
      } else if (start.isNodeCoordinate()) {
        tx.setSelection({
          type: 'node',
          containerId: sel.containerId,
          nodeId: start.path[0],
          mode: start.offset === 0 ? 'before' : 'after',
        });
      } else {
        throw new Error('Unsupported selection for insertBlockNode')
      }
      return this.insertBlockNode(tx, blockNode)
    } else {
      this.break(tx);
      return this.insertBlockNode(tx, blockNode)
    }
  }
  return blockNode
};

Editing.prototype.insertText = function insertText (tx, text) {
  var sel = tx.selection;
  
  
  
  if (sel.isNodeSelection()) {
    var containerId = sel.containerId;
    var container = tx.get(containerId);
    var nodeId = sel.getNodeId();
    var nodePos = container.getPosition(nodeId, 'strict');
    var textNode = tx.createDefaultTextNode(text);
    if (sel.isBefore()) {
      container.show(textNode, nodePos);
    } else if (sel.isAfter()) {
      container.show(textNode, nodePos+1);
    } else {
      container.hide(nodeId);
      documentHelpers.deleteNode(tx, tx.get(nodeId));
      container.show(textNode, nodePos);
    }
    setCursor(tx, textNode, sel.containerId, 'after');
  } else if (sel.isCustomSelection()) {
    
  } else if (sel.isCollapsed() || sel.isPropertySelection()) {
    
    this._insertText(tx, sel, text);
    
  } else if (sel.isContainerSelection()) {
    this._deleteContainerSelection(tx, sel);
    this.insertText(tx, text);
  }
};

Editing.prototype.paste = function paste$1 (tx, content) {
  if (!content) { return }
  
  if (isString$1(content)) {
    paste(tx, {text: content});
  } else if (content._isDocument) {
    paste(tx, {doc: content});
  } else {
    throw new Error('Illegal content for paste.')
  }
};


Editing.prototype.switchTextType = function switchTextType (tx, data) {
  var sel = tx.selection;
  
  if (!sel.isPropertySelection()) {
    throw new Error("Selection must be a PropertySelection.")
  }
  var containerId = sel.containerId;
  
  if (!containerId) {
    throw new Error("Selection must be within a container.")
  }
  var path = sel.path;
  var nodeId = path[0];
  var node = tx.get(nodeId);
  
  if (!(node.isInstanceOf('text'))) {
    throw new Error('Trying to use switchTextType on a non text node.')
  }
  
  var newNode = Object.assign({
    id: uuid(data.type),
    type: data.type,
    content: node.content,
    direction: node.direction
  }, data);
  var newPath = [newNode.id, 'content'];
  newNode = tx.create(newNode);
  annotationHelpers.transferAnnotations(tx, path, 0, newPath, 0);

  
  var container = tx.get(sel.containerId);
  var pos = container.getPosition(nodeId, 'strict');
  container.hide(nodeId);
  documentHelpers.deleteNode(tx, node);
  container.show(newNode.id, pos);

  tx.setSelection({
    type: 'property',
    path: newPath,
    startOffset: sel.start.offset,
    endOffset: sel.end.offset,
    containerId: containerId
  });

  return newNode
};

Editing.prototype.toggleList = function toggleList (tx, params) {
  var sel = tx.selection;
  var container = tx.get(sel.containerId);
  
  if (!container) {
    throw new Error("Selection must be within a container.")
  }
  if (sel.isPropertySelection()) {
    var nodeId = sel.start.path[0];
    
    var node = tx.get(nodeId).getRoot();
    var nodePos = container.getPosition(node.id, 'strict');
    
    if (node.isText()) {
      tx.update([container.id, 'nodes'], { type: 'delete', pos: nodePos });
      
      var newItem = tx.create({
        type: 'list-item',
        content: node.getText(),
      });
      annotationHelpers.transferAnnotations(tx, node.getTextPath(), 0, newItem.getTextPath(), 0);
      var newList = tx.create(Object.assign({
        type: 'list',
        items: [newItem.id]
      }, params));
      documentHelpers.deleteNode(tx, node);
      tx.update([container.id, 'nodes'], { type: 'insert', pos: nodePos, value: newList.id });
      tx.setSelection({
        type: 'property',
        path: newItem.getTextPath(),
        startOffset: sel.start.offset,
        containerId: sel.containerId
      });
    } else if (node.isList()) {
      var itemId = sel.start.path[0];
      var itemPos = node.getItemPosition(itemId);
      var item = node.getItemAt(itemPos);
      var newTextNode = tx.createDefaultTextNode(item.getText());
      annotationHelpers.transferAnnotations(tx, item.getTextPath(), 0, newTextNode.getTextPath(), 0);
      
      node.removeItemAt(itemPos);
      if (node.isEmpty()) {
        tx.update([container.id, 'nodes'], { type: 'delete', pos: nodePos });
        documentHelpers.deleteNode(tx, node);
        tx.update([container.id, 'nodes'], { type: 'insert', pos: nodePos, value: newTextNode.id });
      } else if (itemPos === 0) {
        tx.update([container.id, 'nodes'], { type: 'insert', pos: nodePos, value: newTextNode.id });
      } else if (node.getLength() <= itemPos){
        tx.update([container.id, 'nodes'], { type: 'insert', pos: nodePos+1, value: newTextNode.id });
      } else {
        
        var tail = [];
        var items = node.items.slice();
        var L = items.length;
        for (var i = L-1; i >= itemPos; i--) {
          tail.unshift(items[i]);
          node.removeItemAt(i);
        }
        var newList$1 = tx.create({
          type: 'list',
          items: tail,
          ordered: node.ordered
        });
        tx.update([container.id, 'nodes'], { type: 'insert', pos: nodePos+1, value: newTextNode.id });
        tx.update([container.id, 'nodes'], { type: 'insert', pos: nodePos+2, value: newList$1.id });
      }
      tx.setSelection({
        type: 'property',
        path: newTextNode.getTextPath(),
        startOffset: sel.start.offset,
        containerId: sel.containerId
      });
    } else {
      
    }
  } else if (sel.isContainerSelection()) {
    console.error('TODO: support toggleList with ContainerSelection');
  }
};

Editing.prototype.indent = function indent (tx) {
  var sel = tx.selection;
  if (sel.isPropertySelection()) {
    var nodeId = sel.start.getNodeId();
    
    var node = tx.get(nodeId).getRoot();
    if (node.isList()) {
      var itemId = sel.start.path[0];
      var item = tx.get(itemId);
      
      if (item && item.level<3) {
        tx.set([itemId, 'level'], item.level+1);
      }
    }
  } else if (sel.isContainerSelection()) {
    console.error('TODO: support toggleList with ContainerSelection');
  }
};

Editing.prototype.dedent = function dedent (tx) {
  var sel = tx.selection;
  if (sel.isPropertySelection()) {
    var nodeId = sel.start.getNodeId();
    
    var node = tx.get(nodeId).getRoot();
    if (node.isList()) {
      var itemId = sel.start.path[0];
      var item = tx.get(itemId);
      if (item && item.level>1) {
        tx.set([itemId, 'level'], item.level-1);
      }
    }
  } else if (sel.isContainerSelection()) {
    console.error('TODO: support toggleList with ContainerSelection');
  }
};


Editing.prototype._insertText = function _insertText (tx, sel, text) {
  var start = sel.start;
  var end = sel.end;
  
  if (!isArrayEqual(start.path, end.path)) {
    throw new Error('Unsupported state: range should be on one property')
  }
  var path = start.path;
  var startOffset = start.offset;
  var endOffset = end.offset;
  var typeover = !sel.isCollapsed();
  var L = text.length;
  
  if (typeover) {
    tx.update(path, { type: 'delete', start: startOffset, end: endOffset });
  }
  
  tx.update(path, { type: 'insert', start: startOffset, text: text });
  
  var annos = tx.getAnnotations(path);
  annos.forEach(function(anno) {
    var annoStart = anno.start.offset;
    var annoEnd = anno.end.offset;

    
    
    if (annoEnd<startOffset) {
      return
    }
    
    else if (annoStart>=endOffset) {
      tx.update([anno.id, 'start'], { type: 'shift', value: startOffset-endOffset+L });
      tx.update([anno.id, 'end'], { type: 'shift', value: startOffset-endOffset+L });
    }
    
    
    
    
    else if (
      (annoStart>=startOffset && annoEnd<endOffset) ||
      (anno._isInlineNode && annoStart>=startOffset && annoEnd<=endOffset)
    ) {
      tx.delete(anno.id);
    }
    
    else if (annoStart>=startOffset && annoEnd>=endOffset) {
      
      if (annoStart>startOffset || !typeover) {
        tx.update([anno.id, 'start'], { type: 'shift', value: startOffset-annoStart+L });
      }
      tx.update([anno.id, 'end'], { type: 'shift', value: startOffset-endOffset+L });
    }
    
    else if (annoStart<startOffset && annoEnd<endOffset) {
      
      tx.update([anno.id, 'end'], { type: 'shift', value: startOffset-annoEnd+L });
    }
    
    else if (annoEnd === startOffset && !anno.constructor.autoExpandRight) {
        
    }
    
    else if (annoStart<startOffset && annoEnd>=endOffset) {
      if (anno._isInlineNode) {
        
      } else {
        tx.update([anno.id, 'end'], { type: 'shift', value: startOffset-endOffset+L });
      }
    }
    else {
      console.warn('TODO: handle annotation update case.');
    }
  });
  var offset = startOffset + text.length;
  tx.setSelection({
    type: 'property',
    path: start.path,
    startOffset: offset,
    containerId: sel.containerId,
    surfaceId: sel.surfaceId
  });
};

Editing.prototype._breakNode = function _breakNode (tx, node, coor, container) {
  
  node = node.getRoot();
  
  if (node.isText()) {
    this._breakTextNode(tx, node, coor, container);
  } else if (node.isList()) {
    this._breakListNode(tx, node, coor, container);
  } else {
    throw new Error('Not supported')
  }
};

Editing.prototype._breakTextNode = function _breakTextNode (tx, node, coor, container) {
  var path = coor.path;
  var offset = coor.offset;
  var nodePos = container.getPosition(node.id, 'strict');
  var text = node.getText();

  
  
  if (offset === 0) {
    var newNode = tx.create({
      type: node.type,
      content: ""
    });
    
    container.show(newNode.id, nodePos);
    tx.setSelection({
      type: 'property',
      path: path,
      startOffset: 0,
      containerId: container.id
    });
  }
  
  else {
    var newNode$1 = node.toJSON();
    delete newNode$1.id;
    newNode$1.content = text.substring(offset);
    
    if (offset === text.length) {
      newNode$1.type = tx.getSchema().getDefaultTextType();
    }
    newNode$1 = tx.create(newNode$1);
    
    if (offset < text.length) {
      
      annotationHelpers.transferAnnotations(tx, path, offset, newNode$1.getTextPath(), 0);
      
      tx.update(path, { type: 'delete', start: offset, end: text.length });
    }
    
    container.show(newNode$1.id, nodePos+1);
    
    tx.setSelection({
      type: 'property',
      path: newNode$1.getTextPath(),
      startOffset: 0,
      containerId: container.id
    });
  }
};

Editing.prototype._breakListNode = function _breakListNode (tx, node, coor, container) {
  var path = coor.path;
  var offset = coor.offset;
  var listItem = tx.get(path[0]);

  var L = node.length;
  var itemPos = node.getItemPosition(listItem.id);
  var text = listItem.getText();
  var newItem = listItem.toJSON();
  delete newItem.id;
  if (offset === 0) {
    
    if (!text) {
      
      
      var nodePos = container.getPosition(node.id, 'strict');
      var newTextNode = tx.createDefaultTextNode();
      
      if (L < 2) {
        container.hide(node.id);
        documentHelpers.deleteNode(tx, node);
        container.show(newTextNode.id, nodePos);
      }
      
      else if (itemPos === 0) {
        node.remove(listItem.id);
        documentHelpers.deleteNode(tx, listItem);
        container.show(newTextNode.id, nodePos);
      }
      
      else if (itemPos >= L-1) {
        node.remove(listItem.id);
        documentHelpers.deleteNode(tx, listItem);
        container.show(newTextNode.id, nodePos+1);
      }
      
      else {
        var tail = [];
        var items = node.items.slice();
        for (var i = L-1; i > itemPos; i--) {
          tail.unshift(items[i]);
          node.remove(items[i]);
        }
        node.remove(items[itemPos]);
        var newList = tx.create({
          type: 'list',
          items: tail,
          ordered: node.ordered
        });
        container.show(newTextNode.id, nodePos+1);
        container.show(newList.id, nodePos+2);
      }
      tx.setSelection({
        type: 'property',
        path: newTextNode.getTextPath(),
        startOffset: 0
      });
    }
    
    else {
      newItem.content = "";
      newItem = tx.create(newItem);
      node.insertItemAt(itemPos, newItem.id);
      tx.setSelection({
        type: 'property',
        path: listItem.getTextPath(),
        startOffset: 0
      });
    }
  }
  
  else {
    newItem.content = text.substring(offset);
    newItem = tx.create(newItem);
    
    if (offset < text.length) {
      
      annotationHelpers.transferAnnotations(tx, path, offset, [newItem.id,'content'], 0);
      
      tx.update(path, { type: 'delete', start: offset, end: text.length });
    }
    node.insertItemAt(itemPos+1, newItem.id);
    tx.setSelection({
      type: 'property',
      path: newItem.getTextPath(),
      startOffset: 0
    });
  }
};

Editing.prototype._merge = function _merge (tx, node, coor, direction, container) {
  
  
  if (node.isList()) {
    var list = node;
    var itemId = coor.path[0];
    var itemPos = list.getItemPosition(itemId);
    var withinListNode = (
      (direction === 'left' && itemPos > 0) ||
      (direction === 'right' && itemPos<list.items.length-1)
    );
    if (withinListNode) {
      itemPos = (direction === 'left') ? itemPos-1 : itemPos;
      var target = list.getItemAt(itemPos);
      var targetLength = target.getLength();
      documentHelpers.mergeListItems(tx, list.id, itemPos);
      tx.setSelection({
        type: 'property',
        path: target.getTextPath(),
        startOffset: targetLength,
        containerId: container.id
      });
      return
    }
  }
  
  var nodePos = container.getPosition(node, 'strict');
  if (direction === 'left' && nodePos > 0) {
    this._mergeNodes(tx, container, nodePos-1, direction);
  } else if (direction === 'right' && nodePos<container.getLength()-1) {
    this._mergeNodes(tx, container, nodePos, direction);
  }
};

Editing.prototype._mergeNodes = function _mergeNodes (tx, container, pos, direction) {
  var first = container.getChildAt(pos);
  var second = container.getChildAt(pos+1);
  if (first.isText()) {
    
    if (first.isEmpty()) {
      container.hide(first.id);
      documentHelpers.deleteNode(tx, first);
      
      
      setCursor(tx, second, container.id, 'before');
      return
    }
    var target = first;
    var targetPath = target.getTextPath();
    var targetLength = target.getLength();
    if (second.isText()) {
      var source = second;
      var sourcePath = source.getTextPath();
      container.hide(source.id);
      
      tx.update(targetPath, { type: 'insert', start: targetLength, text: source.getText() });
      
      annotationHelpers.transferAnnotations(tx, sourcePath, 0, targetPath, targetLength);
      documentHelpers.deleteNode(tx, source);
      tx.setSelection({
        type: 'property',
        path: targetPath,
        startOffset: targetLength,
        containerId: container.id
      });
    } else if (second.isList()) {
      var list = second;
      if (!second.isEmpty()) {
        var source$1 = list.getFirstItem();
        var sourcePath$1 = source$1.getTextPath();
        
        list.removeItemAt(0);
        
        tx.update(targetPath, { type: 'insert', start: targetLength, text: source$1.getText() });
        
        annotationHelpers.transferAnnotations(tx, sourcePath$1, 0, targetPath, targetLength);
        
        documentHelpers.deleteNode(tx, source$1);
      }
      if (list.isEmpty()) {
        container.hide(list.id);
        documentHelpers.deleteNode(tx, list);
      }
      tx.setSelection({
        type: 'property',
        path: targetPath,
        startOffset: targetLength,
        containerId: container.id
      });
    } else {
      selectNode(tx, direction === 'left' ? first.id : second.id, container.id);
    }
  } else if (first.isList()) {
    if (second.isText()) {
      var source$2 = second;
      var sourcePath$2 = source$2.getTextPath();
      var target$1 = first.getLastItem();
      var targetPath$1 = target$1.getTextPath();
      var targetLength$1 = target$1.getLength();
      
      container.hide(source$2.id);
      
      tx.update(targetPath$1, { type: 'insert', start: targetLength$1, text: source$2.getText() });
      
      annotationHelpers.transferAnnotations(tx, sourcePath$2, 0, targetPath$1, targetLength$1);
      documentHelpers.deleteNode(tx, source$2);
      tx.setSelection({
        type: 'property',
        path: target$1.getTextPath(),
        startOffset: targetLength$1,
        containerId: container.id
      });
    } else if (second.isList()) {
      
      if (direction !== 'right') {
        
        
        throw new Error('Illegal state')
      }
      container.hide(second.id);
      var firstItems = first.items.slice();
      var secondItems = second.items.slice();
      for (var i=0; i<secondItems.length;i++) {
        second.removeItemAt(0);
        first.appendItem(secondItems[i]);
      }
      documentHelpers.deleteNode(tx, second);
      var item = tx.get(last$1(firstItems));
      tx.setSelection({
        type: 'property',
        path: item.getTextPath(),
        startOffset: item.getLength(),
        containerId: container.id
      });
    } else {
      selectNode(tx, direction === 'left' ? first.id : second.id, container.id);
    }
  } else {
    if (second.isText() && second.isEmpty()) {
      container.hide(second.id);
      documentHelpers.deleteNode(tx, second);
      setCursor(tx, first, container.id, 'after');
    } else {
      selectNode(tx, direction === 'left' ? first.id : second.id, container.id);
    }
  }
};

var EditingInterface = function EditingInterface(doc) {
  this._document = doc;
  this._selection = null;
  
  this._impl = new Editing();
  this._direction = null;
};

var prototypeAccessors$4 = { selection: {},textDirection: {} };

EditingInterface.prototype.getDocument = function getDocument () {
  return this._document
};



EditingInterface.prototype.get = function get () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

  return (ref = this._document).get.apply(ref, args)
    var ref;
};

EditingInterface.prototype.contains = function contains (id) {
  return this._document.contains(id)
};

EditingInterface.prototype.create = function create (nodeData) {
  return this._document.create(nodeData)
};

EditingInterface.prototype.createDefaultTextNode = function createDefaultTextNode (content) {
  return this._document.createDefaultTextNode(content, this._direction)
};

EditingInterface.prototype.delete = function delete$1 (nodeId) {
  return this._document.delete(nodeId)
};

EditingInterface.prototype.set = function set (path, value) {
  return this._document.set(path, value)
};

EditingInterface.prototype.update = function update (path, diffOp) {
  return this._document.update(path, diffOp)
};



EditingInterface.prototype.createSelection = function createSelection (selData) {
  
  
  
  
  var oldSel = this._selection;
  if (selData && oldSel) {
    if (!selData.containerId && oldSel.containerId) {
      selData.containerId = oldSel.containerId;
    }
    if (!selData.surfaceId && oldSel.surfaceId) {
      selData.surfaceId = oldSel.surfaceId;
    }
  }
  return this._document.createSelection(selData)
};

EditingInterface.prototype.setSelection = function setSelection (sel) {
  if (!sel) { sel = Selection.nullSelection; }
  else if (isPlainObject$1(sel)) {
    sel = this.createSelection(sel);
  }
  var oldSel = this._selection;
  if (oldSel && sel && !sel.isNull()) {
    if (!sel.containerId) {
      sel.containerId = oldSel.containerId;
    }
  }
  this._selection = sel;
  return sel
};

EditingInterface.prototype.getSelection = function getSelection () {
  return this._selection
};

prototypeAccessors$4.selection.get = function () {
  return this._selection
};

prototypeAccessors$4.selection.set = function (sel) {
  this.setSelection(sel);
};


prototypeAccessors$4.textDirection.get = function () {
  return this._direction
};

prototypeAccessors$4.textDirection.set = function (dir) {
  this._direction = dir;
};



EditingInterface.prototype.annotate = function annotate (annotationData) {
  var sel = this._selection;
  if (sel && (sel.isPropertySelection() || sel.isContainerSelection())) {
    return this._impl.annotate(this, annotationData)
  }
};

EditingInterface.prototype.break = function break$1 () {
  if (this._selection && !this._selection.isNull()) {
    this._impl.break(this);
  }
};

EditingInterface.prototype.copySelection = function copySelection$1 () {
  var sel = this._selection;
  if (sel && !sel.isNull() && !sel.isCollapsed()) {
    return copySelection(this.getDocument(), this._selection)
  }
};

EditingInterface.prototype.deleteSelection = function deleteSelection (options) {
  var sel = this._selection;
  if (sel && !sel.isNull() && !sel.isCollapsed()) {
    this._impl.delete(this, 'right', options);
  }
};

EditingInterface.prototype.deleteCharacter = function deleteCharacter (direction) {
  var sel = this._selection;
  if (!sel || sel.isNull()) {
    
  } else if (!sel.isCollapsed()) {
    this.deleteSelection();
  } else {
    this._impl.delete(this, direction);
  }
};

EditingInterface.prototype.insertText = function insertText (text) {
  var sel = this._selection;
  if (sel && !sel.isNull()) {
    this._impl.insertText(this, text);
  }
};


EditingInterface.prototype.insertInlineNode = function insertInlineNode (inlineNode) {
  var sel = this._selection;
  if (sel && !sel.isNull() && sel.isPropertySelection()) {
    return this._impl.insertInlineNode(this, inlineNode)
  }
};

EditingInterface.prototype.insertBlockNode = function insertBlockNode (blockNode) {
  var sel = this._selection;
  if (sel && !sel.isNull()) {
    return this._impl.insertBlockNode(this, blockNode)
  }
};

EditingInterface.prototype.paste = function paste (content) {
  var sel = this._selection;
  if (sel && !sel.isNull()) {
    return this._impl.paste(this, content)
  }
};

EditingInterface.prototype.switchTextType = function switchTextType (nodeData) {
  var sel = this._selection;
  if (sel && !sel.isNull()) {
    return this._impl.switchTextType(this, nodeData)
  }
};

EditingInterface.prototype.toggleList = function toggleList (params) {
  var sel = this._selection;
  if (sel && !sel.isNull()) {
    return this._impl.toggleList(this, params)
  }
};

EditingInterface.prototype.indent = function indent () {
  var sel = this._selection;
  if (sel && !sel.isNull()) {
    return this._impl.indent(this)
  }
};

EditingInterface.prototype.dedent = function dedent () {
  var sel = this._selection;
  if (sel && !sel.isNull()) {
    return this._impl.dedent(this)
  }
};



EditingInterface.prototype.getIndex = function getIndex () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

  return (ref = this._document).getIndex.apply(ref, args)
    var ref;
};

EditingInterface.prototype.getAnnotations = function getAnnotations () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

  return (ref = this._document).getAnnotations.apply(ref, args)
    var ref;
};

EditingInterface.prototype.getSchema = function getSchema () {
  return this._document.getSchema()
};

EditingInterface.prototype.createSnippet = function createSnippet () {
  return this._document.createSnippet()
};

Object.defineProperties( EditingInterface.prototype, prototypeAccessors$4 );

var ChangeRecorder = (function (EditingInterface$$1) {
  function ChangeRecorder(doc) {
    EditingInterface$$1.call(this, new TransactionDocument(doc));
  }

  if ( EditingInterface$$1 ) ChangeRecorder.__proto__ = EditingInterface$$1;
  ChangeRecorder.prototype = Object.create( EditingInterface$$1 && EditingInterface$$1.prototype );
  ChangeRecorder.prototype.constructor = ChangeRecorder;

  ChangeRecorder.prototype.generateChange = function generateChange () {
    var ops = this._document.ops.slice();
    this._document.ops.length = 0;
    var change = new DocumentChange(ops, {}, {});
    change._extractInformation(this._document);
    return change
  };

  return ChangeRecorder;
}(EditingInterface));

var documentHelpers = {
  getPropertyAnnotationsForSelection: getPropertyAnnotationsForSelection,
  getContainerAnnotationsForSelection: getContainerAnnotationsForSelection,
  getTextForSelection: getTextForSelection,
  getMarkersForSelection: getMarkersForSelection,
  getChangeFromDocument: getChangeFromDocument,
  copyNode: copyNode,
  deleteNode: deleteNode,
  deleteTextRange: deleteTextRange,
  deleteListRange: deleteListRange,
  mergeListItems: mergeListItems,
  isContainerAnnotation: isContainerAnnotation
};


function getPropertyAnnotationsForSelection(doc, sel, options) {
  options = options || {};
  if (!sel.isPropertySelection()) {
    return []
  }
  var path = sel.getPath();
  var annotations = doc.getIndex('annotations').get(path, sel.start.offset, sel.end.offset);
  if (options.type) {
    annotations = filter(annotations, DocumentIndex.filterByType(options.type));
  }
  return annotations
}


function getContainerAnnotationsForSelection(doc, sel, containerId, options) {
  
  
  
  
  
  if (!containerId) {
    throw new Error("'containerId' is required.")
  }
  options = options || {};
  var index = doc.getIndex('container-annotations');
  var annotations = index.get(containerId, options.type);
  annotations = filter(annotations, function(anno) {
    return sel.overlaps(anno.getSelection())
  });
  return annotations
}


function isContainerAnnotation(doc, type) {
  var schema = doc.getSchema();
  return schema.isInstanceOf(type, 'container-annotation')
}


function getTextForSelection(doc, sel) {
  if (!sel || sel.isNull()) {
    return ""
  } else if (sel.isPropertySelection()) {
    var text = doc.get(sel.start.path);
    return text.substring(sel.start.offset, sel.end.offset)
  } else if (sel.isContainerSelection()) {
    var result = [];
    var nodeIds = sel.getNodeIds();
    var L = nodeIds.length;
    for (var i = 0; i < L; i++) {
      var id = nodeIds[i];
      var node = doc.get(id);
      if (node.isText()) {
        var text$1 = node.getText();
        if (i === L-1) {
          text$1 = text$1.slice(0, sel.end.offset);
        }
        if (i === 0) {
          text$1 = text$1.slice(sel.start.offset);
        }
        result.push(text$1);
      }
    }
    return result.join('\n')
  }
}

function getMarkersForSelection(doc, sel) {
  
  if (!sel || !sel.isPropertySelection()) { return [] }
  var path = sel.getPath();
  
  var markers = doc.getIndex('markers').get(path);
  var filtered = filter(markers, function(m) {
    return m.containsSelection(sel)
  });
  return filtered
}

function getChangeFromDocument(doc) {
  var recorder = new ChangeRecorder(doc);
  return recorder.generateChange()
}


function deleteNode(doc, node) {
  
  if (!node) {
    console.warn('Invalid arguments');
    return
  }
  
  if (node.isText()) {
    
    var annos = doc.getIndex('annotations').get(node.id);
    for (var i = 0; i < annos.length; i++) {
      doc.delete(annos[i].id);
    }
  }
  
  
  
  var nodeSchema = node.getSchema();
  forEach(nodeSchema, function (prop) {
    if ((prop.isReference() && prop.isOwned()) || (prop.type === 'file')) {
      if (prop.isArray()) {
        var ids = node[prop.name];
        ids.forEach(function (id) {
          deleteNode(doc, doc.get(id));
        });
      } else {
        deleteNode(doc, doc.get(node[prop.name]));
      }
    }
  });
  doc.delete(node.id);
}


function copyNode(node) {
  var nodes = [];
  
  var nodeSchema = node.getSchema();
  var doc = node.getDocument();
  forEach(nodeSchema, function (prop) {
    
    
    if ((prop.isReference() && prop.isOwned()) || (prop.type === 'file')) {
      var val = node[prop.name];
      nodes.push(_copyChildren(val));
    }
  });
  nodes.push(node.toJSON());
  var annotationIndex = node.getDocument().getIndex('annotations');
  var annotations = annotationIndex.get([node.id]);
  forEach(annotations, function(anno) {
    nodes.push(anno.toJSON());
  });
  var result = flatten(nodes).filter(Boolean);
  
  return result

  function _copyChildren(val) {
    if (!val) { return null }
    if (isArray$1(val)) {
      return flatten(val.map(_copyChildren))
    } else {
      var id = val;
      if (!id) { return null }
      var child = doc.get(id);
      if (!child) { return }
      return copyNode(child)
    }
  }
}


function deleteTextRange(doc, start, end) {
  if (!start) {
    start = {
      path: end.path,
      offset: 0
    };
  }
  var path = start.path;
  var text = doc.get(path);
  if (!end) {
    end = {
      path: start.path,
      offset: text.length
    };
  }
  
  if (!isArrayEqual(start.path, end.path)) {
    throw new Error('start and end must be on one property')
  }
  var startOffset = start.offset;
  var endOffset = end.offset;
  doc.update(path, { type: 'delete', start: startOffset, end: endOffset });
  
  var annos = doc.getAnnotations(path);
  annos.forEach(function(anno) {
    var annoStart = anno.start.offset;
    var annoEnd = anno.end.offset;
    
    if (annoEnd<=startOffset) {
      return
    }
    
    else if (annoStart>=endOffset) {
      doc.update([anno.id, 'start'], { type: 'shift', value: startOffset-endOffset });
      doc.update([anno.id, 'end'], { type: 'shift', value: startOffset-endOffset });
    }
    
    else if (annoStart>=startOffset && annoEnd<=endOffset) {
      doc.delete(anno.id);
    }
    
    else if (annoStart>=startOffset && annoEnd>=endOffset) {
      if (annoStart>startOffset) {
        doc.update([anno.id, 'start'], { type: 'shift', value: startOffset-annoStart });
      }
      doc.update([anno.id, 'end'], { type: 'shift', value: startOffset-endOffset });
    }
    
    else if (annoStart<=startOffset && annoEnd<=endOffset) {
      doc.update([anno.id, 'end'], { type: 'shift', value: startOffset-annoEnd });
    }
    
    else if (annoStart<startOffset && annoEnd >= endOffset) {
      doc.update([anno.id, 'end'], { type: 'shift', value: startOffset-endOffset });
    }
    else {
      console.warn('TODO: handle annotation update case.');
    }
  });
}

function deleteListRange(doc, list, start, end) {
  if (doc !== list.getDocument()) {
    list = doc.get(list.id);
  }
  if (!start) {
    start = {
      path: list.getItemAt(0).getTextPath(),
      offset: 0
    };
  }
  if (!end) {
    var item = list.getLastItem();
    end = {
      path: item.getTextPath(),
      offset: item.getLength()
    };
  }
  var startId = start.path[0];
  var startPos = list.getItemPosition(startId);
  var endId = end.path[0];
  var endPos = list.getItemPosition(endId);
  
  if (startPos === endPos) {
    deleteTextRange(doc, start, end);
    return
  }
  
  if (startPos > endPos) {
    var assign;
    (assign = [end, start], start = assign[0], end = assign[1]);
    var assign$1;
    (assign$1 = [endPos, startPos], startPos = assign$1[0], endPos = assign$1[1]);
    var assign$2;
    (assign$2 = [endId, startId], startId = assign$2[0], endId = assign$2[1]);
  }
  var firstItem = doc.get(startId);
  var lastItem = doc.get(endId);
  var firstEntirelySelected = isEntirelySelected(doc, firstItem, start, null);
  var lastEntirelySelected = isEntirelySelected(doc, lastItem, null, end);

  
  if (lastEntirelySelected) {
    list.removeItemAt(endPos);
    deleteNode(doc, lastItem);
  } else {
    deleteTextRange(doc, null, end);
  }

  
  for (var i = endPos-1; i > startPos; i--) {
    var itemId = list.items[i];
    list.removeItemAt(i);
    deleteNode(doc, doc.get(itemId));
  }

  
  if (firstEntirelySelected) {
    list.removeItemAt(startPos);
    deleteNode(doc, firstItem);
  } else {
    deleteTextRange(doc, start, null);
  }

  if (!firstEntirelySelected && !lastEntirelySelected) {
    mergeListItems(doc, list.id, startPos);
  }
}

function mergeListItems(doc, listId, itemPos) {
  
  var list = doc.get(listId);
  var target = list.getItemAt(itemPos);
  var targetPath = target.getTextPath();
  var targetLength = target.getLength();
  var source = list.getItemAt(itemPos+1);
  var sourcePath = source.getTextPath();
  
  list.removeItemAt(itemPos+1);
  
  doc.update(targetPath, { type: 'insert', start: targetLength, text: source.getText() });
  
  annotationHelpers.transferAnnotations(doc, sourcePath, 0, targetPath, targetLength);
  doc.delete(source.id);
}

var Annotation = (function (DocumentNode$$1) {
  function Annotation(doc, props) {
    DocumentNode$$1.call(this, doc, _normalizedProps(props));

    
    this.start = new Coordinate(this.start);
    this.end = new Coordinate(this.end);
  }

  if ( DocumentNode$$1 ) Annotation.__proto__ = DocumentNode$$1;
  Annotation.prototype = Object.create( DocumentNode$$1 && DocumentNode$$1.prototype );
  Annotation.prototype.constructor = Annotation;

  var prototypeAccessors = { startPath: {},startOffset: {},endPath: {},endOffset: {} };

  

  prototypeAccessors.startPath.get = function () {
    console.warn('DEPRECATED: use Annotation.start.path instead.');
    return this.start.path
  };

  prototypeAccessors.startPath.set = function (path) {
    console.warn('DEPRECATED: use Annotation.start.path instead.');
    this.start.path = path;
  };

  prototypeAccessors.startOffset.get = function () {
    console.warn('DEPRECATED: use Annotation.start.offset instead.');
    return this.start.offset
  };

  prototypeAccessors.startOffset.set = function (offset) {
    console.warn('DEPRECATED: use Annotation.start.offset instead.');
    this.start.offset = offset;
  };

  prototypeAccessors.endPath.get = function () {
    console.warn('DEPRECATED: use Annotation.end.path instead.');
    return this.end.path
  };

  prototypeAccessors.endPath.set = function (path) {
    console.warn('DEPRECATED: use Annotation.end.path instead.');
    this.end.path = path;
  };

  prototypeAccessors.endOffset.get = function () {
    console.warn('DEPRECATED: use Annotation.end.offset instead.');
    return this.end.offset
  };

  prototypeAccessors.endOffset.set = function (offset) {
    console.warn('DEPRECATED: use Annotation.end.offset instead.');
    this.end.offset = offset;
  };

  

  
  Annotation.prototype.getText = function getText () {
    var doc = this.getDocument();
    if (!doc) {
      console.warn('Trying to use a Annotation which is not attached to the document.');
      return ""
    }
    return documentHelpers.getTextForSelection(doc, this.getSelection())
  };

  
  Annotation.prototype.canSplit = function canSplit () {
    return true
  };

  
  Annotation.prototype.isAnchor = function isAnchor () {
    return false
  };

  Object.defineProperties( Annotation.prototype, prototypeAccessors );

  return Annotation;
}(DocumentNode));

Annotation.define({
  type: "annotation",
  start: "coordinate",
  end: "coordinate"
});

Annotation.prototype._isAnnotation = true;

function _normalizedProps(props) {
  if (!props.hasOwnProperty('start')) {
    
    
    props = Object.assign({}, props);
    props.start = {
      path: props.startPath || props.path,
      offset: props.startOffset
    };
    props.end = {};
    if (props.hasOwnProperty('endPath')) {
      props.end.path = props.endPath;
    } else {
      props.end.path = props.start.path;
    }
    if (props.hasOwnProperty('endOffset')) {
      props.end.offset = props.endOffset;
    } else {
      props.end.offset = props.start.offset;
    }
    delete props.path;
    delete props.startPath;
    delete props.endPath;
    delete props.startOffset;
    delete props.endOffset;
  } else if (props.hasOwnProperty('end') && !props.end.path) {
    props.end.path = props.start.path;
  }
  return props
}

var BlockNode = (function (DocumentNode$$1) {
	function BlockNode () {
		DocumentNode$$1.apply(this, arguments);
	}if ( DocumentNode$$1 ) BlockNode.__proto__ = DocumentNode$$1;
	BlockNode.prototype = Object.create( DocumentNode$$1 && DocumentNode$$1.prototype );
	BlockNode.prototype.constructor = BlockNode;

	

	return BlockNode;
}(DocumentNode));

BlockNode.isBlock = true;

var ChangeHistory = function ChangeHistory() {
  
  this.doneChanges = [];
  
  this.undoneChanges = [];
  
  this.lastChange = null;
};

ChangeHistory.prototype.canUndo = function canUndo () {
  return this.doneChanges.length > 0
};

ChangeHistory.prototype.canRedo = function canRedo () {
  return this.undoneChanges.length > 0
};

ChangeHistory.prototype.push = function push (change) {
  this.doneChanges.push(change);
  this.undoneChanges = [];
};

var ContainerAddress = function ContainerAddress(pos, offset) {
  this.pos = pos;
  this.offset = offset;
};

ContainerAddress.prototype.isBefore = function isBefore (other, strict) {
  strict = Boolean(strict);
  if (this.pos < other.pos) {
    return true
  } else if (this.pos > other.pos) {
    return false
  } else if (this.offset < other.offset) {
    return true
  } else if (this.offset > other.offset) {
    return false
  }
  if (strict) {
    return false
  } else {
    return true
  }
};

ContainerAddress.prototype.isAfter = function isAfter (other, strict) {
  return other.isBefore(this, strict)
};

ContainerAddress.prototype.isEqual = function isEqual (other) {
  return (this.pos === other.pos && this.offset === other.offset)
};

ContainerAddress.prototype.toString = function toString () {
  return [this.pos,'.',this.offset].join('')
};

var Container = (function (DocumentNode$$1) {
  function Container() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    DocumentNode$$1.apply(this, args);

    
    
    
    this._enableCaching();
  }

  if ( DocumentNode$$1 ) Container.__proto__ = DocumentNode$$1;
  Container.prototype = Object.create( DocumentNode$$1 && DocumentNode$$1.prototype );
  Container.prototype.constructor = Container;

  var prototypeAccessors = { length: {} };

  Container.prototype.dispose = function dispose () {
    this.document.off(this);
  };

  Container.prototype.getContentPath = function getContentPath () {
    return [this.id, 'nodes']
  };

  Container.prototype.getContent = function getContent () {
    return this.nodes
  };

  Container.prototype.contains = function contains (nodeId) {
    return this.getPosition(nodeId) >= 0
  };

  Container.prototype.getPosition = function getPosition (node, strict) {
    if (isString$1(node)) {
      node = this.document.get(node);
    }
    if (!node) { return -1 }
    var pos = this._getPosition(node);
    if (strict && pos < 0) {
      throw new Error('Node is not within this container: ' + node.id)
    }
    return pos
  };

  Container.prototype.getNodeAt = function getNodeAt (idx) {
    var content = this.getContent();
    if (idx < 0 || idx >= content.length) {
      throw new Error('Array index out of bounds: ' + idx + ", " + content.length)
    }
    return this.getDocument().get(content[idx])
  };

  Container.prototype.getNodes = function getNodes () {
    var doc = this.getDocument();
    return this.getContent().map(function (id) { return doc.get(id); }).filter(Boolean)
  };

  Container.prototype.show = function show (nodeId, pos) {
    var doc = this.getDocument();
    var arg1 = arguments[0];
    if (!isString$1(arg1)) {
      if (arg1._isNode) {
        nodeId = arg1.id;
      }
    }
    if (!isNumber(pos)) {
      pos = this.getLength();
    }
    doc.update(this.getContentPath(), { type: 'insert', pos: pos, value: nodeId });
  };

  Container.prototype.hide = function hide (nodeId) {
    var doc = this.getDocument();
    var pos = this.getPosition(nodeId);
    if (pos >= 0) {
      doc.update(this.getContentPath(), { type: 'delete', pos: pos });
    }
  };

  Container.prototype.getAddress = function getAddress (coor) {
    if (!coor._isCoordinate) {
      
      throw new Error('Illegal argument: Container.getAddress(coor) expects a Coordinate instance.')
    }
    var nodeId = coor.path[0];
    var nodePos = this.getPosition(nodeId);
    var offset;
    if (coor.isNodeCoordinate()) {
      if (coor.offset > 0) {
        offset = Number.MAX_VALUE;
      } else {
        offset = 0;
      }
    } else {
      offset = coor.offset;
    }
    return new ContainerAddress(nodePos, offset)
  };

  Container.prototype.getLength = function getLength () {
    return this.getContent().length
  };

  prototypeAccessors.length.get = function () {
    return this.getLength()
  };

  Container.prototype._getPosition = function _getPosition (node) {
    if (this._isCaching) {
      return this._getCachedPosition(node)
    } else {
      return this._lookupPosition(node)
    }
  };

  Container.prototype._getCachedPosition = function _getCachedPosition (node) {
    var cache = this._cachedPositions || this._fillCache();
    var nodeId = node.id;
    var pos = -1;
    if (cache.hasOwnProperty(nodeId)) {
      pos = cache[nodeId];
    } else {
      pos = this._lookupPosition(node);
      cache[nodeId] = pos;
    }
    return pos
  };

  Container.prototype._fillCache = function _fillCache () {
    var positions = {};
    this.nodes.forEach(function (id, pos) {
      positions[id] = pos;
    });
    this._cachedPositions = positions;
    return positions
  };

  Container.prototype._invalidateCache = function _invalidateCache () {
    this._cachedPositions = null;
  };

  Container.prototype._lookupPosition = function _lookupPosition (node) {
    if (node.hasParent()) {
      node = node.getRoot();
    }
    return this.getContent().indexOf(node.id)
  };

  Container.prototype._enableCaching = function _enableCaching () {
    
    
    if (this.document) {
      this.document.data.on('operation:applied', this._onOperationApplied, this);
      this._isCaching = true;
    }
  };

  Container.prototype._onOperationApplied = function _onOperationApplied (op) {
    if (op.type === 'set' || op.type === 'update') {
      if (op.path[0] === this.id) {
        this._invalidateCache();
      }
    }
  };

  Container.prototype._onDocumentChange = function _onDocumentChange (change) {
    if (change.hasUpdated(this.getContentPath())) {
      this._invalidateCache();
    }
  };

  
  

  Container.prototype.hasChildren = function hasChildren () {
    return this.nodes.length > 0
  };

  Container.prototype.getChildIndex = function getChildIndex (child) {
    return this.nodes.indexOf(child.id)
  };

  Container.prototype.getChildren = function getChildren () {
    var doc = this.getDocument();
    var childrenIds = this.nodes;
    return childrenIds.map(function(id) {
      return doc.get(id)
    })
  };

  Container.prototype.getChildAt = function getChildAt (idx) {
    var childrenIds = this.nodes;
    if (idx < 0 || idx >= childrenIds.length) {
      throw new Error('Array index out of bounds: ' + idx + ", " + childrenIds.length)
    }
    return this.getDocument().get(childrenIds[idx])
  };

  Container.prototype.getChildCount = function getChildCount () {
    return this.nodes.length
  };

  Object.defineProperties( Container.prototype, prototypeAccessors );

  return Container;
}(DocumentNode));

Container.prototype._isContainer = true;

Container.schema = {
  type: 'container',
  nodes: { type: ['array', 'id'], default: [] }
};

var ContainerAdapter = (function (Container$$1) {
  function ContainerAdapter(doc, path) {
    Container$$1.call(this, doc, { id: String(path) });
    this.document = doc;
    this.path = path;

    
    
    doc.data.nodes[this.id] = this;
  }

  if ( Container$$1 ) ContainerAdapter.__proto__ = Container$$1;
  ContainerAdapter.prototype = Object.create( Container$$1 && Container$$1.prototype );
  ContainerAdapter.prototype.constructor = ContainerAdapter;

  var prototypeAccessors = { nodes: {} };

  ContainerAdapter.prototype.getContentPath = function getContentPath () {
    return this.path
  };

  prototypeAccessors.nodes.get = function () {
    return this.document.get(this.path)
  };

  Object.defineProperties( ContainerAdapter.prototype, prototypeAccessors );

  return ContainerAdapter;
}(Container));

ContainerAdapter.prototype._isDocumentNode = false;
ContainerAdapter.prototype._isContainer = false;

var ContainerAnnotation = (function (Annotation$$1) {
  function ContainerAnnotation () {
    Annotation$$1.apply(this, arguments);
  }

  if ( Annotation$$1 ) ContainerAnnotation.__proto__ = Annotation$$1;
  ContainerAnnotation.prototype = Object.create( Annotation$$1 && Annotation$$1.prototype );
  ContainerAnnotation.prototype.constructor = ContainerAnnotation;

  ContainerAnnotation.prototype.getSelection = function getSelection () {
    var doc = this.getDocument();
    
    if (!doc) {
      console.warn('Trying to use a ContainerAnnotation which is not attached to the document.');
      return Selection.nullSelection()
    }
    return doc.createSelection({
      type: "container",
      containerId: this.containerId,
      startPath: this.start.path,
      startOffset: this.start.offset,
      endPath: this.end.path,
      endOffset: this.end.offset
    })
  };

  ContainerAnnotation.prototype.setHighlighted = function setHighlighted (highlighted, scope) {
    if (this.highlighted !== highlighted) {
      this.highlighted = highlighted;
      this.highlightedScope = scope;
      this.emit('highlighted', highlighted, scope);
      forEach(this.fragments, function(frag) {
        frag.emit('highlighted', highlighted, scope);
      });
    }
  };

  ContainerAnnotation.prototype._updateRange = function _updateRange (tx, sel) {
    if (!sel.isContainerSelection()) {
      throw new Error('Invalid argument.')
    }
    
    if (!isEqual(this.start.path, sel.start.path)) {
      tx.set([this.id, 'start', 'path'], sel.start.path);
    }
    if (this.start.offset !== sel.start.offset) {
      tx.set([this.id, 'start', 'offset'], sel.start.offset);
    }
    if (!isEqual(this.end.path, sel.end.path)) {
      tx.set([this.id, 'end', 'path'], sel.end.path);
    }
    if (this.end.offset !== sel.end.offset) {
      tx.set([this.id, 'end', 'offset'], sel.end.offset);
    }
  };

  return ContainerAnnotation;
}(Annotation));

ContainerAnnotation.schema = {
  type: "container-annotation",
  containerId: "string"
};

ContainerAnnotation.prototype._isContainerAnnotation = true;

var CoordinateAdapter = (function (Coordinate$$1) {
  function CoordinateAdapter(owner, pathProperty, offsetProperty) {
    Coordinate$$1.call(this, 'SKIP');

    this._owner = owner;
    this._pathProp = pathProperty;
    this._offsetProp = offsetProperty;
    Object.freeze(this);
  }

  if ( Coordinate$$1 ) CoordinateAdapter.__proto__ = Coordinate$$1;
  CoordinateAdapter.prototype = Object.create( Coordinate$$1 && Coordinate$$1.prototype );
  CoordinateAdapter.prototype.constructor = CoordinateAdapter;

  var prototypeAccessors = { path: {},offset: {} };

  CoordinateAdapter.prototype.equals = function equals (other) {
    return (other === this ||
      (isArrayEqual(other.path, this.path) && other.offset === this.offset) )
  };

  prototypeAccessors.path.get = function () {
    return this._owner[this._pathProp];
  };

  prototypeAccessors.path.set = function (path) {
    this._owner[this._pathProp] = path;
  };

  prototypeAccessors.offset.get = function () {
    return this._owner[this._offsetProp];
  };

  prototypeAccessors.offset.set = function (offset) {
    this._owner[this._offsetProp] = offset;
  };

  CoordinateAdapter.prototype.toJSON = function toJSON () {
    return {
      path: this.path,
      offset: this.offset
    }
  };

  CoordinateAdapter.prototype.toString = function toString () {
    return "(" + this.path.join('.') + ", " + this.offset + ")"
  };

  Object.defineProperties( CoordinateAdapter.prototype, prototypeAccessors );

  return CoordinateAdapter;
}(Coordinate));

function createDocumentFactory$$1(ArticleClass, create) {
  return {
    ArticleClass: ArticleClass,
    createEmptyArticle: function() {
      var doc = new ArticleClass();
      return doc
    },
    createArticle: function() {
      var doc = new ArticleClass();
      create(doc);
      return doc
    },
    createChangeset: function() {
      var doc = new ArticleClass();
      var txDoc = new TransactionDocument(doc);
      var tx = new EditingInterface(txDoc);
      create(tx);
      var change = new DocumentChange(txDoc.ops);
      return [change.toJSON()]
    }
  }
}

var DefaultChangeCompressor = function DefaultChangeCompressor () {};

DefaultChangeCompressor.prototype.shouldMerge = function shouldMerge (lastChange, newChange) {
  return false
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
};


DefaultChangeCompressor.prototype.merge = function merge$$1 (first, second) {
  
  
  var firstOp = first.ops[0];
  var secondOp = second.ops[0];
  var firstDiff = firstOp.diff;
  var secondDiff = secondOp.diff;
  var mergedOp = false;
  if (firstDiff.isInsert()) {
    if (firstDiff.pos+firstDiff.getLength() === secondDiff.pos) {
      mergedOp = firstOp.toJSON();
      mergedOp.diff.str += secondDiff.str;
    }
  }
  else if (firstDiff.isDelete()) {
    
    
    if (firstDiff.pos === secondDiff.pos) {
      mergedOp = firstOp.toJSON();
      mergedOp.diff.str += secondDiff.str;
    } else if (secondDiff.pos+secondDiff.getLength() === firstDiff.pos) {
      mergedOp = firstOp.toJSON();
      mergedOp.diff = secondDiff;
      mergedOp.diff.str += firstDiff.str;
    }
  }
  if (mergedOp) {
    first.ops[0] = ObjectOperation.fromJSON(mergedOp);
    if (first.ops.length > 1) {
      
      
      
      first.ops = first.ops.concat(second.ops.slice(1));
      first.after = second.after;
    }
    return true
  }
  return false
};

var FileProxy = function FileProxy(fileNode, context) {
  this.fileNode = fileNode;
  this.context = context;
  fileNode.setProxy(this);
};

var prototypeAccessors$5 = { id: {} };

prototypeAccessors$5.id.get = function () {
  return this.fileNode.id
};


FileProxy.prototype.triggerUpdate = function triggerUpdate () {
  var fileId = this.fileNode.id;
  this.context.editorSession.transaction(function (tx) {
    tx.set([fileId, '__changed__'], '');
  }, { history: false });
};

FileProxy.prototype.getUrl = function getUrl () {
  return ''
};

FileProxy.prototype.sync = function sync () {
  return Promise.reject(new Error('sync method not implemented'))
};

Object.defineProperties( FileProxy.prototype, prototypeAccessors$5 );

FileProxy.match = function(fileNode, context) { 
  return false
};

var DefaultFileProxy = (function (FileProxy$$1) {
  function DefaultFileProxy(fileNode, context) {
    FileProxy$$1.call(this, fileNode, context);

    
    this.file = fileNode.sourceFile;
    if (this.file) {
      this._fileUrl = URL.createObjectURL(this.file);
    }
    this.url = fileNode.url;
  }

  if ( FileProxy$$1 ) DefaultFileProxy.__proto__ = FileProxy$$1;
  DefaultFileProxy.prototype = Object.create( FileProxy$$1 && FileProxy$$1.prototype );
  DefaultFileProxy.prototype.constructor = DefaultFileProxy;

  DefaultFileProxy.prototype.getUrl = function getUrl () {
    
    if (this.url) {
      return this.url
    }
    
    if (this._fileUrl) {
      return this._fileUrl
    }
    
    return ''
  };

  DefaultFileProxy.prototype.sync = function sync () {
    if (!this.url) {
      console.info('Simulating file upload. Creating blob url instead.', this._fileUrl);
      this.url = this._fileUrl;
    }
    return Promise.resolve()
  };

  return DefaultFileProxy;
}(FileProxy));

var NodeRegistry = (function (Registry$$1) {
  function NodeRegistry () {
    Registry$$1.apply(this, arguments);
  }

  if ( Registry$$1 ) NodeRegistry.__proto__ = Registry$$1;
  NodeRegistry.prototype = Object.create( Registry$$1 && Registry$$1.prototype );
  NodeRegistry.prototype.constructor = NodeRegistry;

  NodeRegistry.prototype.register = function register (nodeClazz) {
    var type = nodeClazz.prototype.type;
    if ( typeof type !== 'string' || type === '' ) {
      console.error('#### nodeClazz', nodeClazz);
      throw new Error( 'Node names must be strings and must not be empty')
    }
    if ( !( nodeClazz.prototype._isNode) ) {
      throw new Error( 'Nodes must be subclasses of Substance.Data.Node' )
    }
    if (this.contains(type)) {
      throw new Error('Node class is already registered: ' + type)
    }
    this.add(type, nodeClazz);
  };

  return NodeRegistry;
}(Registry));

var Schema = function Schema(name, version) {
  
  this.name = name;
  
  this.version = version;
  
  this.nodeRegistry = new NodeRegistry();
  
  this.tocTypes = [];

  
  this.addNodes(this.getBuiltIns());
};


Schema.prototype.addNodes = function addNodes (nodes) {
  if (!nodes) { return }
  forEach(nodes, function(NodeClass) {
    if (!NodeClass.prototype._isNode) {
      console.error('Illegal node class: ', NodeClass);
    } else {
      this.addNode(NodeClass);
    }
  }.bind(this));
};

Schema.prototype.addNode = function addNode (NodeClass) {
  this.nodeRegistry.register(NodeClass);
  if (NodeClass.tocType) {
    this.tocTypes.push(NodeClass.type);
  }
};


Schema.prototype.getNodeClass = function getNodeClass (name) {
  return this.nodeRegistry.get(name)
};


Schema.prototype.getBuiltIns = function getBuiltIns () {
  return []
};


Schema.prototype.isInstanceOf = function isInstanceOf (type, parentType) {
  var NodeClass = this.getNodeClass(type);
  if (NodeClass) {
    return Node.isInstanceOf(NodeClass, parentType)
  }
  return false
};


Schema.prototype.each = function each () {
  this.nodeRegistry.each.apply(this.nodeRegistry, arguments);
};


Schema.prototype.getTocTypes = function getTocTypes () {
  return this.tocTypes
};


Schema.prototype.getDefaultTextType = function getDefaultTextType () {
  throw new Error('Schmema.prototype.getDefaultTextType() must be overridden.')
};

Schema.prototype.getNodeSchema = function getNodeSchema (type) {
  var NodeClass = this.getNodeClass(type);
  if (!NodeClass) {
    console.error('Unknown node type ', type);
    return null
  }
  return NodeClass.schema
};

var PropertyAnnotation = (function (Annotation$$1) {
  function PropertyAnnotation () {
    Annotation$$1.apply(this, arguments);
  }

  if ( Annotation$$1 ) PropertyAnnotation.__proto__ = Annotation$$1;
  PropertyAnnotation.prototype = Object.create( Annotation$$1 && Annotation$$1.prototype );
  PropertyAnnotation.prototype.constructor = PropertyAnnotation;

  var prototypeAccessors = { path: {},startPath: {},endPath: {} };

  prototypeAccessors.path.get = function () {
    return this.start.path
  };

  PropertyAnnotation.prototype.getPath = function getPath () {
    return this.start.path
  };

  PropertyAnnotation.prototype.getSelection = function getSelection () {
    return this.getDocument().createSelection({
      type: 'property',
      path: this.path,
      startOffset: this.start.offset,
      endOffset: this.end.offset
    })
  };

  
  PropertyAnnotation.prototype._updateRange = function _updateRange (tx, sel) {
    if (!sel.isPropertySelection()) {
      throw new Error('Invalid argument: PropertyAnnotation._updateRange() requires a PropertySelection.')
    }
    if (!isArrayEqual(this.start.path, sel.start.path)) {
      tx.set([this.id, 'path'], sel.start.path);
    }
    
    if (this.start.offset !== sel.start.offset) {
      tx.set([this.id, 'start', 'offset'], sel.start.offset);
    }
    if (this.end.offset !== sel.end.offset) {
      tx.set([this.id, 'end', 'offset'], sel.end.offset);
    }
  };

  prototypeAccessors.startPath.get = function () {
    return this.path
  };

  prototypeAccessors.endPath.get = function () {
    return this.path
  };

  Object.defineProperties( PropertyAnnotation.prototype, prototypeAccessors );

  return PropertyAnnotation;
}(Annotation));

PropertyAnnotation.prototype._isAnnotation = true;
PropertyAnnotation.prototype._isPropertyAnnotation = true;

PropertyAnnotation.isPropertyAnnotation = true;
PropertyAnnotation.autoExpandRight = true;

PropertyAnnotation.schema = {
  type: "annotation",
  start: "coordinate",
  end: "coordinate",
  
  
  _content: { type: "string", optional: true}
};

var DocumentSchema = (function (Schema$$1) {
  function DocumentSchema(ref) {
    var name = ref.name;
    var DocumentClass = ref.DocumentClass;
    var defaultTextType = ref.defaultTextType; if ( defaultTextType === void 0 ) defaultTextType = 'text';
    var version = ref.version; if ( version === void 0 ) version = '0.0.0';

    Schema$$1.call(this, name, version);

    
    if (!DocumentClass) {
      throw new Error('DocumentClass is mandatory')
    }

    this.DocumentClass = DocumentClass;
    this.defaultTextType = defaultTextType;
  }

  if ( Schema$$1 ) DocumentSchema.__proto__ = Schema$$1;
  DocumentSchema.prototype = Object.create( Schema$$1 && Schema$$1.prototype );
  DocumentSchema.prototype.constructor = DocumentSchema;

  DocumentSchema.prototype.getDocumentClass = function getDocumentClass () {
    return this.DocumentClass
  };

  
  DocumentSchema.prototype.getDefaultTextType = function getDefaultTextType () {
    return this.defaultTextType
  };

  
  DocumentSchema.prototype.getBuiltIns = function getBuiltIns () {
    return [DocumentNode, PropertyAnnotation, Container, ContainerAnnotation]
  };

  return DocumentSchema;
}(Schema));

var ENTER = 1;
var EXIT = -1;
var ANCHOR = -2;






























var Fragmenter = function Fragmenter(options) {
  Object.assign(this, options);
};

Fragmenter.prototype.start = function start (rootContext, text, annotations) {
  if (!isString$1(text)) {
    throw new Error("Illegal argument: 'text' must be a String, but was " + text)
  }
  this._start(rootContext, text, annotations);
};

Fragmenter.prototype.onText = function onText (context, text, entry) { 
};


Fragmenter.prototype.onEnter = function onEnter (entry, parentContext) { 
  return null
};

Fragmenter.prototype.onExit = function onExit (entry, context, parentContext) { 
};

Fragmenter.prototype._enter = function _enter (entry, parentContext) {
  entry.counter++;
  return this.onEnter(entry, parentContext)
};

Fragmenter.prototype._exit = function _exit (entry, context, parentContext) {
  this.onExit(entry, context, parentContext);
};

Fragmenter.prototype._createText = function _createText (context, text, entry) {
  this.onText(context, text, entry);
};

Fragmenter.prototype._start = function _start (rootContext, text, annotations) {
    var this$1 = this;

  var entries = _extractEntries.call(this, annotations);
  var stack = [{context: rootContext, entry: null}];

  var pos = 0;
  for (var i = 0; i < entries.length; i++) {
    var entry = entries[i];
    var textFragment = text.substring(pos, entry.pos);
    if (textFragment) {
      
      this$1._createText(stack[stack.length-1].context, textFragment, entry);
    }

    pos = entry.pos;
    var stackLevel, idx, _entry;
    if (entry.mode === ENTER || entry.mode === ANCHOR) {
      
      for (stackLevel = 1; stackLevel < stack.length; stackLevel++) {
        if (entry.level < stack[stackLevel].entry.level) {
          break
        }
      }
      
      
      for (idx = stack.length-1; idx >= stackLevel; idx--) {
        _entry = stack[idx].entry;
        
        _entry.length = pos - _entry.pos;
        this$1._exit(_entry, stack[idx].context, stack[idx-1].context);
      }
      stack.splice(stackLevel, 0, {entry: entry});
      
      for (idx = stackLevel; idx < stack.length; idx++) {
        _entry = stack[idx].entry;
        
        _entry.pos = pos;
        stack[idx].context = this$1._enter(_entry, stack[idx-1].context);
      }
    }
    if (entry.mode === EXIT || entry.mode === ANCHOR) {
      
      for (stackLevel = 1; stackLevel < stack.length; stackLevel++) {
        if (stack[stackLevel].entry.node === entry.node) {
          break
        }
      }
      for (idx = stack.length-1; idx >= stackLevel; idx--) {
        _entry = stack[idx].entry;
        
        _entry.length = pos - _entry.pos;
        this$1._exit(_entry, stack[idx].context, stack[idx-1].context);
      }
      stack.splice(stackLevel, 1);
      
      for (idx = stackLevel; idx < stack.length; idx++) {
        _entry = stack[idx].entry;
        
        _entry.pos = pos;
        stack[idx].context = this$1._enter(_entry, stack[idx-1].context);
      }
    }
  }

  
  var trailingText = text.substring(pos);
  if (trailingText) {
    this._createText(rootContext, trailingText);
  }
};

Fragmenter.SHOULD_NOT_SPLIT = 0;
Fragmenter.NORMAL = 10;
Fragmenter.ANY = 100;
Fragmenter.ALWAYS_ON_TOP = Number.MAX_VALUE;







































function _extractEntries(annotations) {
  var openers = [];
  var closers = [];
  forEach(annotations, function(a) {
    var isAnchor = (a.isAnchor ? a.isAnchor() : false);
    
    if (isAnchor) {
      openers.push({
        mode: ANCHOR,
        pos: a.offset,
        id: a.id,
        level: Fragmenter.ALWAYS_ON_TOP,
        type: 'anchor',
        node: a,
        counter: -1,
        length: 0
      });
    } else {
      
      
      
      
      
      
      

      
      var l = Fragmenter.NORMAL;
      var isInline = (a.isInline ? a.isInline() : false);
      if (isInline) {
        l = Number.MAX_VALUE;
      } else if (a.constructor.hasOwnProperty('fragmentation')) {
        l = a.constructor.fragmentation;
      } else if (a.hasOwnProperty('fragmentationHint')) {
        l = a.fragmentationHint;
      }
      var startOffset = Math.min(a.start.offset, a.end.offset);
      var endOffset = Math.max(a.start.offset, a.end.offset);
      var opener = {
        pos: startOffset,
        mode: ENTER,
        level: l,
        id: a.id,
        type: a.type,
        node: a,
        length: 0,
        counter: -1,
      };
      openers.push(opener);
      closers.push({
        pos: endOffset,
        mode: EXIT,
        level: l,
        id: a.id,
        type: a.type,
        node: a,
        opener: opener
      });
    }
  });

  
  openers.sort(_compareOpeners);
  
  for (var i = openers.length - 1; i >= 0; i--) {
    openers[i].idx = i;
  }
  closers.sort(_compareClosers);
  
  var entries = new Array(openers.length+closers.length);
  var idx = 0;
  var idx1 = 0;
  var idx2 = 0;
  var opener = openers[idx1];
  var closer = closers[idx2];
  while(opener || closer) {
    if (opener && closer) {
      
      if (closer.pos <= opener.pos && closer.opener !== opener) {
        entries[idx] = closer;
        idx2++;
      } else {
        entries[idx] = opener;
        idx1++;
      }
    } else if (opener) {
      entries[idx] = opener;
      idx1++;
    } else if (closer) {
      entries[idx] = closer;
      idx2++;
    }
    opener = openers[idx1];
    closer = closers[idx2];
    idx++;
  }
  return entries
}

function _compareOpeners(a, b) {
  if (a.pos < b.pos) { return -1 }
  if (a.pos > b.pos) { return 1 }
  if (a.mode < b.mode) { return -1 }
  if (a.mode > b.mode) { return 1 }
  if (a.mode === b.mode) {
    if (a.level < b.level) { return -1 }
    if (a.level > b.level) { return 1 }
  }
  return 0
}


function _compareClosers(a, b) {
  if (a.pos < b.pos) { return -1 }
  if (a.pos > b.pos) { return 1 }
  
  
  
  
  
  if (a.pos === a.opener.pos && b.pos === b.opener.pos) {
    if (a.opener.idx < b.opener.idx) {
      return -1
    } else {
      return 1
    }
  }
  if (a.opener.idx > b.opener.idx) { return -1 }
  if (a.opener.idx < b.opener.idx) { return 1 }
  return 0
}

var DOMExporter = function DOMExporter(config, context) {
  this.context = context || {};
  if (!config.converters) {
    throw new Error('config.converters is mandatory')
  }
  if (!config.converters._isRegistry) {
    this.converters = new Registry();
    config.converters.forEach(function(Converter) {
      var converter = isFunction$1(Converter) ? new Converter() : Converter;
      if (!converter.type) {
        console.error('Converter must provide the type of the associated node.', converter);
        return
      }
      this.converters.add(converter.type, converter);
    }.bind(this));
  } else {
    this.converters = config.converters;
  }

  this.state = {
    doc: null
  };
  this.config = config;
  
  
  this._elementFactory = config.elementFactory;
  if (!this._elementFactory) {
    throw new Error("'elementFactory' is mandatory")
  }
  this.$$ = this.createElement.bind(this);
};

DOMExporter.prototype.exportDocument = function exportDocument (doc) {
  
  
  
  
  return this.convertDocument(doc)
};


DOMExporter.prototype.convertDocument = function convertDocument (doc) { 
  throw new Error('This method is abstract')
};

DOMExporter.prototype.convertContainer = function convertContainer (container) {
  if (!container) {
    throw new Error('Illegal arguments: container is mandatory.')
  }
  var doc = container.getDocument();
  this.state.doc = doc;
  var elements = [];
  container.nodes.forEach(function(id) {
    var node = doc.get(id);
    var nodeEl = this.convertNode(node);
    elements.push(nodeEl);
  }.bind(this));
  return elements
};

DOMExporter.prototype.convertNode = function convertNode (node) {
  if (isString$1(node)) {
    
    node = this.state.doc.get(node);
  } else {
    this.state.doc = node.getDocument();
  }
  var converter = this.getNodeConverter(node);
  
  
  if (node._isPropertyAnnotation && (!converter || !converter.export)) {
    return this._convertPropertyAnnotation(node)
  }
  if (!converter) {
    converter = this.getDefaultBlockConverter();
  }
  var el;
  if (converter.tagName) {
    el = this.$$(converter.tagName);
  } else {
    el = this.$$('div');
  }
  el.attr(this.config.idAttribute, node.id);
  if (converter.export) {
    el = converter.export(node, el, this) || el;
  } else {
    el = this.getDefaultBlockConverter().export(node, el, this) || el;
  }
  return el
};

DOMExporter.prototype.convertProperty = function convertProperty (doc, path, options) {
  this.initialize(doc, options);
  var wrapper = this.$$('div')
    .append(this.annotatedText(path));
  return wrapper.innerHTML
};

DOMExporter.prototype.annotatedText = function annotatedText (path) {
  var doc = this.state.doc;
  var text = doc.get(path);
  var annotations = doc.getIndex('annotations').get(path);
  return this._annotatedText(text, annotations)
};

DOMExporter.prototype.getNodeConverter = function getNodeConverter (node) {
  return this.converters.get(node.type)
};

DOMExporter.prototype.getDefaultBlockConverter = function getDefaultBlockConverter () {
  throw new Error('This method is abstract.')
};

DOMExporter.prototype.getDefaultPropertyAnnotationConverter = function getDefaultPropertyAnnotationConverter () {
  throw new Error('This method is abstract.')
};

DOMExporter.prototype.getDocument = function getDocument () {
  return this.state.doc
};

DOMExporter.prototype.createElement = function createElement (str) {
  return this._elementFactory.createElement(str)
};

DOMExporter.prototype._annotatedText = function _annotatedText (text, annotations) {
  var self = this;

  var annotator = new Fragmenter();
  annotator.onText = function(context, text) {
    context.children.push(encodeXMLEntities(text));
  };
  annotator.onEnter = function(fragment) {
    var anno = fragment.node;
    return {
      annotation: anno,
      children: []
    }
  };
  annotator.onExit = function(fragment, context, parentContext) {
    var anno = context.annotation;
    var converter = self.getNodeConverter(anno);
    if (!converter) {
      converter = self.getDefaultPropertyAnnotationConverter();
    }
    var el;
    if (converter.tagName) {
      el = this.$$(converter.tagName);
    } else {
      el = this.$$('span');
    }
    el.attr(this.config.idAttribute, anno.id);
    el.append(context.children);
    if (converter.export) {
      el = converter.export(anno, el, self) || el;
    }
    parentContext.children.push(el);
  }.bind(this);
  var wrapper = { children: [] };
  annotator.start(wrapper, text, annotations);
  return wrapper.children
};


DOMExporter.prototype._convertPropertyAnnotation = function _convertPropertyAnnotation (anno) {
  
  var wrapper = this.$$('div').append(this.annotatedText(anno.path));
  var el = wrapper.find('['+this.config.idAttribute+'="'+anno.id+'"]');
  return el
};

var WS_LEFT = /^\s+/g;
var WS_LEFT_ALL = /^\s*/g;
var WS_RIGHT = /\s+$/g;
var WS_ALL = /\s+/g;


var SPACE = " ";
var TABS_OR_NL = /[\t\n\r]+/g;

var INVISIBLE_CHARACTER = "\u200B";


var DOMImporter = function DOMImporter(config, context) {
  this.context = context || {};

  if (!config.schema) {
    throw new Error('"config.schema" is mandatory')
  }
  if (!config.converters) {
    throw new Error('"config.converters" is mandatory')
  }

  this.config = Object.assign({ idAttribute: 'id' }, config);
  this.schema = config.schema;
  this.converters = config.converters;
  this.state = null;

  this._defaultBlockConverter = null;
  this._allConverters = [];
  this._blockConverters = [];
  this._propertyAnnotationConverters = [];

  this.state = new DOMImporter.State();

  this._initialize();
};


DOMImporter.prototype._initialize = function _initialize () {
    var this$1 = this;

  var schema = this.schema;
  var defaultTextType = schema.getDefaultTextType();
  var converters = this.converters;
  for (var i = 0; i < converters.length; i++) {
    var converter = (void 0);
    if (typeof converters[i] === 'function') {
      var Converter = converters[i];
      converter = new Converter();
    } else {
      converter = converters[i];
    }
    if (!converter.type) {
      throw new Error('Converter must provide the type of the associated node.')
    }
    if (!converter.matchElement && !converter.tagName) {
      throw new Error('Converter must provide a matchElement function or a tagName property.')
    }
    if (!converter.matchElement) {
      converter.matchElement = this$1._defaultElementMatcher.bind(converter);
    }
    var NodeClass = schema.getNodeClass(converter.type);
    if (!NodeClass) {
      throw new Error('No node type defined for converter')
    }
    if (!this$1._defaultBlockConverter && defaultTextType === converter.type) {
      this$1._defaultBlockConverter = converter;
    }
    this$1._allConverters.push(converter);
    
    if (NodeClass.prototype._isPropertyAnnotation) {
      this$1._propertyAnnotationConverters.push(converter);
    } else {
      this$1._blockConverters.push(converter);
    }
  }
  if (!this._defaultBlockConverter) {
    throw new Error(("No converter for defaultTextType " + defaultTextType))
  }
};

DOMImporter.prototype.dispose = function dispose () {
  if (this.state.doc) {
    this.state.doc.dispose();
  }
};


DOMImporter.prototype.reset = function reset () {
  if (this.state.doc) {
    this.state.doc.dispose();
  }
  this.state.reset();
  this.state.doc = this._createDocument();
};

DOMImporter.prototype.getDocument = function getDocument () {
  return this.state.doc
};


DOMImporter.prototype.convertContainer = function convertContainer (elements, containerId) {
    var this$1 = this;

  if (!this.state.doc) { this.reset(); }
  var state = this.state;
  var iterator = new ArrayIterator(elements);
  var nodeIds = [];
  while(iterator.hasNext()) {
    var el = iterator.next();
    var node = (void 0);
    var blockTypeConverter = this$1._getConverterForElement(el, 'block');
    if (blockTypeConverter) {
      state.pushContext(el.tagName, blockTypeConverter);
      var nodeData = this$1._createNodeData(el, blockTypeConverter.type);
      nodeData = blockTypeConverter.import(el, nodeData, this$1) || nodeData;
      node = this$1._createNode(nodeData);
      var context = state.popContext();
      context.annos.forEach(function (a) {
        this$1._createNode(a);
      });
    } else if (el.isCommentNode()) {
      continue
    } else {
      
      if (el.isTextNode() && /^\s*$/.exec(el.textContent)) { continue }
      
      
      iterator.back();
      node = this$1._wrapInlineElementsIntoBlockElement(iterator);
    }
    if (node) {
      nodeIds.push(node.id);
    }
  }
  return this._createNode({
    type: 'container',
    id: containerId,
    nodes: nodeIds
  })
};


DOMImporter.prototype.convertElement = function convertElement (el) {
    var this$1 = this;

  if (!this.state.doc) { this.reset(); }
  var isTopLevel = !this.state.isConverting;
  if (isTopLevel) {
    this.state.isConverting = true;
  }

  var nodeData, annos;
  var converter = this._getConverterForElement(el);
  if (converter) {
    var NodeClass = this.schema.getNodeClass(converter.type);
    nodeData = this._createNodeData(el, converter.type);
    this.state.pushContext(el.tagName, converter);
    
    
    
    
    
    if (NodeClass.isInline) {
      nodeData = this._convertInlineNode(el, nodeData, converter);
    }
    else if (NodeClass.prototype._isPropertyAnnotation) {
      nodeData = this._convertPropertyAnnotation(el, nodeData);
    } else {
      nodeData = converter.import(el, nodeData, this) || nodeData;
    }
    var context = this.state.popContext();
    annos = context.annos;
  } else {
    throw new Error('No converter found for '+el.tagName)
  }
  
  var node = this._createNode(nodeData);
  
  annos.forEach(function (a) {
    this$1._createNode(a);
  });

  
  
  if (this.config["stand-alone"] && isTopLevel) {
    this.state.isConverting = false;
    this.reset();
  }
  return node
};


DOMImporter.prototype.annotatedText = function annotatedText (el, path, options) {
    if ( options === void 0 ) options={};

  if (!path) {
    throw new Error('path is mandatory')
  }
  var state = this.state;
  var context = last$1(state.contexts);
  
  
  if (!context) {
    throw new Error('This should be called from within an element converter.')
  }
  
  var oldPreserveWhitespace = state.preserveWhitespace;
  if (options.preserveWhitespace) {
    state.preserveWhitespace = true;
  }
  state.stack.push({ path: path, offset: 0, text: "", annos: []});
  
  
  
  this.state.lastChar = '';
  var iterator = el.getChildNodeIterator();
  var text = this._annotatedText(iterator);
  
  
  var top = state.stack.pop();
  context.annos = context.annos.concat(top.annos);

  
  state.preserveWhitespace = oldPreserveWhitespace;

  return text
};


DOMImporter.prototype.plainText = function plainText (el) {
  var state = this.state;
  var text = el.textContent;
  if (state.stack.length > 0) {
    var context = last$1(state.stack);
    context.offset += text.length;
    context.text += context.text.concat(text);
  }
  return text
};


DOMImporter.prototype._customText = function _customText (text) {
  var state = this.state;
  if (state.stack.length > 0) {
    var context = last$1(state.stack);
    context.offset += text.length;
    context.text += context.text.concat(text);
  }
  return text
};


DOMImporter.prototype.nextId = function nextId (prefix) {
  
  
  
  
  return this.state.uuid(prefix)
};

DOMImporter.prototype._getNextId = function _getNextId (dom, type) {
    var this$1 = this;

  var id = this.nextId(type);
  while (this.state.ids[id] || dom.find('#'+id)) {
    id = this$1.nextId(type);
  }
  return id
};

DOMImporter.prototype._getIdForElement = function _getIdForElement (el, type) {
  var id = el.getAttribute(this.config.idAttribute);
  if (id && !this.state.ids[id]) { return id }
  return this._getNextId(el.getOwnerDocument(), type)
};




DOMImporter.prototype._createDocument = function _createDocument () {
  
  var schema = this.config.schema;
  var DocumentClass = schema.getDocumentClass();
  return new DocumentClass(schema)
};

DOMImporter.prototype._convertPropertyAnnotation = function _convertPropertyAnnotation (el, nodeData) {
  var path = [nodeData.id, '_content'];
  
  
  
  nodeData._content = this.annotatedText(el, path);
  nodeData.start = { path: path, offset: 0 };
  nodeData.end = { offset: nodeData._content.length };
  return nodeData
};

DOMImporter.prototype._convertInlineNode = function _convertInlineNode (el, nodeData, converter) {
  var path = [nodeData.id, '_content'];
  if (converter.import) {
    nodeData = converter.import(el, nodeData, this) || nodeData;
  }
  nodeData._content = '$';
  nodeData.start = { path: path, offset: 0 };
  nodeData.end = { offset: 1 };
  return nodeData
};

DOMImporter.prototype._createNodeData = function _createNodeData (el, type) {
  if (!type) {
    throw new Error('type is mandatory.')
  }
  var nodeData = {
    type: type,
    id: this._getIdForElement(el, type)
  };
  this.state.ids[nodeData.id] = true;
  return nodeData
};

DOMImporter.prototype._createNode = function _createNode (nodeData) {
  var doc = this.state.doc;
  
  
  
  var node = doc.get(nodeData.id);
  if (node) {
    
    doc.delete(node.id);
  }
  return doc.create(nodeData)
};

DOMImporter.prototype._defaultElementMatcher = function _defaultElementMatcher (el) {
  return el.is(this.tagName)
};


DOMImporter.prototype._annotatedText = function _annotatedText (iterator) {
    var this$1 = this;

  var state = this.state;
  var context = last$1(state.stack);
  
  if (!context) {
    throw new Error('Illegal state: context is null.')
  }
  while(iterator.hasNext()) {
    var el = iterator.next();
    var text = "";
    
    
    if (el.isTextNode()) {
      text = this$1._prepareText(el.textContent);
      if (text.length) {
        
        
        context.text = context.text.concat(text);
        context.offset += text.length;
      }
    } else if (el.isCommentNode()) {
      
      continue
    } else if (el.isElementNode()) {
      var annoConverter = this$1._getConverterForElement(el, 'inline');
      
      if (!annoConverter) {
        
        if (!this$1.IGNORE_DEFAULT_WARNINGS) {
          console.warn('Unsupported inline element. We will not create an annotation for it, but process its children to extract annotated text.', el.outerHTML);
        }
        
        
        var iterator$1 = el.getChildNodeIterator();
        this$1._annotatedText(iterator$1);
        continue
      }
      
      
      
      var startOffset = context.offset;
      var annoType = annoConverter.type;
      var AnnoClass = this$1.schema.getNodeClass(annoType);
      var annoData = this$1._createNodeData(el, annoType);
      
      var stackFrame = {
        path: context.path,
        offset: startOffset,
        text: "",
        annos: []
      };
      state.stack.push(stackFrame);
      
      if (annoConverter.import) {
        state.pushContext(el.tagName, annoConverter);
        annoData = annoConverter.import(el, annoData, this$1) || annoData;
        state.popContext();
      }
      
      
      
      
      if (AnnoClass.isInline) {
        this$1._customText(INVISIBLE_CHARACTER);
      } else {
        
        
        
        var iterator$2 = el.getChildNodeIterator();
        this$1._annotatedText(iterator$2);
      }
      
      state.stack.pop();
      context.offset = stackFrame.offset;
      context.text = context.text.concat(stackFrame.text);
      
      var endOffset = context.offset;
      annoData.start = {
        path: context.path.slice(0),
        offset: startOffset
      };
      annoData.end = {
        offset: endOffset
      };
      
      var parentFrame = last$1(state.stack);
      parentFrame.annos = parentFrame.annos.concat(stackFrame.annos, annoData);
    } else {
      console.warn('Unknown element type. Taking plain text.', el.outerHTML);
      text = this$1._prepareText(el.textContent);
      context.text = context.text.concat(text);
      context.offset += text.length;
    }
  }
  
  return context.text
};

DOMImporter.prototype._getConverterForElement = function _getConverterForElement (el, mode) {
    var this$1 = this;

  var converters;
  if (mode === "block") {
    if (!el.tagName) { return null }
    converters = this._blockConverters;
  } else if (mode === "inline") {
    converters = this._propertyAnnotationConverters;
  } else {
    converters = this._allConverters;
  }
  var converter = null;
  for (var i = 0; i < converters.length; i++) {
    if (this$1._converterCanBeApplied(converters[i], el)) {
      converter = converters[i];
      break
    }
  }
  return converter
};

DOMImporter.prototype._converterCanBeApplied = function _converterCanBeApplied (converter, el) {
  return converter.matchElement(el, this)
};


DOMImporter.prototype._wrapInlineElementsIntoBlockElement = function _wrapInlineElementsIntoBlockElement (childIterator) {
    var this$1 = this;

  if (!childIterator.hasNext()) { return }
  var dom = childIterator.peek().getOwnerDocument();
  var wrapper = dom.createElement('wrapper');
  while(childIterator.hasNext()) {
    var el = childIterator.next();
    
    var blockTypeConverter = this$1._getConverterForElement(el, 'block');
    if (blockTypeConverter) {
      childIterator.back();
      break
    }
    wrapper.append(el.clone());
  }
  var type = this.schema.getDefaultTextType();
  var id = this._getNextId(dom, type);
  var converter = this._defaultBlockConverter;
  var nodeData = { type: type, id: id };
  this.state.pushContext('wrapper', converter);
  nodeData = converter.import(wrapper, nodeData, this) || nodeData;
  var context = this.state.popContext();
  var annos = context.annos;
  
  var node = this._createNode(nodeData);
  
  annos.forEach(function (a) {
    this$1._createNode(a);
  });
  return node
};


DOMImporter.prototype._prepareText = function _prepareText (text) {
  var state = this.state;
  if (state.preserveWhitespace) {
    return text
  }
  var repl = SPACE;
  
  text = text.replace(TABS_OR_NL, '');
  
  
  
  if (state.lastChar === SPACE) {
    text = text.replace(WS_LEFT_ALL, repl);
  } else {
    text = text.replace(WS_LEFT, repl);
  }
  text = text.replace(WS_RIGHT, repl);
  
  
  
  if (this.config.REMOVE_INNER_WS || state.removeInnerWhitespace) {
    text = text.replace(WS_ALL, SPACE);
  }
  state.lastChar = text[text.length-1] || state.lastChar;
  return text
};


DOMImporter.prototype._trimTextContent = function _trimTextContent (el) {
  var nodes = el.getChildNodes();
  var firstNode = nodes[0];
  var lastNode = last$1(nodes);
  var text, trimmed;
    
  if (firstNode && firstNode.isTextNode()) {
    text = firstNode.textContent;
    trimmed = this._trimLeft(text);
    firstNode.textContent = trimmed;
  }
  if (lastNode && lastNode.isTextNode()) {
    text = lastNode.textContent;
    trimmed = this._trimRight(text);
    lastNode.textContent = trimmed;
  }
  return el
};

DOMImporter.prototype._trimLeft = function _trimLeft (text) {
  return text.replace(WS_LEFT, "")
};

DOMImporter.prototype._trimRight = function _trimRight (text) {
  return text.replace(WS_RIGHT, "")
};

var DOMImporterState = function DOMImporterState() {
  this.reset();
};

DOMImporterState.prototype.reset = function reset () {
  this.preserveWhitespace = false;
  this.nodes = [];
  this.annotations = [];
  this.containerId = null;
  this.container = [];
  this.ids = {};
  
  this.contexts = [];
  
  this.stack = [];
  this.lastChar = "";
  this.skipTypes = {};
  this.ignoreAnnotations = false;
  this.isConverting = false;

  
  
  this.uuid = createCountingIdGenerator();
};

DOMImporterState.prototype.pushContext = function pushContext (tagName, converter) {
  this.contexts.push({ tagName: tagName, converter: converter, annos: []});
};

DOMImporterState.prototype.popContext = function popContext () {
  return this.contexts.pop()
};

DOMImporterState.prototype.getCurrentContext = function getCurrentContext () {
  return last$1(this.contexts)
};

DOMImporter.State = DOMImporterState;

DOMImporter.INVISIBLE_CHARACTER = INVISIBLE_CHARACTER;

var EditingBehavior = function EditingBehavior() {
  this._merge = {};
  this._mergeComponents = {};
  this._break = {};
};

EditingBehavior.prototype.defineMerge = function defineMerge (firstType, secondType, impl) {
  if (!this._merge[firstType]) {
    this._merge[firstType] = {};
  }
  this._merge[firstType][secondType] = impl;
  return this
};

EditingBehavior.prototype.canMerge = function canMerge (firstType, secondType) {
  return (this._merge[firstType] && this._merge[firstType][secondType])
};

EditingBehavior.prototype.getMerger = function getMerger (firstType, secondType) {
  return this._merge[firstType][secondType]
};

EditingBehavior.prototype.defineComponentMerge = function defineComponentMerge (nodeType, impl) {
  this._mergeComponents[nodeType] = impl;
};

EditingBehavior.prototype.canMergeComponents = function canMergeComponents (nodeType) {
  return this._mergeComponents[nodeType]
};

EditingBehavior.prototype.getComponentMerger = function getComponentMerger (nodeType) {
  return this._mergeComponents[nodeType]
};

EditingBehavior.prototype.defineBreak = function defineBreak (nodeType, impl) {
  this._break[nodeType] = impl;
  return this
};

EditingBehavior.prototype.canBreak = function canBreak (nodeType) {
  return this._break[nodeType]
};

EditingBehavior.prototype.getBreaker = function getBreaker (nodeType) {
  return this._break[nodeType]
};

var FileNode = (function (DocumentNode$$1) {
  function FileNode() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    DocumentNode$$1.apply(this, args);
  }

  if ( DocumentNode$$1 ) FileNode.__proto__ = DocumentNode$$1;
  FileNode.prototype = Object.create( DocumentNode$$1 && DocumentNode$$1.prototype );
  FileNode.prototype.constructor = FileNode;

  FileNode.prototype.getUrl = function getUrl () {
    if (this.proxy) {
      return this.proxy.getUrl()
    } else {
      
      console.warn('No file proxy attached to ', this.id);
      return ''
    }
  };

  FileNode.prototype.setProxy = function setProxy (proxy) {
    this.proxy = proxy;
  };

  return FileNode;
}(DocumentNode));

FileNode.type = 'file';

FileNode.schema = {
  url: { type: 'string', optional: true },
  fileType: { type: 'string', optional: true },
  mimeType: { type: 'string', optional: true },
  sourceFile: { type: 'object', optional: true }
};

FileNode.prototype._isFileNode = true;
FileNode._isFileNode = true;

var DOMEventListener = function DOMEventListener(eventName, handler, options) {
  
  if (!isString$1(eventName) || !isFunction$1(handler)) {
    throw new Error("Illegal arguments: 'eventName' must be a String, and 'handler' must be a Function.")
  }
  options = options || {};
  var origHandler = handler;
  var context = options.context;
  var capture = Boolean(options.capture);

  if (context) {
    handler = handler.bind(context);
  }
  if (options.once === true) {
    handler = _once(this, handler);
  }

  this.eventName = eventName;
  this.originalHandler = origHandler;
  this.handler = handler;
  this.capture = capture;
  this.context = context;
  this.options = options;
  
  this._el = null;
};

DOMEventListener.prototype._isDOMEventListener = true;

DOMEventListener.findIndex = function(eventListeners, eventName, handler) {
  var idx = -1;
  if (arguments[1]._isDOMEventListener) {
    idx = eventListeners.indexOf(arguments[1]);
  } else {
    idx = findIndex$1(eventListeners,
      _matches.bind(null, {
        eventName: eventName,
        originalHandler: handler
      })
    );
  }
  return idx
};

function _matches(l1, l2) {
  return l1.eventName === l2.eventName && l1.originalHandler === l2.originalHandler
}

function _once(listener, handler) {
  return function(event) {
    handler(event);
    listener._el.removeEventListener(listener);
  }
}

var NOT_IMPLEMENTED = 'This method is not implemented.';


var DOMElement = function DOMElement () {};

var prototypeAccessors$6 = { id: {},tagName: {},nodeName: {},nodeType: {},className: {},textContent: {},innerHTML: {},outerHTML: {},firstChild: {},lastChild: {},nextSibling: {},previousSibling: {},parentNode: {},height: {},width: {},value: {} };

DOMElement.prototype.getNativeElement = function getNativeElement () {
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.isTextNode = function isTextNode () {
  
  return false
};


DOMElement.prototype.isElementNode = function isElementNode () {
  
  return false
};


DOMElement.prototype.isCommentNode = function isCommentNode () {
  
  return false
};


DOMElement.prototype.isDocumentNode = function isDocumentNode () {
  
  return false
};


DOMElement.prototype.getTagName = function getTagName () {
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.setTagName = function setTagName (tagName) { 
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.getId = function getId () {
  return this.getAttribute('id')
};


DOMElement.prototype.setId = function setId (id) {
  this.setAttribute('id', id);
};


DOMElement.prototype.hasClass = function hasClass (className) { 
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.addClass = function addClass (classString) { 
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.removeClass = function removeClass (classString) { 
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.hasAttribute = function hasAttribute (name) {
  return Boolean(this.getAttribute(name))
};


DOMElement.prototype.attr = function attr () {
  if (arguments.length === 1) {
    if (isString$1(arguments[0])) {
      return this.getAttribute(arguments[0])
    } else if (isObject$1(arguments[0])) {
      forEach(arguments[0], function(value, name) {
        this.setAttribute(name, value);
      }.bind(this));
    }
  } else if (arguments.length === 2) {
    this.setAttribute(arguments[0], arguments[1]);
  }
  return this
};


DOMElement.prototype.removeAttr = function removeAttr (name) {
  var names = name.split(/\s+/);
  if (names.length === 1) {
    this.removeAttribute(name);
  } else {
    names.forEach(function(name) {
      this.removeAttribute(name);
    }.bind(this));
  }
  return this
};


DOMElement.prototype.getAttribute = function getAttribute (name) { 
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.setAttribute = function setAttribute (name, value) { 
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.removeAttribute = function removeAttribute (name) { 
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.getAttributes = function getAttributes () {
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.htmlProp = function htmlProp () {
  if (arguments.length === 1) {
    if (isString$1(arguments[0])) {
      return this.getProperty(arguments[0])
    } else if (isObject$1(arguments[0])) {
      forEach(arguments[0], function(value, name) {
        this.setProperty(name, value);
      }.bind(this));
    }
  } else if (arguments.length === 2) {
    this.setProperty(arguments[0], arguments[1]);
  }
  return this
};

DOMElement.prototype.getProperty = function getProperty (name) { 
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.setProperty = function setProperty (name, value) { 
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.val = function val (value) {
  if (arguments.length === 0) {
    return this.getValue()
  } else {
    this.setValue(value);
    return this
  }
};

DOMElement.prototype.getValue = function getValue () {
  return this.getProperty('value')
};

DOMElement.prototype.setValue = function setValue (value) {
  this.setProperty('value', value);
  return this
};


DOMElement.prototype.css = function css () {
  
  if (arguments.length === 1) {
    
    if (isString$1(arguments[0])) {
      return this.getStyle(arguments[0])
    } else if (isObject$1(arguments[0])) {
      forEach(arguments[0], function(value, name) {
        this.setStyle(name, value);
      }.bind(this));
    } else {
      throw new Error('Illegal arguments.')
    }
  } else if (arguments.length === 2) {
    this.setStyle(arguments[0], arguments[1]);
  } else {
    throw new Error('Illegal arguments.')
  }
  return this
};

DOMElement.prototype.getStyle = function getStyle (name) { 
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.setStyle = function setStyle (name, value) { 
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.text = function text (text$1) {
  if (arguments.length === 0) {
    return this.getTextContent()
  } else {
    this.setTextContent(text$1);
  }
  return this
};


DOMElement.prototype.getTextContent = function getTextContent () {
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.setTextContent = function setTextContent (text) { 
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.html = function html (html$1) {
  if (arguments.length === 0) {
    return this.getInnerHTML()
  } else {
    this.setInnerHTML(html$1);
  }
  return this
};


DOMElement.prototype.getInnerHTML = function getInnerHTML () {
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.setInnerHTML = function setInnerHTML (html) { 
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.getOuterHTML = function getOuterHTML () {
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.on = function on (eventName, handler, context, options) {
  
  if (!isString$1(eventName)) {
    throw new Error('Illegal argument: "event" must be a String.')
  }
  options = options || {};
  if (context) {
    options.context = context;
  }
  
  if (!handler || !isFunction$1(handler)) {
    throw new Error('Illegal argument: invalid handler function for event ' + eventName)
  }
  this.addEventListener(eventName, handler, options);
  return this
};


DOMElement.prototype.off = function off (eventName, handler) {
  
  if (arguments.length === 1 && !isString$1(eventName)) {
    var context = arguments[0];
    this.getEventListeners().filter(function(l) {
      return l.context === context
    }).forEach(function(l) {
      this.removeEventListener(l);
    }.bind(this));
  } else {
    this.removeEventListener(eventName, handler);
  }
  return this
};

DOMElement.prototype.addEventListener = function addEventListener (eventName, handler, options) {
    if ( options === void 0 ) options = {};

  var listener;
  if (arguments.length === 1 && arguments[0]) {
    listener = arguments[0];
  } else {
    listener = this._createEventListener(eventName, handler, options);
  }
  if (!this.eventListeners) {
    this.eventListeners = [];
  }
  listener._el = this;
  this.eventListeners.push(listener);
  this._addEventListenerNative(listener);
  return this
};

DOMElement.prototype._createEventListener = function _createEventListener (eventName, handler, options) {
  return new DOMEventListener(eventName, handler, options)
};

DOMElement.prototype._addEventListenerNative = function _addEventListenerNative (listener) {}; 

DOMElement.prototype.removeEventListener = function removeEventListener (eventName, handler) {
  if (!this.eventListeners) { return }
  
  var listener = null, idx = -1;
  idx = DOMEventListener.findIndex(this.eventListeners, eventName, handler);
  listener = this.eventListeners[idx];
  if (idx > -1) {
    this.eventListeners.splice(idx, 1);
    
    listener._el = null;
    this._removeEventListenerNative(listener);
  }
  return this
};

DOMElement.prototype._removeEventListenerNative = function _removeEventListenerNative (listener) {}; 

DOMElement.prototype.removeAllEventListeners = function removeAllEventListeners () {
    var this$1 = this;

  if (!this.eventListeners) { return }
  for (var i = 0; i < this.eventListeners.length; i++) {
    var listener = this$1.eventListeners[i];
    
    listener._el = null;
    this$1._removeEventListenerNative(listener);
  }
  delete this.eventListeners;
};

DOMElement.prototype.getEventListeners = function getEventListeners () {
  return this.eventListeners || []
};


DOMElement.prototype.getNodeType = function getNodeType () {
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.getContentType = function getContentType () {
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.getChildCount = function getChildCount () {
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.getChildNodes = function getChildNodes () {
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.getChildren = function getChildren () {
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.getChildAt = function getChildAt (pos) { 
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.getChildIndex = function getChildIndex (child) { 
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.getChildNodeIterator = function getChildNodeIterator () {
  return new ArrayIterator(this.getChildNodes())
};

DOMElement.prototype.getLastChild = function getLastChild () {
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.getFirstChild = function getFirstChild () {
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.getNextSibling = function getNextSibling () {
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.getPreviousSibling = function getPreviousSibling () {
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.clone = function clone$$1 () {
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.createElement = function createElement (str) { 
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.createTextNode = function createTextNode (text) { 
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.createComment = function createComment (data) { 
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.createProcessingInstruction = function createProcessingInstruction (name, data) { 
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.createCDATASection = function createCDATASection (data) { 
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.is = function is (cssSelector) { 
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.getParent = function getParent () {
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.getOwnerDocument = function getOwnerDocument () {
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.find = function find$$1 (cssSelector) { 
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.findAll = function findAll (cssSelector) { 
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.append = function append (child) {
  var children;
  if (arguments.length === 1) {
    if (isArray$1(child)) {
      children = child;
    } else {
      this.appendChild(child);
      return this
    }
  } else {
    children = arguments;
  }
  if (children) {
    Array.prototype.forEach.call(children, this.appendChild.bind(this));
  }
  return this
};

DOMElement.prototype.appendChild = function appendChild (child) { 
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.insertAt = function insertAt (pos, child) { 
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.insertBefore = function insertBefore (newChild, before) { 
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.removeAt = function removeAt (pos) { 
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.removeChild = function removeChild (child) { 
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.replaceChild = function replaceChild (oldChild, newChild) { 
  
  throw new Error(NOT_IMPLEMENTED)
};


DOMElement.prototype.remove = function remove () {
  var parent = this.getParent();
  if (parent) {
    parent.removeChild(this);
  }
};


DOMElement.prototype.empty = function empty () {
  
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.serialize = function serialize () {
  return this.getOuterHTML()
};

DOMElement.prototype.isInDocument = function isInDocument () {
  var el = this;
  while(el) {
    if (el.isDocumentNode()) {
      return true
    }
    el = el.getParent();
  }
};


DOMElement.prototype.focus = function focus () {
  
  return this
};


DOMElement.prototype.blur = function blur () {
  
  return this
};


DOMElement.prototype.click = function click () {
  
  return this
};



DOMElement.prototype.getWidth = function getWidth () {
  
  return 0
};

DOMElement.prototype.getHeight = function getHeight () {
  
  return 0
};


DOMElement.prototype.getOuterHeight = function getOuterHeight (withMargin) { 
  
  return 0
};


DOMElement.prototype.getOffset = function getOffset () {
  
  return { top: 0, left: 0 }
};


DOMElement.prototype.getPosition = function getPosition () {
  
  return { top: 0, left: 0 }
};


DOMElement.prototype.getElementFactory = function getElementFactory () {
  return this.createElement.bind(this)
};


DOMElement.prototype.emit = function emit (name, data) { 
  
  throw new Error(NOT_IMPLEMENTED)
};



prototypeAccessors$6.id.get = function () {
  return this.getId()
};

prototypeAccessors$6.id.set = function (id) {
  this.setId(id);
};

prototypeAccessors$6.tagName.get = function () {
  return this.getTagName()
};

prototypeAccessors$6.tagName.set = function (tagName) {
  this.setTagName(tagName);
};

prototypeAccessors$6.nodeName.get = function () {
  return this.getTagName()
};

prototypeAccessors$6.nodeType.get = function () {
  return this.getNodeType()
};

prototypeAccessors$6.className.get = function () {
  return this.getAttribute('class')
};

prototypeAccessors$6.className.set = function (className) {
  this.setAttribute('class', className);
};

prototypeAccessors$6.textContent.get = function () {
  return this.getTextContent()
};

prototypeAccessors$6.textContent.set = function (text) {
  this.setTextContent(text);
};

prototypeAccessors$6.innerHTML.get = function () {
  return this.getInnerHTML()
};

prototypeAccessors$6.innerHTML.set = function (html) {
  this.setInnerHTML(html);
};

prototypeAccessors$6.outerHTML.get = function () {
  return this.getOuterHTML()
};

prototypeAccessors$6.firstChild.get = function () {
  return this.getFirstChild()
};

prototypeAccessors$6.lastChild.get = function () {
  return this.getLastChild()
};

prototypeAccessors$6.nextSibling.get = function () {
  return this.getNextSibling()
};

prototypeAccessors$6.previousSibling.get = function () {
  return this.getPreviousSibling()
};

prototypeAccessors$6.parentNode.get = function () {
  return this.getParent()
};

prototypeAccessors$6.height.get = function () {
  return this.getHeight()
};

prototypeAccessors$6.width.get = function () {
  return this.getWidth()
};

prototypeAccessors$6.value.get = function () {
  return this.getValue()
};

prototypeAccessors$6.value.set = function (value) {
  return this.setValue(value)
};

Object.defineProperties( DOMElement.prototype, prototypeAccessors$6 );

DOMElement.prototype._isDOMElement = true;

DOMElement.pxStyles = {
  top: true,
  bottom: true,
  left: true,
  right: true,
  height: true,
  width: true
};

DOMElement.EMPTY_HTML = '<html><head></head><body></body></html>';

var SIGNATURE = uuid('_BrowserDOMElement');

function _attach(nativeEl, browserDOMElement) {
  nativeEl[SIGNATURE] = browserDOMElement;
}

function _detach(nativeEl) {
  delete nativeEl[SIGNATURE];
}

function _unwrap(nativeEl) {
  return nativeEl[SIGNATURE]
}

var BrowserDOMElement = (function (DOMElement$$1) {
  function BrowserDOMElement(el) {
    DOMElement$$1.call(this);
    console.assert(el instanceof window.Node, "Expecting native DOM node.");
    this.el = el;
    
    
    _attach(el, this);
  }

  if ( DOMElement$$1 ) BrowserDOMElement.__proto__ = DOMElement$$1;
  BrowserDOMElement.prototype = Object.create( DOMElement$$1 && DOMElement$$1.prototype );
  BrowserDOMElement.prototype.constructor = BrowserDOMElement;

  var prototypeAccessors = { childNodes: {},children: {},ownerDocument: {} };

  BrowserDOMElement.prototype.getNativeElement = function getNativeElement () {
    return this.el
  };

  BrowserDOMElement.prototype.getNodeType = function getNodeType () {
    switch(this.el.nodeType) {
      case window.Node.TEXT_NODE:
        return "text"
      case window.Node.ELEMENT_NODE:
        return 'element'
      case window.Node.DOCUMENT_NODE:
        return 'document'
      case window.Node.COMMENT_NODE:
        return 'comment'
      case window.Node.PROCESSING_INSTRUCTION_NODE:
        return 'directive'
      case window.Node.CDATA_SECTION_NODE:
        return 'cdata'
      default:
        
    }
  };

  BrowserDOMElement.prototype.isTextNode = function isTextNode () {
    return (this.el.nodeType === window.Node.TEXT_NODE)
  };

  BrowserDOMElement.prototype.isElementNode = function isElementNode () {
    return (this.el.nodeType === window.Node.ELEMENT_NODE)
  };

  BrowserDOMElement.prototype.isCommentNode = function isCommentNode () {
    return (this.el.nodeType === window.Node.COMMENT_NODE)
  };

  BrowserDOMElement.prototype.isDocumentNode = function isDocumentNode () {
    return (this.el.nodeType === window.Node.DOCUMENT_NODE)
  };

  BrowserDOMElement.prototype.hasClass = function hasClass (className) {
    return this.el.classList.contains(className)
  };

  BrowserDOMElement.prototype.addClass = function addClass (className) {
    this.el.classList.add(className);
    return this
  };

  BrowserDOMElement.prototype.removeClass = function removeClass (className) {
    this.el.classList.remove(className);
    return this
  };

  BrowserDOMElement.prototype.getAttribute = function getAttribute (name) {
    return this.el.getAttribute(name)
  };

  BrowserDOMElement.prototype.setAttribute = function setAttribute (name, value) {
    this.el.setAttribute(name, String(value));
    return this
  };

  BrowserDOMElement.prototype.removeAttribute = function removeAttribute (name) {
    this.el.removeAttribute(name);
    return this
  };

  BrowserDOMElement.prototype.getAttributes = function getAttributes () {
    if (!this.el.attributes._mapAdapter) {
      this.el.attributes._mapAdapter = new AttributesMapAdapter(this.el.attributes);
    }
    return this.el.attributes._mapAdapter
  };

  BrowserDOMElement.prototype.getProperty = function getProperty (name) {
    return this.el[name]
  };

  BrowserDOMElement.prototype.setProperty = function setProperty (name, value) {
    
    
    if (this._isXML()) { throw new Error('setProperty() is only supported for HTML elements.') }
    if (!this._changedProperties) { this._changedProperties = new Set(); }
    
    
    if (value === undefined) {
      this._changedProperties.delete(name);
    } else {
      this._changedProperties.add(name);
    }
    this.el[name] = value;
    return this
  };

  BrowserDOMElement.prototype.getTagName = function getTagName () {
    
    
    if (this._isXML()) {
      return this.el.tagName
    } else if (this.el.tagName) {
      return this.el.tagName.toLowerCase()
    }
  };

  BrowserDOMElement.prototype.setTagName = function setTagName (tagName) {
    var newEl = this.createElement(tagName);
    var attributes = this.el.attributes;
    var l = attributes.length;
    var i;
    for(i = 0; i < l; i++) {
      var attr = attributes.item(i);
      newEl.setAttribute(attr.name, attr.value);
    }
    
    
    
    
    
    
    if (this.eventListeners) {
      this.eventListeners.forEach(function(listener) {
        newEl.addEventListener(listener.eventName, listener.handler, listener.capture);
      });
    }
    newEl.append(this.getChildNodes());

    this._replaceNativeEl(newEl.getNativeElement());
    return this
  };

  BrowserDOMElement.prototype.getId = function getId () {
    return this.el.id
  };

  BrowserDOMElement.prototype.setId = function setId (id) {
    this.el.id = id;
    return this
  };

  BrowserDOMElement.prototype.getStyle = function getStyle (name) {
    
    var style = this.getComputedStyle();
    return style[name] || this.el.style[name]
  };

  BrowserDOMElement.prototype.getComputedStyle = function getComputedStyle () {
    return window.getComputedStyle(this.el)
  };

  BrowserDOMElement.prototype.setStyle = function setStyle (name, value) {
    if (DOMElement$$1.pxStyles[name] && isNumber(value)) { value = value + 'px'; }
    this.el.style[name] = value;
    return this
  };

  BrowserDOMElement.prototype.getTextContent = function getTextContent () {
    return this.el.textContent
  };

  BrowserDOMElement.prototype.setTextContent = function setTextContent (text) {
    this.el.textContent = text;
    return this
  };

  BrowserDOMElement.prototype.getInnerHTML = function getInnerHTML () {
    if (this._isXML()) {
      var xs = new window.XMLSerializer();
      var result = Array.prototype.map.call(this.el.childNodes, function (c) { return xs.serializeToString(c); });
      return result.join('')
    } else {
      return this.el.innerHTML
    }
  };

  BrowserDOMElement.prototype.setInnerHTML = function setInnerHTML (html) {
    
    
    this.el.innerHTML = html;
    return this
  };

  BrowserDOMElement.prototype.getOuterHTML = function getOuterHTML () {
    
    
    if (this._isXML()) {
      var xs = new window.XMLSerializer();
      return xs.serializeToString(this.el)
    } else {
      return this.el.outerHTML
    }
  };

  BrowserDOMElement.prototype._addEventListenerNative = function _addEventListenerNative (listener) {
    this.el.addEventListener(listener.eventName, listener.handler, listener.capture);
  };

  BrowserDOMElement.prototype._removeEventListenerNative = function _removeEventListenerNative (listener) {
    this.el.removeEventListener(listener.eventName, listener.handler);
  };

  BrowserDOMElement.prototype.getEventListeners = function getEventListeners () {
    return this.eventListeners || []
  };

  BrowserDOMElement.prototype.getChildCount = function getChildCount () {
    return this.el.childNodes.length
  };

  BrowserDOMElement.prototype.getChildNodes = function getChildNodes () {
    var childNodes = [];
    for (var node = this.el.firstChild; node; node = node.nextSibling) {
      childNodes.push(BrowserDOMElement.wrap(node));
    }
    return childNodes
  };

  prototypeAccessors.childNodes.get = function () {
    return this.getChildNodes()
  };

  BrowserDOMElement.prototype.getChildren = function getChildren () {
    
    
    var children = [];
    for (var node = this.el.firstChild; node; node = node.nextSibling) {
      if (node.nodeType === window.Node.ELEMENT_NODE) {
        children.push(BrowserDOMElement.wrap(node));
      }
    }
    return children
  };

  prototypeAccessors.children.get = function () {
    return this.getChildren()
  };

  BrowserDOMElement.prototype.getChildAt = function getChildAt (pos) {
    return BrowserDOMElement.wrap(this.el.childNodes[pos])
  };

  BrowserDOMElement.prototype.getChildIndex = function getChildIndex (child) {
    
    if (!child._isBrowserDOMElement) {
      throw new Error('Expecting a BrowserDOMElement instance.')
    }
    return Array.prototype.indexOf.call(this.el.childNodes, child.el)
  };

  BrowserDOMElement.prototype.getFirstChild = function getFirstChild () {
    var firstChild = this.el.firstChild;
    
    if (firstChild) {
      return BrowserDOMElement.wrap(firstChild)
    } else {
      return null
    }
  };

  BrowserDOMElement.prototype.getLastChild = function getLastChild () {
    var lastChild = this.el.lastChild;
    
    if (lastChild) {
      return BrowserDOMElement.wrap(lastChild)
    } else {
      return null
    }
  };

  BrowserDOMElement.prototype.getNextSibling = function getNextSibling () {
    var next = this.el.nextSibling;
    
    if (next) {
      return BrowserDOMElement.wrap(next)
    } else {
      return null
    }
  };

  BrowserDOMElement.prototype.getPreviousSibling = function getPreviousSibling () {
    var previous = this.el.previousSibling;
    
    if (previous) {
      return BrowserDOMElement.wrap(previous)
    } else {
      return null
    }
  };

  BrowserDOMElement.prototype.clone = function clone$$1 () {
    var clone$$1 = this.el.cloneNode(true);
    return BrowserDOMElement.wrap(clone$$1)
  };

  BrowserDOMElement.prototype.createDocument = function createDocument (format) {
    return BrowserDOMElement.createDocument(format)
  };

  BrowserDOMElement.prototype.createElement = function createElement (tagName) {
    var doc = this._getNativeOwnerDocument();
    var el = doc.createElement(tagName);
    return BrowserDOMElement.wrap(el)
  };

  BrowserDOMElement.prototype.createTextNode = function createTextNode (text) {
    var doc = this._getNativeOwnerDocument();
    var el = doc.createTextNode(text);
    return BrowserDOMElement.wrap(el)
  };

  BrowserDOMElement.prototype.createComment = function createComment (data) {
    var doc = this._getNativeOwnerDocument();
    var el = doc.createComment(data);
    return BrowserDOMElement.wrap(el)
  };

  BrowserDOMElement.prototype.createProcessingInstruction = function createProcessingInstruction (name, data) {
    var doc = this._getNativeOwnerDocument();
    var el = doc.createProcessingInstruction(name, data);
    return BrowserDOMElement.wrap(el)
  };

  BrowserDOMElement.prototype.createCDATASection = function createCDATASection (data) {
    var doc = this._getNativeOwnerDocument();
    var el = doc.createCDATASection(data);
    return BrowserDOMElement.wrap(el)
  };

  BrowserDOMElement.prototype.is = function is (cssSelector) {
    
    
    var el = this.el;
    
    if (this.isElementNode()) {
      return matches(el, cssSelector)
    } else {
      return false
    }
  };

  BrowserDOMElement.prototype.getParent = function getParent () {
    var parent = this.el.parentNode;
    
    if (parent) {
      return BrowserDOMElement.wrap(parent)
    } else {
      return null
    }
  };

  BrowserDOMElement.prototype.getOwnerDocument = function getOwnerDocument () {
    return BrowserDOMElement.wrap(this._getNativeOwnerDocument())
  };

  prototypeAccessors.ownerDocument.get = function () {
    return this.getOwnerDocument()
  };

  BrowserDOMElement.prototype._getNativeOwnerDocument = function _getNativeOwnerDocument () {
    return (this.isDocumentNode() ? this.el : this.el.ownerDocument)
  };

  BrowserDOMElement.prototype.find = function find$$1 (cssSelector) {
    var result = null;
    if (this.el.querySelector) {
      result = this.el.querySelector(cssSelector);
    }
    if (result) {
      return BrowserDOMElement.wrap(result)
    } else {
      return null
    }
  };

  BrowserDOMElement.prototype.findAll = function findAll (cssSelector) {
    var result = [];
    if (this.el.querySelectorAll) {
      result = this.el.querySelectorAll(cssSelector);
    }
    return Array.prototype.map.call(result, function(el) {
      return BrowserDOMElement.wrap(el)
    })
  };

  BrowserDOMElement.prototype._normalizeChild = function _normalizeChild (child) {
    if (child instanceof window.Node) {
      child = BrowserDOMElement.wrap(child);
    }
    
    
    
    else if (child._isBrowserDOMElement && ! (child instanceof BrowserDOMElement)) {
      child = BrowserDOMElement.wrap(child);
    } else if (isString$1(child) || isNumber(child)) {
      child = this.createTextNode(child);
    }
    
    if (!child || !child._isBrowserDOMElement) {
      throw new Error('Illegal child type.')
    }
    console.assert(_unwrap(child.el) === child, "The backlink to the wrapper should be consistent");
    return child.getNativeElement()
  };

  BrowserDOMElement.prototype.appendChild = function appendChild (child) {
    var nativeChild = this._normalizeChild(child);
    this.el.appendChild(nativeChild);
    return this
  };

  BrowserDOMElement.prototype.insertAt = function insertAt (pos, child) {
    var nativeChild = this._normalizeChild(child);
    var childNodes = this.el.childNodes;
    if (pos >= childNodes.length) {
      this.el.appendChild(nativeChild);
    } else {
      this.el.insertBefore(nativeChild, childNodes[pos]);
    }
    return this
  };

  BrowserDOMElement.prototype.insertBefore = function insertBefore (child, before) {
    
    if (!before || !before._isBrowserDOMElement) {
      throw new Error('insertBefore(): Illegal arguments. "before" must be a BrowserDOMElement instance.')
    }
    var nativeChild = this._normalizeChild(child);
    this.el.insertBefore(nativeChild, before.el);
    return this
  };

  BrowserDOMElement.prototype.removeAt = function removeAt (pos) {
    this.el.removeChild(this.el.childNodes[pos]);
    return this;
  };

  BrowserDOMElement.prototype.removeChild = function removeChild (child) {
    
    if (!child || !child._isBrowserDOMElement) {
      throw new Error('removeChild(): Illegal arguments. Expecting a BrowserDOMElement instance.')
    }
    this.el.removeChild(child.el);
    return this
  };

  BrowserDOMElement.prototype.replaceChild = function replaceChild (oldChild, newChild) {
    
    if (!newChild || !oldChild ||
        !newChild._isBrowserDOMElement || !oldChild._isBrowserDOMElement) {
      throw new Error('replaceChild(): Illegal arguments. Expecting BrowserDOMElement instances.')
    }
    
    this.el.replaceChild(newChild.el, oldChild.el);
    return this
  };

  BrowserDOMElement.prototype.empty = function empty () {
    var el = this.el;
    while (el.lastChild) {
      el.removeChild(el.lastChild);
    }
    return this
  };

  BrowserDOMElement.prototype.remove = function remove () {
    if (this.el.parentNode) {
      this.el.parentNode.removeChild(this.el);
    }
    return this
  };

  BrowserDOMElement.prototype.serialize = function serialize () {
    var outerHTML = this.el.outerHTML;
    if (isString$1(outerHTML)) {
      return outerHTML
    } else {
      var xs = new window.XMLSerializer();
      return xs.serializeToString(this.el)
    }
  };

  BrowserDOMElement.prototype.isInDocument = function isInDocument () {
    var el = this.el;
    while(el) {
      if (el.nodeType === window.Node.DOCUMENT_NODE) {
        return true
      }
      el = el.parentNode;
    }
  };

  BrowserDOMElement.prototype._replaceNativeEl = function _replaceNativeEl (newEl) {
    console.assert(newEl instanceof window.Node, "Expecting a native element.");
    var oldEl = this.el;
    var parentNode = oldEl.parentNode;
    if (parentNode) {
      parentNode.replaceChild(newEl, oldEl);
    }
    this.el = newEl;
    _detach(oldEl);
    _attach(newEl, this);
  };

  BrowserDOMElement.prototype._getChildNodeCount = function _getChildNodeCount () {
    return this.el.childNodes.length
  };

  BrowserDOMElement.prototype.focus = function focus () {
    this.el.focus();
    return this
  };

  BrowserDOMElement.prototype.blur = function blur () {
    this.el.focus();
    return this
  };

  BrowserDOMElement.prototype.click = function click () {
    this.el.click();
    return this
  };

  BrowserDOMElement.prototype.getWidth = function getWidth () {
    var rect = this.el.getClientRects()[0];
    if (rect) {
      return rect.width
    } else {
      return 0
    }
  };

  BrowserDOMElement.prototype.getHeight = function getHeight () {
    var rect = this.el.getClientRects()[0];
    if (rect) {
      return rect.height
    } else {
      return 0
    }
  };

  BrowserDOMElement.prototype.getOffset = function getOffset () {
    var rect = this.el.getBoundingClientRect();
    return {
      top: rect.top + document.body.scrollTop,
      left: rect.left + document.body.scrollLeft
    }
  };

  BrowserDOMElement.prototype.getPosition = function getPosition () {
    return {left: this.el.offsetLeft, top: this.el.offsetTop}
  };

  BrowserDOMElement.prototype.getOuterHeight = function getOuterHeight (withMargin) {
    var outerHeight = this.el.offsetHeight;
    if (withMargin) {
      var style = this.getComputedStyle();
      outerHeight += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
    }
    return outerHeight
  };

  BrowserDOMElement.prototype.getContentType = function getContentType () {
    return this._getNativeOwnerDocument().contentType
  };

  BrowserDOMElement.prototype._isXML = function _isXML () {
    return this.getContentType() === 'application/xml'
  };

  BrowserDOMElement.prototype.emit = function emit (name, data) {
    var event;
    if (data) {
      event = new window.CustomEvent(name, { detail: data });
    } else {
      event = new window.Event(name);
    }
    this.el.dispatchEvent(event);
  };

  Object.defineProperties( BrowserDOMElement.prototype, prototypeAccessors );

  return BrowserDOMElement;
}(DOMElement));

BrowserDOMElement.prototype._isBrowserDOMElement = true;


BrowserDOMElement.createDocument = function(format) {
  var doc;
  if (format === 'xml') {
    
    doc = window.document.implementation.createDocument(null, 'dummy');
    
    doc.removeChild(doc.firstChild);
  } else {
    doc = (new window.DOMParser()).parseFromString(DOMElement.EMPTY_HTML, 'text/html');
  }
  return BrowserDOMElement.wrap(doc)
};

BrowserDOMElement.parseMarkup = function(str, format, options) {
  if ( options === void 0 ) options={};

  if (!str) {
    return BrowserDOMElement.createDocument(format)
  }
  if (options.snippet) {
    str = "<div id='__snippet__'>" + str + "</div>";
  }
  var doc;
  var parser = new window.DOMParser();
  if (format === 'html') {
    doc = BrowserDOMElement.wrap(
      _check(
        parser.parseFromString(str, 'text/html')
      )
    );
  } else if (format === 'xml') {
    doc = BrowserDOMElement.wrap(
      _check(
        parser.parseFromString(str, 'text/xml')
      )
    );
  }
  if (options.snippet) {
    var childNodes = doc.find('#__snippet__').childNodes;
    if (childNodes.length === 1) {
      return childNodes[0]
    } else {
      return childNodes
    }
  } else {
    return doc
  }

  function _check(doc) {
    if (doc) {
      var parserError = doc.querySelector('parsererror');
      if (parserError) {
        throw new Error("ParserError: " + parserError)
      }
    }
    return doc
  }
};

BrowserDOMElement.wrap =
BrowserDOMElement.wrapNativeElement = function(el) {
  if (el) {
    var _el = _unwrap(el);
    if (_el) {
      return _el
    } else if (el instanceof window.Node) {
      return new BrowserDOMElement(el)
    } else if (el._isBrowserDOMElement) {
      return new BrowserDOMElement(el.getNativeElement())
    } else if (el === window) {
      return BrowserDOMElement.getBrowserWindow()
    }
  } else {
    return null
  }
};

BrowserDOMElement.unwrap = function(nativeEl) {
  return _unwrap(nativeEl)
};


var BrowserWindow = function BrowserWindow() {
  
  this.el = window;
  window.__BrowserDOMElementWrapper__ = this;
};

BrowserWindow.prototype.on = BrowserDOMElement.prototype.on;
BrowserWindow.prototype.off = BrowserDOMElement.prototype.off;
BrowserWindow.prototype.addEventListener = BrowserDOMElement.prototype.addEventListener;
BrowserWindow.prototype.removeEventListener = BrowserDOMElement.prototype.removeEventListener;
BrowserWindow.prototype._createEventListener = BrowserDOMElement.prototype._createEventListener;
BrowserWindow.prototype._addEventListenerNative = BrowserDOMElement.prototype._addEventListenerNative;
BrowserWindow.prototype._removeEventListenerNative = BrowserDOMElement.prototype._removeEventListenerNative;

BrowserWindow.prototype.getEventListeners = BrowserDOMElement.prototype.getEventListeners;

BrowserDOMElement.getBrowserWindow = function() {
  if (window[SIGNATURE]) { return window[SIGNATURE] }
  return new BrowserWindow(window)
};

BrowserDOMElement.isReverse = function(anchorNode, anchorOffset, focusNode, focusOffset) {
  
  
  if (focusNode && anchorNode) {
    if (!BrowserDOMElement.isReverse._r1) {
      BrowserDOMElement.isReverse._r1 = window.document.createRange();
      BrowserDOMElement.isReverse._r2 = window.document.createRange();
    }
    var _r1 = BrowserDOMElement.isReverse._r1;
    var _r2 = BrowserDOMElement.isReverse._r2;
    _r1.setStart(anchorNode.getNativeElement(), anchorOffset);
    _r2.setStart(focusNode.getNativeElement(), focusOffset);
    var cmp = _r1.compareBoundaryPoints(window.Range.START_TO_START, _r2);
    if (cmp === 1) {
      return true
    }
  }
  return false
};

BrowserDOMElement.getWindowSelection = function() {
  var nativeSel = window.getSelection();
  var result = {
    anchorNode: BrowserDOMElement.wrap(nativeSel.anchorNode),
    anchorOffset: nativeSel.anchorOffset,
    focusNode: BrowserDOMElement.wrap(nativeSel.focusNode),
    focusOffset: nativeSel.focusOffset
  };
  return result
};


function matches(el, selector) {
  var elProto = window.Element.prototype;
  var _matches = (
    elProto.matches || elProto.matchesSelector ||
    elProto.msMatchesSelector || elProto.webkitMatchesSelector
  );
  return _matches.call(el, selector)
}

var AttributesMapAdapter = function AttributesMapAdapter(attributes) {
  this.attributes = attributes;
};

var prototypeAccessors$1$1 = { size: {} };

prototypeAccessors$1$1.size.get = function () {
  return this.attributes.length
};

AttributesMapAdapter.prototype.get = function get (name) {
  var item = this.attributes.getNamedItem(name);
  if (item) {
    return item.value
  }
};

AttributesMapAdapter.prototype.entries = function entries () {
    var this$1 = this;

  var entries = [];
  var S = this.size;
  for (var i = 0; i < S; i++) {
    var item = this$1.attributes.item(i);
    entries.push([item.name, item.value]);
  }
  return entries
};

AttributesMapAdapter.prototype.set = function set () {
  throw new Error('This is a read-only map.')
};

Object.defineProperties( AttributesMapAdapter.prototype, prototypeAccessors$1$1 );

var index = {
	Text: "text", 
	Directive: "directive", 
	Comment: "comment", 
	Script: "script", 
	Style: "style", 
	Tag: "tag", 
	CDATA: "cdata", 
	Doctype: "doctype",

	isTag: function(elem){
		return elem.type === "tag" || elem.type === "script" || elem.type === "style";
	}
};

var amp = "&";
var apos = "'";
var gt = ">";
var lt = "<";
var quot = "\"";
var xmlJSON = {
	amp: amp,
	apos: apos,
	gt: gt,
	lt: lt,
	quot: quot
};

var xml = Object.freeze({
	amp: amp,
	apos: apos,
	gt: gt,
	lt: lt,
	quot: quot,
	default: xmlJSON
});

var Aacute = "";
var aacute = "";
var Abreve = "";
var abreve = "";
var ac = "";
var acd = "";
var acE = "";
var Acirc = "";
var acirc = "";
var acute = "";
var Acy = "";
var acy = "";
var AElig = "";
var aelig = "";
var af = "";
var Afr = "";
var afr = "";
var Agrave = "";
var agrave = "";
var alefsym = "";
var aleph = "";
var Alpha = "";
var alpha = "";
var Amacr = "";
var amacr = "";
var amalg = "";
var amp$1 = "&";
var AMP = "&";
var andand = "";
var And = "";
var and = "";
var andd = "";
var andslope = "";
var andv = "";
var ang = "";
var ange = "";
var angle = "";
var angmsdaa = "";
var angmsdab = "";
var angmsdac = "";
var angmsdad = "";
var angmsdae = "";
var angmsdaf = "";
var angmsdag = "";
var angmsdah = "";
var angmsd = "";
var angrt = "";
var angrtvb = "";
var angrtvbd = "";
var angsph = "";
var angst = "";
var angzarr = "";
var Aogon = "";
var aogon = "";
var Aopf = "";
var aopf = "";
var apacir = "";
var ap = "";
var apE = "";
var ape = "";
var apid = "";
var apos$1 = "'";
var ApplyFunction = "";
var approx = "";
var approxeq = "";
var Aring = "";
var aring = "";
var Ascr = "";
var ascr = "";
var Assign = "";
var ast = "*";
var asymp = "";
var asympeq = "";
var Atilde = "";
var atilde = "";
var Auml = "";
var auml = "";
var awconint = "";
var awint = "";
var backcong = "";
var backepsilon = "";
var backprime = "";
var backsim = "";
var backsimeq = "";
var Backslash = "";
var Barv = "";
var barvee = "";
var barwed = "";
var Barwed = "";
var barwedge = "";
var bbrk = "";
var bbrktbrk = "";
var bcong = "";
var Bcy = "";
var bcy = "";
var bdquo = "";
var becaus = "";
var because = "";
var Because = "";
var bemptyv = "";
var bepsi = "";
var bernou = "";
var Bernoullis = "";
var Beta = "";
var beta = "";
var beth = "";
var between = "";
var Bfr = "";
var bfr = "";
var bigcap = "";
var bigcirc = "";
var bigcup = "";
var bigodot = "";
var bigoplus = "";
var bigotimes = "";
var bigsqcup = "";
var bigstar = "";
var bigtriangledown = "";
var bigtriangleup = "";
var biguplus = "";
var bigvee = "";
var bigwedge = "";
var bkarow = "";
var blacklozenge = "";
var blacksquare = "";
var blacktriangle = "";
var blacktriangledown = "";
var blacktriangleleft = "";
var blacktriangleright = "";
var blank = "";
var blk12 = "";
var blk14 = "";
var blk34 = "";
var block = "";
var bne = "=";
var bnequiv = "";
var bNot = "";
var bnot = "";
var Bopf = "";
var bopf = "";
var bot = "";
var bottom = "";
var bowtie = "";
var boxbox = "";
var boxdl = "";
var boxdL = "";
var boxDl = "";
var boxDL = "";
var boxdr = "";
var boxdR = "";
var boxDr = "";
var boxDR = "";
var boxh = "";
var boxH = "";
var boxhd = "";
var boxHd = "";
var boxhD = "";
var boxHD = "";
var boxhu = "";
var boxHu = "";
var boxhU = "";
var boxHU = "";
var boxminus = "";
var boxplus = "";
var boxtimes = "";
var boxul = "";
var boxuL = "";
var boxUl = "";
var boxUL = "";
var boxur = "";
var boxuR = "";
var boxUr = "";
var boxUR = "";
var boxv = "";
var boxV = "";
var boxvh = "";
var boxvH = "";
var boxVh = "";
var boxVH = "";
var boxvl = "";
var boxvL = "";
var boxVl = "";
var boxVL = "";
var boxvr = "";
var boxvR = "";
var boxVr = "";
var boxVR = "";
var bprime = "";
var breve = "";
var Breve = "";
var brvbar = "";
var bscr = "";
var Bscr = "";
var bsemi = "";
var bsim = "";
var bsime = "";
var bsolb = "";
var bsol = "\\";
var bsolhsub = "";
var bull = "";
var bullet = "";
var bump = "";
var bumpE = "";
var bumpe = "";
var Bumpeq = "";
var bumpeq = "";
var Cacute = "";
var cacute = "";
var capand = "";
var capbrcup = "";
var capcap = "";
var cap = "";
var Cap = "";
var capcup = "";
var capdot = "";
var CapitalDifferentialD = "";
var caps = "";
var caret = "";
var caron = "";
var Cayleys = "";
var ccaps = "";
var Ccaron = "";
var ccaron = "";
var Ccedil = "";
var ccedil = "";
var Ccirc = "";
var ccirc = "";
var Cconint = "";
var ccups = "";
var ccupssm = "";
var Cdot = "";
var cdot = "";
var cedil = "";
var Cedilla = "";
var cemptyv = "";
var cent = "";
var centerdot = "";
var CenterDot = "";
var cfr = "";
var Cfr = "";
var CHcy = "";
var chcy = "";
var check = "";
var checkmark = "";
var Chi = "";
var chi = "";
var circ = "";
var circeq = "";
var circlearrowleft = "";
var circlearrowright = "";
var circledast = "";
var circledcirc = "";
var circleddash = "";
var CircleDot = "";
var circledR = "";
var circledS = "";
var CircleMinus = "";
var CirclePlus = "";
var CircleTimes = "";
var cir = "";
var cirE = "";
var cire = "";
var cirfnint = "";
var cirmid = "";
var cirscir = "";
var ClockwiseContourIntegral = "";
var CloseCurlyDoubleQuote = "";
var CloseCurlyQuote = "";
var clubs = "";
var clubsuit = "";
var colon = ":";
var Colon = "";
var Colone = "";
var colone = "";
var coloneq = "";
var comma = ",";
var commat = "@";
var comp = "";
var compfn = "";
var complement = "";
var complexes = "";
var cong = "";
var congdot = "";
var Congruent = "";
var conint = "";
var Conint = "";
var ContourIntegral = "";
var copf = "";
var Copf = "";
var coprod = "";
var Coproduct = "";
var copy = "";
var COPY = "";
var copysr = "";
var CounterClockwiseContourIntegral = "";
var crarr = "";
var cross = "";
var Cross = "";
var Cscr = "";
var cscr = "";
var csub = "";
var csube = "";
var csup = "";
var csupe = "";
var ctdot = "";
var cudarrl = "";
var cudarrr = "";
var cuepr = "";
var cuesc = "";
var cularr = "";
var cularrp = "";
var cupbrcap = "";
var cupcap = "";
var CupCap = "";
var cup = "";
var Cup = "";
var cupcup = "";
var cupdot = "";
var cupor = "";
var cups = "";
var curarr = "";
var curarrm = "";
var curlyeqprec = "";
var curlyeqsucc = "";
var curlyvee = "";
var curlywedge = "";
var curren = "";
var curvearrowleft = "";
var curvearrowright = "";
var cuvee = "";
var cuwed = "";
var cwconint = "";
var cwint = "";
var cylcty = "";
var dagger = "";
var Dagger = "";
var daleth = "";
var darr = "";
var Darr = "";
var dArr = "";
var dash = "";
var Dashv = "";
var dashv = "";
var dbkarow = "";
var dblac = "";
var Dcaron = "";
var dcaron = "";
var Dcy = "";
var dcy = "";
var ddagger = "";
var ddarr = "";
var DD = "";
var dd = "";
var DDotrahd = "";
var ddotseq = "";
var deg = "";
var Del = "";
var Delta = "";
var delta = "";
var demptyv = "";
var dfisht = "";
var Dfr = "";
var dfr = "";
var dHar = "";
var dharl = "";
var dharr = "";
var DiacriticalAcute = "";
var DiacriticalDot = "";
var DiacriticalDoubleAcute = "";
var DiacriticalGrave = "`";
var DiacriticalTilde = "";
var diam = "";
var diamond = "";
var Diamond = "";
var diamondsuit = "";
var diams = "";
var die = "";
var DifferentialD = "";
var digamma = "";
var disin = "";
var div = "";
var divide = "";
var divideontimes = "";
var divonx = "";
var DJcy = "";
var djcy = "";
var dlcorn = "";
var dlcrop = "";
var dollar = "$";
var Dopf = "";
var dopf = "";
var Dot = "";
var dot = "";
var DotDot = "";
var doteq = "";
var doteqdot = "";
var DotEqual = "";
var dotminus = "";
var dotplus = "";
var dotsquare = "";
var doublebarwedge = "";
var DoubleContourIntegral = "";
var DoubleDot = "";
var DoubleDownArrow = "";
var DoubleLeftArrow = "";
var DoubleLeftRightArrow = "";
var DoubleLeftTee = "";
var DoubleLongLeftArrow = "";
var DoubleLongLeftRightArrow = "";
var DoubleLongRightArrow = "";
var DoubleRightArrow = "";
var DoubleRightTee = "";
var DoubleUpArrow = "";
var DoubleUpDownArrow = "";
var DoubleVerticalBar = "";
var DownArrowBar = "";
var downarrow = "";
var DownArrow = "";
var Downarrow = "";
var DownArrowUpArrow = "";
var DownBreve = "";
var downdownarrows = "";
var downharpoonleft = "";
var downharpoonright = "";
var DownLeftRightVector = "";
var DownLeftTeeVector = "";
var DownLeftVectorBar = "";
var DownLeftVector = "";
var DownRightTeeVector = "";
var DownRightVectorBar = "";
var DownRightVector = "";
var DownTeeArrow = "";
var DownTee = "";
var drbkarow = "";
var drcorn = "";
var drcrop = "";
var Dscr = "";
var dscr = "";
var DScy = "";
var dscy = "";
var dsol = "";
var Dstrok = "";
var dstrok = "";
var dtdot = "";
var dtri = "";
var dtrif = "";
var duarr = "";
var duhar = "";
var dwangle = "";
var DZcy = "";
var dzcy = "";
var dzigrarr = "";
var Eacute = "";
var eacute = "";
var easter = "";
var Ecaron = "";
var ecaron = "";
var Ecirc = "";
var ecirc = "";
var ecir = "";
var ecolon = "";
var Ecy = "";
var ecy = "";
var eDDot = "";
var Edot = "";
var edot = "";
var eDot = "";
var ee = "";
var efDot = "";
var Efr = "";
var efr = "";
var eg = "";
var Egrave = "";
var egrave = "";
var egs = "";
var egsdot = "";
var el = "";
var Element = "";
var elinters = "";
var ell = "";
var els = "";
var elsdot = "";
var Emacr = "";
var emacr = "";
var empty = "";
var emptyset = "";
var EmptySmallSquare = "";
var emptyv = "";
var EmptyVerySmallSquare = "";
var emsp13 = "";
var emsp14 = "";
var emsp = "";
var ENG = "";
var eng = "";
var ensp = "";
var Eogon = "";
var eogon = "";
var Eopf = "";
var eopf = "";
var epar = "";
var eparsl = "";
var eplus = "";
var epsi = "";
var Epsilon = "";
var epsilon = "";
var epsiv = "";
var eqcirc = "";
var eqcolon = "";
var eqsim = "";
var eqslantgtr = "";
var eqslantless = "";
var Equal = "";
var equals = "=";
var EqualTilde = "";
var equest = "";
var Equilibrium = "";
var equiv = "";
var equivDD = "";
var eqvparsl = "";
var erarr = "";
var erDot = "";
var escr = "";
var Escr = "";
var esdot = "";
var Esim = "";
var esim = "";
var Eta = "";
var eta = "";
var ETH = "";
var eth = "";
var Euml = "";
var euml = "";
var euro = "";
var excl = "!";
var exist = "";
var Exists = "";
var expectation = "";
var exponentiale = "";
var ExponentialE = "";
var fallingdotseq = "";
var Fcy = "";
var fcy = "";
var female = "";
var ffilig = "";
var fflig = "";
var ffllig = "";
var Ffr = "";
var ffr = "";
var filig = "";
var FilledSmallSquare = "";
var FilledVerySmallSquare = "";
var fjlig = "fj";
var flat = "";
var fllig = "";
var fltns = "";
var fnof = "";
var Fopf = "";
var fopf = "";
var forall = "";
var ForAll = "";
var fork = "";
var forkv = "";
var Fouriertrf = "";
var fpartint = "";
var frac12 = "";
var frac13 = "";
var frac14 = "";
var frac15 = "";
var frac16 = "";
var frac18 = "";
var frac23 = "";
var frac25 = "";
var frac34 = "";
var frac35 = "";
var frac38 = "";
var frac45 = "";
var frac56 = "";
var frac58 = "";
var frac78 = "";
var frasl = "";
var frown = "";
var fscr = "";
var Fscr = "";
var gacute = "";
var Gamma = "";
var gamma = "";
var Gammad = "";
var gammad = "";
var gap = "";
var Gbreve = "";
var gbreve = "";
var Gcedil = "";
var Gcirc = "";
var gcirc = "";
var Gcy = "";
var gcy = "";
var Gdot = "";
var gdot = "";
var ge = "";
var gE = "";
var gEl = "";
var gel = "";
var geq = "";
var geqq = "";
var geqslant = "";
var gescc = "";
var ges = "";
var gesdot = "";
var gesdoto = "";
var gesdotol = "";
var gesl = "";
var gesles = "";
var Gfr = "";
var gfr = "";
var gg = "";
var Gg = "";
var ggg = "";
var gimel = "";
var GJcy = "";
var gjcy = "";
var gla = "";
var gl = "";
var glE = "";
var glj = "";
var gnap = "";
var gnapprox = "";
var gne = "";
var gnE = "";
var gneq = "";
var gneqq = "";
var gnsim = "";
var Gopf = "";
var gopf = "";
var grave = "`";
var GreaterEqual = "";
var GreaterEqualLess = "";
var GreaterFullEqual = "";
var GreaterGreater = "";
var GreaterLess = "";
var GreaterSlantEqual = "";
var GreaterTilde = "";
var Gscr = "";
var gscr = "";
var gsim = "";
var gsime = "";
var gsiml = "";
var gtcc = "";
var gtcir = "";
var gt$1 = ">";
var GT = ">";
var Gt = "";
var gtdot = "";
var gtlPar = "";
var gtquest = "";
var gtrapprox = "";
var gtrarr = "";
var gtrdot = "";
var gtreqless = "";
var gtreqqless = "";
var gtrless = "";
var gtrsim = "";
var gvertneqq = "";
var gvnE = "";
var Hacek = "";
var hairsp = "";
var half = "";
var hamilt = "";
var HARDcy = "";
var hardcy = "";
var harrcir = "";
var harr = "";
var hArr = "";
var harrw = "";
var Hat = "^";
var hbar = "";
var Hcirc = "";
var hcirc = "";
var hearts = "";
var heartsuit = "";
var hellip = "";
var hercon = "";
var hfr = "";
var Hfr = "";
var HilbertSpace = "";
var hksearow = "";
var hkswarow = "";
var hoarr = "";
var homtht = "";
var hookleftarrow = "";
var hookrightarrow = "";
var hopf = "";
var Hopf = "";
var horbar = "";
var HorizontalLine = "";
var hscr = "";
var Hscr = "";
var hslash = "";
var Hstrok = "";
var hstrok = "";
var HumpDownHump = "";
var HumpEqual = "";
var hybull = "";
var hyphen = "";
var Iacute = "";
var iacute = "";
var ic = "";
var Icirc = "";
var icirc = "";
var Icy = "";
var icy = "";
var Idot = "";
var IEcy = "";
var iecy = "";
var iexcl = "";
var iff = "";
var ifr = "";
var Ifr = "";
var Igrave = "";
var igrave = "";
var ii = "";
var iiiint = "";
var iiint = "";
var iinfin = "";
var iiota = "";
var IJlig = "";
var ijlig = "";
var Imacr = "";
var imacr = "";
var image = "";
var ImaginaryI = "";
var imagline = "";
var imagpart = "";
var imath = "";
var Im = "";
var imof = "";
var imped = "";
var Implies = "";
var incare = "";
var infin = "";
var infintie = "";
var inodot = "";
var intcal = "";
var int = "";
var Int = "";
var integers = "";
var Integral = "";
var intercal = "";
var Intersection = "";
var intlarhk = "";
var intprod = "";
var InvisibleComma = "";
var InvisibleTimes = "";
var IOcy = "";
var iocy = "";
var Iogon = "";
var iogon = "";
var Iopf = "";
var iopf = "";
var Iota = "";
var iota = "";
var iprod = "";
var iquest = "";
var iscr = "";
var Iscr = "";
var isin = "";
var isindot = "";
var isinE = "";
var isins = "";
var isinsv = "";
var isinv = "";
var it = "";
var Itilde = "";
var itilde = "";
var Iukcy = "";
var iukcy = "";
var Iuml = "";
var iuml = "";
var Jcirc = "";
var jcirc = "";
var Jcy = "";
var jcy = "";
var Jfr = "";
var jfr = "";
var jmath = "";
var Jopf = "";
var jopf = "";
var Jscr = "";
var jscr = "";
var Jsercy = "";
var jsercy = "";
var Jukcy = "";
var jukcy = "";
var Kappa = "";
var kappa = "";
var kappav = "";
var Kcedil = "";
var kcedil = "";
var Kcy = "";
var kcy = "";
var Kfr = "";
var kfr = "";
var kgreen = "";
var KHcy = "";
var khcy = "";
var KJcy = "";
var kjcy = "";
var Kopf = "";
var kopf = "";
var Kscr = "";
var kscr = "";
var lAarr = "";
var Lacute = "";
var lacute = "";
var laemptyv = "";
var lagran = "";
var Lambda = "";
var lambda = "";
var lang = "";
var Lang = "";
var langd = "";
var langle = "";
var lap = "";
var Laplacetrf = "";
var laquo = "";
var larrb = "";
var larrbfs = "";
var larr = "";
var Larr = "";
var lArr = "";
var larrfs = "";
var larrhk = "";
var larrlp = "";
var larrpl = "";
var larrsim = "";
var larrtl = "";
var latail = "";
var lAtail = "";
var lat = "";
var late = "";
var lates = "";
var lbarr = "";
var lBarr = "";
var lbbrk = "";
var lbrace = "{";
var lbrack = "[";
var lbrke = "";
var lbrksld = "";
var lbrkslu = "";
var Lcaron = "";
var lcaron = "";
var Lcedil = "";
var lcedil = "";
var lceil = "";
var lcub = "{";
var Lcy = "";
var lcy = "";
var ldca = "";
var ldquo = "";
var ldquor = "";
var ldrdhar = "";
var ldrushar = "";
var ldsh = "";
var le = "";
var lE = "";
var LeftAngleBracket = "";
var LeftArrowBar = "";
var leftarrow = "";
var LeftArrow = "";
var Leftarrow = "";
var LeftArrowRightArrow = "";
var leftarrowtail = "";
var LeftCeiling = "";
var LeftDoubleBracket = "";
var LeftDownTeeVector = "";
var LeftDownVectorBar = "";
var LeftDownVector = "";
var LeftFloor = "";
var leftharpoondown = "";
var leftharpoonup = "";
var leftleftarrows = "";
var leftrightarrow = "";
var LeftRightArrow = "";
var Leftrightarrow = "";
var leftrightarrows = "";
var leftrightharpoons = "";
var leftrightsquigarrow = "";
var LeftRightVector = "";
var LeftTeeArrow = "";
var LeftTee = "";
var LeftTeeVector = "";
var leftthreetimes = "";
var LeftTriangleBar = "";
var LeftTriangle = "";
var LeftTriangleEqual = "";
var LeftUpDownVector = "";
var LeftUpTeeVector = "";
var LeftUpVectorBar = "";
var LeftUpVector = "";
var LeftVectorBar = "";
var LeftVector = "";
var lEg = "";
var leg = "";
var leq = "";
var leqq = "";
var leqslant = "";
var lescc = "";
var les = "";
var lesdot = "";
var lesdoto = "";
var lesdotor = "";
var lesg = "";
var lesges = "";
var lessapprox = "";
var lessdot = "";
var lesseqgtr = "";
var lesseqqgtr = "";
var LessEqualGreater = "";
var LessFullEqual = "";
var LessGreater = "";
var lessgtr = "";
var LessLess = "";
var lesssim = "";
var LessSlantEqual = "";
var LessTilde = "";
var lfisht = "";
var lfloor = "";
var Lfr = "";
var lfr = "";
var lg = "";
var lgE = "";
var lHar = "";
var lhard = "";
var lharu = "";
var lharul = "";
var lhblk = "";
var LJcy = "";
var ljcy = "";
var llarr = "";
var ll = "";
var Ll = "";
var llcorner = "";
var Lleftarrow = "";
var llhard = "";
var lltri = "";
var Lmidot = "";
var lmidot = "";
var lmoustache = "";
var lmoust = "";
var lnap = "";
var lnapprox = "";
var lne = "";
var lnE = "";
var lneq = "";
var lneqq = "";
var lnsim = "";
var loang = "";
var loarr = "";
var lobrk = "";
var longleftarrow = "";
var LongLeftArrow = "";
var Longleftarrow = "";
var longleftrightarrow = "";
var LongLeftRightArrow = "";
var Longleftrightarrow = "";
var longmapsto = "";
var longrightarrow = "";
var LongRightArrow = "";
var Longrightarrow = "";
var looparrowleft = "";
var looparrowright = "";
var lopar = "";
var Lopf = "";
var lopf = "";
var loplus = "";
var lotimes = "";
var lowast = "";
var lowbar = "_";
var LowerLeftArrow = "";
var LowerRightArrow = "";
var loz = "";
var lozenge = "";
var lozf = "";
var lpar = "(";
var lparlt = "";
var lrarr = "";
var lrcorner = "";
var lrhar = "";
var lrhard = "";
var lrm = "";
var lrtri = "";
var lsaquo = "";
var lscr = "";
var Lscr = "";
var lsh = "";
var Lsh = "";
var lsim = "";
var lsime = "";
var lsimg = "";
var lsqb = "[";
var lsquo = "";
var lsquor = "";
var Lstrok = "";
var lstrok = "";
var ltcc = "";
var ltcir = "";
var lt$1 = "<";
var LT = "<";
var Lt = "";
var ltdot = "";
var lthree = "";
var ltimes = "";
var ltlarr = "";
var ltquest = "";
var ltri = "";
var ltrie = "";
var ltrif = "";
var ltrPar = "";
var lurdshar = "";
var luruhar = "";
var lvertneqq = "";
var lvnE = "";
var macr = "";
var male = "";
var malt = "";
var maltese = "";
var map$1 = "";
var mapsto = "";
var mapstodown = "";
var mapstoleft = "";
var mapstoup = "";
var marker = "";
var mcomma = "";
var Mcy = "";
var mcy = "";
var mdash = "";
var mDDot = "";
var measuredangle = "";
var MediumSpace = "";
var Mellintrf = "";
var Mfr = "";
var mfr = "";
var mho = "";
var micro = "";
var midast = "*";
var midcir = "";
var mid = "";
var middot = "";
var minusb = "";
var minus = "";
var minusd = "";
var minusdu = "";
var MinusPlus = "";
var mlcp = "";
var mldr = "";
var mnplus = "";
var models = "";
var Mopf = "";
var mopf = "";
var mp = "";
var mscr = "";
var Mscr = "";
var mstpos = "";
var Mu = "";
var mu = "";
var multimap = "";
var mumap = "";
var nabla = "";
var Nacute = "";
var nacute = "";
var nang = "";
var nap = "";
var napE = "";
var napid = "";
var napos = "";
var napprox = "";
var natural = "";
var naturals = "";
var natur = "";
var nbsp = "";
var nbump = "";
var nbumpe = "";
var ncap = "";
var Ncaron = "";
var ncaron = "";
var Ncedil = "";
var ncedil = "";
var ncong = "";
var ncongdot = "";
var ncup = "";
var Ncy = "";
var ncy = "";
var ndash = "";
var nearhk = "";
var nearr = "";
var neArr = "";
var nearrow = "";
var ne = "";
var nedot = "";
var NegativeMediumSpace = "";
var NegativeThickSpace = "";
var NegativeThinSpace = "";
var NegativeVeryThinSpace = "";
var nequiv = "";
var nesear = "";
var nesim = "";
var NestedGreaterGreater = "";
var NestedLessLess = "";
var NewLine = "\n";
var nexist = "";
var nexists = "";
var Nfr = "";
var nfr = "";
var ngE = "";
var nge = "";
var ngeq = "";
var ngeqq = "";
var ngeqslant = "";
var nges = "";
var nGg = "";
var ngsim = "";
var nGt = "";
var ngt = "";
var ngtr = "";
var nGtv = "";
var nharr = "";
var nhArr = "";
var nhpar = "";
var ni = "";
var nis = "";
var nisd = "";
var niv = "";
var NJcy = "";
var njcy = "";
var nlarr = "";
var nlArr = "";
var nldr = "";
var nlE = "";
var nle = "";
var nleftarrow = "";
var nLeftarrow = "";
var nleftrightarrow = "";
var nLeftrightarrow = "";
var nleq = "";
var nleqq = "";
var nleqslant = "";
var nles = "";
var nless = "";
var nLl = "";
var nlsim = "";
var nLt = "";
var nlt = "";
var nltri = "";
var nltrie = "";
var nLtv = "";
var nmid = "";
var NoBreak = "";
var NonBreakingSpace = "";
var nopf = "";
var Nopf = "";
var Not = "";
var not = "";
var NotCongruent = "";
var NotCupCap = "";
var NotDoubleVerticalBar = "";
var NotElement = "";
var NotEqual = "";
var NotEqualTilde = "";
var NotExists = "";
var NotGreater = "";
var NotGreaterEqual = "";
var NotGreaterFullEqual = "";
var NotGreaterGreater = "";
var NotGreaterLess = "";
var NotGreaterSlantEqual = "";
var NotGreaterTilde = "";
var NotHumpDownHump = "";
var NotHumpEqual = "";
var notin = "";
var notindot = "";
var notinE = "";
var notinva = "";
var notinvb = "";
var notinvc = "";
var NotLeftTriangleBar = "";
var NotLeftTriangle = "";
var NotLeftTriangleEqual = "";
var NotLess = "";
var NotLessEqual = "";
var NotLessGreater = "";
var NotLessLess = "";
var NotLessSlantEqual = "";
var NotLessTilde = "";
var NotNestedGreaterGreater = "";
var NotNestedLessLess = "";
var notni = "";
var notniva = "";
var notnivb = "";
var notnivc = "";
var NotPrecedes = "";
var NotPrecedesEqual = "";
var NotPrecedesSlantEqual = "";
var NotReverseElement = "";
var NotRightTriangleBar = "";
var NotRightTriangle = "";
var NotRightTriangleEqual = "";
var NotSquareSubset = "";
var NotSquareSubsetEqual = "";
var NotSquareSuperset = "";
var NotSquareSupersetEqual = "";
var NotSubset = "";
var NotSubsetEqual = "";
var NotSucceeds = "";
var NotSucceedsEqual = "";
var NotSucceedsSlantEqual = "";
var NotSucceedsTilde = "";
var NotSuperset = "";
var NotSupersetEqual = "";
var NotTilde = "";
var NotTildeEqual = "";
var NotTildeFullEqual = "";
var NotTildeTilde = "";
var NotVerticalBar = "";
var nparallel = "";
var npar = "";
var nparsl = "";
var npart = "";
var npolint = "";
var npr = "";
var nprcue = "";
var nprec = "";
var npreceq = "";
var npre = "";
var nrarrc = "";
var nrarr = "";
var nrArr = "";
var nrarrw = "";
var nrightarrow = "";
var nRightarrow = "";
var nrtri = "";
var nrtrie = "";
var nsc = "";
var nsccue = "";
var nsce = "";
var Nscr = "";
var nscr = "";
var nshortmid = "";
var nshortparallel = "";
var nsim = "";
var nsime = "";
var nsimeq = "";
var nsmid = "";
var nspar = "";
var nsqsube = "";
var nsqsupe = "";
var nsub = "";
var nsubE = "";
var nsube = "";
var nsubset = "";
var nsubseteq = "";
var nsubseteqq = "";
var nsucc = "";
var nsucceq = "";
var nsup = "";
var nsupE = "";
var nsupe = "";
var nsupset = "";
var nsupseteq = "";
var nsupseteqq = "";
var ntgl = "";
var Ntilde = "";
var ntilde = "";
var ntlg = "";
var ntriangleleft = "";
var ntrianglelefteq = "";
var ntriangleright = "";
var ntrianglerighteq = "";
var Nu = "";
var nu = "";
var num = "#";
var numero = "";
var numsp = "";
var nvap = "";
var nvdash = "";
var nvDash = "";
var nVdash = "";
var nVDash = "";
var nvge = "";
var nvgt = ">";
var nvHarr = "";
var nvinfin = "";
var nvlArr = "";
var nvle = "";
var nvlt = "<";
var nvltrie = "";
var nvrArr = "";
var nvrtrie = "";
var nvsim = "";
var nwarhk = "";
var nwarr = "";
var nwArr = "";
var nwarrow = "";
var nwnear = "";
var Oacute = "";
var oacute = "";
var oast = "";
var Ocirc = "";
var ocirc = "";
var ocir = "";
var Ocy = "";
var ocy = "";
var odash = "";
var Odblac = "";
var odblac = "";
var odiv = "";
var odot = "";
var odsold = "";
var OElig = "";
var oelig = "";
var ofcir = "";
var Ofr = "";
var ofr = "";
var ogon = "";
var Ograve = "";
var ograve = "";
var ogt = "";
var ohbar = "";
var ohm = "";
var oint = "";
var olarr = "";
var olcir = "";
var olcross = "";
var oline = "";
var olt = "";
var Omacr = "";
var omacr = "";
var Omega = "";
var omega = "";
var Omicron = "";
var omicron = "";
var omid = "";
var ominus = "";
var Oopf = "";
var oopf = "";
var opar = "";
var OpenCurlyDoubleQuote = "";
var OpenCurlyQuote = "";
var operp = "";
var oplus = "";
var orarr = "";
var Or = "";
var or = "";
var ord = "";
var order = "";
var orderof = "";
var ordf = "";
var ordm = "";
var origof = "";
var oror = "";
var orslope = "";
var orv = "";
var oS = "";
var Oscr = "";
var oscr = "";
var Oslash = "";
var oslash = "";
var osol = "";
var Otilde = "";
var otilde = "";
var otimesas = "";
var Otimes = "";
var otimes = "";
var Ouml = "";
var ouml = "";
var ovbar = "";
var OverBar = "";
var OverBrace = "";
var OverBracket = "";
var OverParenthesis = "";
var para = "";
var parallel = "";
var par = "";
var parsim = "";
var parsl = "";
var part = "";
var PartialD = "";
var Pcy = "";
var pcy = "";
var percnt = "%";
var period = ".";
var permil = "";
var perp = "";
var pertenk = "";
var Pfr = "";
var pfr = "";
var Phi = "";
var phi = "";
var phiv = "";
var phmmat = "";
var phone = "";
var Pi = "";
var pi = "";
var pitchfork = "";
var piv = "";
var planck = "";
var planckh = "";
var plankv = "";
var plusacir = "";
var plusb = "";
var pluscir = "";
var plus = "+";
var plusdo = "";
var plusdu = "";
var pluse = "";
var PlusMinus = "";
var plusmn = "";
var plussim = "";
var plustwo = "";
var pm = "";
var Poincareplane = "";
var pointint = "";
var popf = "";
var Popf = "";
var pound = "";
var prap = "";
var Pr = "";
var pr = "";
var prcue = "";
var precapprox = "";
var prec = "";
var preccurlyeq = "";
var Precedes = "";
var PrecedesEqual = "";
var PrecedesSlantEqual = "";
var PrecedesTilde = "";
var preceq = "";
var precnapprox = "";
var precneqq = "";
var precnsim = "";
var pre = "";
var prE = "";
var precsim = "";
var prime = "";
var Prime = "";
var primes = "";
var prnap = "";
var prnE = "";
var prnsim = "";
var prod = "";
var Product = "";
var profalar = "";
var profline = "";
var profsurf = "";
var prop = "";
var Proportional = "";
var Proportion = "";
var propto = "";
var prsim = "";
var prurel = "";
var Pscr = "";
var pscr = "";
var Psi = "";
var psi = "";
var puncsp = "";
var Qfr = "";
var qfr = "";
var qint = "";
var qopf = "";
var Qopf = "";
var qprime = "";
var Qscr = "";
var qscr = "";
var quaternions = "";
var quatint = "";
var quest = "?";
var questeq = "";
var quot$1 = "\"";
var QUOT = "\"";
var rAarr = "";
var race = "";
var Racute = "";
var racute = "";
var radic = "";
var raemptyv = "";
var rang = "";
var Rang = "";
var rangd = "";
var range = "";
var rangle = "";
var raquo = "";
var rarrap = "";
var rarrb = "";
var rarrbfs = "";
var rarrc = "";
var rarr = "";
var Rarr = "";
var rArr = "";
var rarrfs = "";
var rarrhk = "";
var rarrlp = "";
var rarrpl = "";
var rarrsim = "";
var Rarrtl = "";
var rarrtl = "";
var rarrw = "";
var ratail = "";
var rAtail = "";
var ratio = "";
var rationals = "";
var rbarr = "";
var rBarr = "";
var RBarr = "";
var rbbrk = "";
var rbrace = "}";
var rbrack = "]";
var rbrke = "";
var rbrksld = "";
var rbrkslu = "";
var Rcaron = "";
var rcaron = "";
var Rcedil = "";
var rcedil = "";
var rceil = "";
var rcub = "}";
var Rcy = "";
var rcy = "";
var rdca = "";
var rdldhar = "";
var rdquo = "";
var rdquor = "";
var rdsh = "";
var real = "";
var realine = "";
var realpart = "";
var reals = "";
var Re = "";
var rect = "";
var reg = "";
var REG = "";
var ReverseElement = "";
var ReverseEquilibrium = "";
var ReverseUpEquilibrium = "";
var rfisht = "";
var rfloor = "";
var rfr = "";
var Rfr = "";
var rHar = "";
var rhard = "";
var rharu = "";
var rharul = "";
var Rho = "";
var rho = "";
var rhov = "";
var RightAngleBracket = "";
var RightArrowBar = "";
var rightarrow = "";
var RightArrow = "";
var Rightarrow = "";
var RightArrowLeftArrow = "";
var rightarrowtail = "";
var RightCeiling = "";
var RightDoubleBracket = "";
var RightDownTeeVector = "";
var RightDownVectorBar = "";
var RightDownVector = "";
var RightFloor = "";
var rightharpoondown = "";
var rightharpoonup = "";
var rightleftarrows = "";
var rightleftharpoons = "";
var rightrightarrows = "";
var rightsquigarrow = "";
var RightTeeArrow = "";
var RightTee = "";
var RightTeeVector = "";
var rightthreetimes = "";
var RightTriangleBar = "";
var RightTriangle = "";
var RightTriangleEqual = "";
var RightUpDownVector = "";
var RightUpTeeVector = "";
var RightUpVectorBar = "";
var RightUpVector = "";
var RightVectorBar = "";
var RightVector = "";
var ring = "";
var risingdotseq = "";
var rlarr = "";
var rlhar = "";
var rlm = "";
var rmoustache = "";
var rmoust = "";
var rnmid = "";
var roang = "";
var roarr = "";
var robrk = "";
var ropar = "";
var ropf = "";
var Ropf = "";
var roplus = "";
var rotimes = "";
var RoundImplies = "";
var rpar = ")";
var rpargt = "";
var rppolint = "";
var rrarr = "";
var Rrightarrow = "";
var rsaquo = "";
var rscr = "";
var Rscr = "";
var rsh = "";
var Rsh = "";
var rsqb = "]";
var rsquo = "";
var rsquor = "";
var rthree = "";
var rtimes = "";
var rtri = "";
var rtrie = "";
var rtrif = "";
var rtriltri = "";
var RuleDelayed = "";
var ruluhar = "";
var rx = "";
var Sacute = "";
var sacute = "";
var sbquo = "";
var scap = "";
var Scaron = "";
var scaron = "";
var Sc = "";
var sc = "";
var sccue = "";
var sce = "";
var scE = "";
var Scedil = "";
var scedil = "";
var Scirc = "";
var scirc = "";
var scnap = "";
var scnE = "";
var scnsim = "";
var scpolint = "";
var scsim = "";
var Scy = "";
var scy = "";
var sdotb = "";
var sdot = "";
var sdote = "";
var searhk = "";
var searr = "";
var seArr = "";
var searrow = "";
var sect = "";
var semi = ";";
var seswar = "";
var setminus = "";
var setmn = "";
var sext = "";
var Sfr = "";
var sfr = "";
var sfrown = "";
var sharp = "";
var SHCHcy = "";
var shchcy = "";
var SHcy = "";
var shcy = "";
var ShortDownArrow = "";
var ShortLeftArrow = "";
var shortmid = "";
var shortparallel = "";
var ShortRightArrow = "";
var ShortUpArrow = "";
var shy = "";
var Sigma = "";
var sigma = "";
var sigmaf = "";
var sigmav = "";
var sim = "";
var simdot = "";
var sime = "";
var simeq = "";
var simg = "";
var simgE = "";
var siml = "";
var simlE = "";
var simne = "";
var simplus = "";
var simrarr = "";
var slarr = "";
var SmallCircle = "";
var smallsetminus = "";
var smashp = "";
var smeparsl = "";
var smid = "";
var smile = "";
var smt = "";
var smte = "";
var smtes = "";
var SOFTcy = "";
var softcy = "";
var solbar = "";
var solb = "";
var sol = "/";
var Sopf = "";
var sopf = "";
var spades = "";
var spadesuit = "";
var spar = "";
var sqcap = "";
var sqcaps = "";
var sqcup = "";
var sqcups = "";
var Sqrt = "";
var sqsub = "";
var sqsube = "";
var sqsubset = "";
var sqsubseteq = "";
var sqsup = "";
var sqsupe = "";
var sqsupset = "";
var sqsupseteq = "";
var square = "";
var Square = "";
var SquareIntersection = "";
var SquareSubset = "";
var SquareSubsetEqual = "";
var SquareSuperset = "";
var SquareSupersetEqual = "";
var SquareUnion = "";
var squarf = "";
var squ = "";
var squf = "";
var srarr = "";
var Sscr = "";
var sscr = "";
var ssetmn = "";
var ssmile = "";
var sstarf = "";
var Star = "";
var star = "";
var starf = "";
var straightepsilon = "";
var straightphi = "";
var strns = "";
var sub = "";
var Sub = "";
var subdot = "";
var subE = "";
var sube = "";
var subedot = "";
var submult = "";
var subnE = "";
var subne = "";
var subplus = "";
var subrarr = "";
var subset = "";
var Subset = "";
var subseteq = "";
var subseteqq = "";
var SubsetEqual = "";
var subsetneq = "";
var subsetneqq = "";
var subsim = "";
var subsub = "";
var subsup = "";
var succapprox = "";
var succ = "";
var succcurlyeq = "";
var Succeeds = "";
var SucceedsEqual = "";
var SucceedsSlantEqual = "";
var SucceedsTilde = "";
var succeq = "";
var succnapprox = "";
var succneqq = "";
var succnsim = "";
var succsim = "";
var SuchThat = "";
var sum = "";
var Sum = "";
var sung = "";
var sup1 = "";
var sup2 = "";
var sup3 = "";
var sup = "";
var Sup = "";
var supdot = "";
var supdsub = "";
var supE = "";
var supe = "";
var supedot = "";
var Superset = "";
var SupersetEqual = "";
var suphsol = "";
var suphsub = "";
var suplarr = "";
var supmult = "";
var supnE = "";
var supne = "";
var supplus = "";
var supset = "";
var Supset = "";
var supseteq = "";
var supseteqq = "";
var supsetneq = "";
var supsetneqq = "";
var supsim = "";
var supsub = "";
var supsup = "";
var swarhk = "";
var swarr = "";
var swArr = "";
var swarrow = "";
var swnwar = "";
var szlig = "";
var Tab = "\t";
var target = "";
var Tau = "";
var tau = "";
var tbrk = "";
var Tcaron = "";
var tcaron = "";
var Tcedil = "";
var tcedil = "";
var Tcy = "";
var tcy = "";
var tdot = "";
var telrec = "";
var Tfr = "";
var tfr = "";
var there4 = "";
var therefore = "";
var Therefore = "";
var Theta = "";
var theta = "";
var thetasym = "";
var thetav = "";
var thickapprox = "";
var thicksim = "";
var ThickSpace = "";
var ThinSpace = "";
var thinsp = "";
var thkap = "";
var thksim = "";
var THORN = "";
var thorn = "";
var tilde = "";
var Tilde = "";
var TildeEqual = "";
var TildeFullEqual = "";
var TildeTilde = "";
var timesbar = "";
var timesb = "";
var times$1 = "";
var timesd = "";
var tint = "";
var toea = "";
var topbot = "";
var topcir = "";
var top = "";
var Topf = "";
var topf = "";
var topfork = "";
var tosa = "";
var tprime = "";
var trade = "";
var TRADE = "";
var triangle = "";
var triangledown = "";
var triangleleft = "";
var trianglelefteq = "";
var triangleq = "";
var triangleright = "";
var trianglerighteq = "";
var tridot = "";
var trie = "";
var triminus = "";
var TripleDot = "";
var triplus = "";
var trisb = "";
var tritime = "";
var trpezium = "";
var Tscr = "";
var tscr = "";
var TScy = "";
var tscy = "";
var TSHcy = "";
var tshcy = "";
var Tstrok = "";
var tstrok = "";
var twixt = "";
var twoheadleftarrow = "";
var twoheadrightarrow = "";
var Uacute = "";
var uacute = "";
var uarr = "";
var Uarr = "";
var uArr = "";
var Uarrocir = "";
var Ubrcy = "";
var ubrcy = "";
var Ubreve = "";
var ubreve = "";
var Ucirc = "";
var ucirc = "";
var Ucy = "";
var ucy = "";
var udarr = "";
var Udblac = "";
var udblac = "";
var udhar = "";
var ufisht = "";
var Ufr = "";
var ufr = "";
var Ugrave = "";
var ugrave = "";
var uHar = "";
var uharl = "";
var uharr = "";
var uhblk = "";
var ulcorn = "";
var ulcorner = "";
var ulcrop = "";
var ultri = "";
var Umacr = "";
var umacr = "";
var uml = "";
var UnderBar = "_";
var UnderBrace = "";
var UnderBracket = "";
var UnderParenthesis = "";
var Union = "";
var UnionPlus = "";
var Uogon = "";
var uogon = "";
var Uopf = "";
var uopf = "";
var UpArrowBar = "";
var uparrow = "";
var UpArrow = "";
var Uparrow = "";
var UpArrowDownArrow = "";
var updownarrow = "";
var UpDownArrow = "";
var Updownarrow = "";
var UpEquilibrium = "";
var upharpoonleft = "";
var upharpoonright = "";
var uplus = "";
var UpperLeftArrow = "";
var UpperRightArrow = "";
var upsi = "";
var Upsi = "";
var upsih = "";
var Upsilon = "";
var upsilon = "";
var UpTeeArrow = "";
var UpTee = "";
var upuparrows = "";
var urcorn = "";
var urcorner = "";
var urcrop = "";
var Uring = "";
var uring = "";
var urtri = "";
var Uscr = "";
var uscr = "";
var utdot = "";
var Utilde = "";
var utilde = "";
var utri = "";
var utrif = "";
var uuarr = "";
var Uuml = "";
var uuml = "";
var uwangle = "";
var vangrt = "";
var varepsilon = "";
var varkappa = "";
var varnothing = "";
var varphi = "";
var varpi = "";
var varpropto = "";
var varr = "";
var vArr = "";
var varrho = "";
var varsigma = "";
var varsubsetneq = "";
var varsubsetneqq = "";
var varsupsetneq = "";
var varsupsetneqq = "";
var vartheta = "";
var vartriangleleft = "";
var vartriangleright = "";
var vBar = "";
var Vbar = "";
var vBarv = "";
var Vcy = "";
var vcy = "";
var vdash = "";
var vDash = "";
var Vdash = "";
var VDash = "";
var Vdashl = "";
var veebar = "";
var vee = "";
var Vee = "";
var veeeq = "";
var vellip = "";
var verbar = "|";
var Verbar = "";
var vert = "|";
var Vert = "";
var VerticalBar = "";
var VerticalLine = "|";
var VerticalSeparator = "";
var VerticalTilde = "";
var VeryThinSpace = "";
var Vfr = "";
var vfr = "";
var vltri = "";
var vnsub = "";
var vnsup = "";
var Vopf = "";
var vopf = "";
var vprop = "";
var vrtri = "";
var Vscr = "";
var vscr = "";
var vsubnE = "";
var vsubne = "";
var vsupnE = "";
var vsupne = "";
var Vvdash = "";
var vzigzag = "";
var Wcirc = "";
var wcirc = "";
var wedbar = "";
var wedge = "";
var Wedge = "";
var wedgeq = "";
var weierp = "";
var Wfr = "";
var wfr = "";
var Wopf = "";
var wopf = "";
var wp = "";
var wr = "";
var wreath = "";
var Wscr = "";
var wscr = "";
var xcap = "";
var xcirc = "";
var xcup = "";
var xdtri = "";
var Xfr = "";
var xfr = "";
var xharr = "";
var xhArr = "";
var Xi = "";
var xi = "";
var xlarr = "";
var xlArr = "";
var xmap = "";
var xnis = "";
var xodot = "";
var Xopf = "";
var xopf = "";
var xoplus = "";
var xotime = "";
var xrarr = "";
var xrArr = "";
var Xscr = "";
var xscr = "";
var xsqcup = "";
var xuplus = "";
var xutri = "";
var xvee = "";
var xwedge = "";
var Yacute = "";
var yacute = "";
var YAcy = "";
var yacy = "";
var Ycirc = "";
var ycirc = "";
var Ycy = "";
var ycy = "";
var yen = "";
var Yfr = "";
var yfr = "";
var YIcy = "";
var yicy = "";
var Yopf = "";
var yopf = "";
var Yscr = "";
var yscr = "";
var YUcy = "";
var yucy = "";
var yuml = "";
var Yuml = "";
var Zacute = "";
var zacute = "";
var Zcaron = "";
var zcaron = "";
var Zcy = "";
var zcy = "";
var Zdot = "";
var zdot = "";
var zeetrf = "";
var ZeroWidthSpace = "";
var Zeta = "";
var zeta = "";
var zfr = "";
var Zfr = "";
var ZHcy = "";
var zhcy = "";
var zigrarr = "";
var zopf = "";
var Zopf = "";
var Zscr = "";
var zscr = "";
var zwj = "";
var zwnj = "";
var entitiesJSON = {
	Aacute: Aacute,
	aacute: aacute,
	Abreve: Abreve,
	abreve: abreve,
	ac: ac,
	acd: acd,
	acE: acE,
	Acirc: Acirc,
	acirc: acirc,
	acute: acute,
	Acy: Acy,
	acy: acy,
	AElig: AElig,
	aelig: aelig,
	af: af,
	Afr: Afr,
	afr: afr,
	Agrave: Agrave,
	agrave: agrave,
	alefsym: alefsym,
	aleph: aleph,
	Alpha: Alpha,
	alpha: alpha,
	Amacr: Amacr,
	amacr: amacr,
	amalg: amalg,
	amp: amp$1,
	AMP: AMP,
	andand: andand,
	And: And,
	and: and,
	andd: andd,
	andslope: andslope,
	andv: andv,
	ang: ang,
	ange: ange,
	angle: angle,
	angmsdaa: angmsdaa,
	angmsdab: angmsdab,
	angmsdac: angmsdac,
	angmsdad: angmsdad,
	angmsdae: angmsdae,
	angmsdaf: angmsdaf,
	angmsdag: angmsdag,
	angmsdah: angmsdah,
	angmsd: angmsd,
	angrt: angrt,
	angrtvb: angrtvb,
	angrtvbd: angrtvbd,
	angsph: angsph,
	angst: angst,
	angzarr: angzarr,
	Aogon: Aogon,
	aogon: aogon,
	Aopf: Aopf,
	aopf: aopf,
	apacir: apacir,
	ap: ap,
	apE: apE,
	ape: ape,
	apid: apid,
	apos: apos$1,
	ApplyFunction: ApplyFunction,
	approx: approx,
	approxeq: approxeq,
	Aring: Aring,
	aring: aring,
	Ascr: Ascr,
	ascr: ascr,
	Assign: Assign,
	ast: ast,
	asymp: asymp,
	asympeq: asympeq,
	Atilde: Atilde,
	atilde: atilde,
	Auml: Auml,
	auml: auml,
	awconint: awconint,
	awint: awint,
	backcong: backcong,
	backepsilon: backepsilon,
	backprime: backprime,
	backsim: backsim,
	backsimeq: backsimeq,
	Backslash: Backslash,
	Barv: Barv,
	barvee: barvee,
	barwed: barwed,
	Barwed: Barwed,
	barwedge: barwedge,
	bbrk: bbrk,
	bbrktbrk: bbrktbrk,
	bcong: bcong,
	Bcy: Bcy,
	bcy: bcy,
	bdquo: bdquo,
	becaus: becaus,
	because: because,
	Because: Because,
	bemptyv: bemptyv,
	bepsi: bepsi,
	bernou: bernou,
	Bernoullis: Bernoullis,
	Beta: Beta,
	beta: beta,
	beth: beth,
	between: between,
	Bfr: Bfr,
	bfr: bfr,
	bigcap: bigcap,
	bigcirc: bigcirc,
	bigcup: bigcup,
	bigodot: bigodot,
	bigoplus: bigoplus,
	bigotimes: bigotimes,
	bigsqcup: bigsqcup,
	bigstar: bigstar,
	bigtriangledown: bigtriangledown,
	bigtriangleup: bigtriangleup,
	biguplus: biguplus,
	bigvee: bigvee,
	bigwedge: bigwedge,
	bkarow: bkarow,
	blacklozenge: blacklozenge,
	blacksquare: blacksquare,
	blacktriangle: blacktriangle,
	blacktriangledown: blacktriangledown,
	blacktriangleleft: blacktriangleleft,
	blacktriangleright: blacktriangleright,
	blank: blank,
	blk12: blk12,
	blk14: blk14,
	blk34: blk34,
	block: block,
	bne: bne,
	bnequiv: bnequiv,
	bNot: bNot,
	bnot: bnot,
	Bopf: Bopf,
	bopf: bopf,
	bot: bot,
	bottom: bottom,
	bowtie: bowtie,
	boxbox: boxbox,
	boxdl: boxdl,
	boxdL: boxdL,
	boxDl: boxDl,
	boxDL: boxDL,
	boxdr: boxdr,
	boxdR: boxdR,
	boxDr: boxDr,
	boxDR: boxDR,
	boxh: boxh,
	boxH: boxH,
	boxhd: boxhd,
	boxHd: boxHd,
	boxhD: boxhD,
	boxHD: boxHD,
	boxhu: boxhu,
	boxHu: boxHu,
	boxhU: boxhU,
	boxHU: boxHU,
	boxminus: boxminus,
	boxplus: boxplus,
	boxtimes: boxtimes,
	boxul: boxul,
	boxuL: boxuL,
	boxUl: boxUl,
	boxUL: boxUL,
	boxur: boxur,
	boxuR: boxuR,
	boxUr: boxUr,
	boxUR: boxUR,
	boxv: boxv,
	boxV: boxV,
	boxvh: boxvh,
	boxvH: boxvH,
	boxVh: boxVh,
	boxVH: boxVH,
	boxvl: boxvl,
	boxvL: boxvL,
	boxVl: boxVl,
	boxVL: boxVL,
	boxvr: boxvr,
	boxvR: boxvR,
	boxVr: boxVr,
	boxVR: boxVR,
	bprime: bprime,
	breve: breve,
	Breve: Breve,
	brvbar: brvbar,
	bscr: bscr,
	Bscr: Bscr,
	bsemi: bsemi,
	bsim: bsim,
	bsime: bsime,
	bsolb: bsolb,
	bsol: bsol,
	bsolhsub: bsolhsub,
	bull: bull,
	bullet: bullet,
	bump: bump,
	bumpE: bumpE,
	bumpe: bumpe,
	Bumpeq: Bumpeq,
	bumpeq: bumpeq,
	Cacute: Cacute,
	cacute: cacute,
	capand: capand,
	capbrcup: capbrcup,
	capcap: capcap,
	cap: cap,
	Cap: Cap,
	capcup: capcup,
	capdot: capdot,
	CapitalDifferentialD: CapitalDifferentialD,
	caps: caps,
	caret: caret,
	caron: caron,
	Cayleys: Cayleys,
	ccaps: ccaps,
	Ccaron: Ccaron,
	ccaron: ccaron,
	Ccedil: Ccedil,
	ccedil: ccedil,
	Ccirc: Ccirc,
	ccirc: ccirc,
	Cconint: Cconint,
	ccups: ccups,
	ccupssm: ccupssm,
	Cdot: Cdot,
	cdot: cdot,
	cedil: cedil,
	Cedilla: Cedilla,
	cemptyv: cemptyv,
	cent: cent,
	centerdot: centerdot,
	CenterDot: CenterDot,
	cfr: cfr,
	Cfr: Cfr,
	CHcy: CHcy,
	chcy: chcy,
	check: check,
	checkmark: checkmark,
	Chi: Chi,
	chi: chi,
	circ: circ,
	circeq: circeq,
	circlearrowleft: circlearrowleft,
	circlearrowright: circlearrowright,
	circledast: circledast,
	circledcirc: circledcirc,
	circleddash: circleddash,
	CircleDot: CircleDot,
	circledR: circledR,
	circledS: circledS,
	CircleMinus: CircleMinus,
	CirclePlus: CirclePlus,
	CircleTimes: CircleTimes,
	cir: cir,
	cirE: cirE,
	cire: cire,
	cirfnint: cirfnint,
	cirmid: cirmid,
	cirscir: cirscir,
	ClockwiseContourIntegral: ClockwiseContourIntegral,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
	CloseCurlyQuote: CloseCurlyQuote,
	clubs: clubs,
	clubsuit: clubsuit,
	colon: colon,
	Colon: Colon,
	Colone: Colone,
	colone: colone,
	coloneq: coloneq,
	comma: comma,
	commat: commat,
	comp: comp,
	compfn: compfn,
	complement: complement,
	complexes: complexes,
	cong: cong,
	congdot: congdot,
	Congruent: Congruent,
	conint: conint,
	Conint: Conint,
	ContourIntegral: ContourIntegral,
	copf: copf,
	Copf: Copf,
	coprod: coprod,
	Coproduct: Coproduct,
	copy: copy,
	COPY: COPY,
	copysr: copysr,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
	crarr: crarr,
	cross: cross,
	Cross: Cross,
	Cscr: Cscr,
	cscr: cscr,
	csub: csub,
	csube: csube,
	csup: csup,
	csupe: csupe,
	ctdot: ctdot,
	cudarrl: cudarrl,
	cudarrr: cudarrr,
	cuepr: cuepr,
	cuesc: cuesc,
	cularr: cularr,
	cularrp: cularrp,
	cupbrcap: cupbrcap,
	cupcap: cupcap,
	CupCap: CupCap,
	cup: cup,
	Cup: Cup,
	cupcup: cupcup,
	cupdot: cupdot,
	cupor: cupor,
	cups: cups,
	curarr: curarr,
	curarrm: curarrm,
	curlyeqprec: curlyeqprec,
	curlyeqsucc: curlyeqsucc,
	curlyvee: curlyvee,
	curlywedge: curlywedge,
	curren: curren,
	curvearrowleft: curvearrowleft,
	curvearrowright: curvearrowright,
	cuvee: cuvee,
	cuwed: cuwed,
	cwconint: cwconint,
	cwint: cwint,
	cylcty: cylcty,
	dagger: dagger,
	Dagger: Dagger,
	daleth: daleth,
	darr: darr,
	Darr: Darr,
	dArr: dArr,
	dash: dash,
	Dashv: Dashv,
	dashv: dashv,
	dbkarow: dbkarow,
	dblac: dblac,
	Dcaron: Dcaron,
	dcaron: dcaron,
	Dcy: Dcy,
	dcy: dcy,
	ddagger: ddagger,
	ddarr: ddarr,
	DD: DD,
	dd: dd,
	DDotrahd: DDotrahd,
	ddotseq: ddotseq,
	deg: deg,
	Del: Del,
	Delta: Delta,
	delta: delta,
	demptyv: demptyv,
	dfisht: dfisht,
	Dfr: Dfr,
	dfr: dfr,
	dHar: dHar,
	dharl: dharl,
	dharr: dharr,
	DiacriticalAcute: DiacriticalAcute,
	DiacriticalDot: DiacriticalDot,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
	DiacriticalGrave: DiacriticalGrave,
	DiacriticalTilde: DiacriticalTilde,
	diam: diam,
	diamond: diamond,
	Diamond: Diamond,
	diamondsuit: diamondsuit,
	diams: diams,
	die: die,
	DifferentialD: DifferentialD,
	digamma: digamma,
	disin: disin,
	div: div,
	divide: divide,
	divideontimes: divideontimes,
	divonx: divonx,
	DJcy: DJcy,
	djcy: djcy,
	dlcorn: dlcorn,
	dlcrop: dlcrop,
	dollar: dollar,
	Dopf: Dopf,
	dopf: dopf,
	Dot: Dot,
	dot: dot,
	DotDot: DotDot,
	doteq: doteq,
	doteqdot: doteqdot,
	DotEqual: DotEqual,
	dotminus: dotminus,
	dotplus: dotplus,
	dotsquare: dotsquare,
	doublebarwedge: doublebarwedge,
	DoubleContourIntegral: DoubleContourIntegral,
	DoubleDot: DoubleDot,
	DoubleDownArrow: DoubleDownArrow,
	DoubleLeftArrow: DoubleLeftArrow,
	DoubleLeftRightArrow: DoubleLeftRightArrow,
	DoubleLeftTee: DoubleLeftTee,
	DoubleLongLeftArrow: DoubleLongLeftArrow,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
	DoubleLongRightArrow: DoubleLongRightArrow,
	DoubleRightArrow: DoubleRightArrow,
	DoubleRightTee: DoubleRightTee,
	DoubleUpArrow: DoubleUpArrow,
	DoubleUpDownArrow: DoubleUpDownArrow,
	DoubleVerticalBar: DoubleVerticalBar,
	DownArrowBar: DownArrowBar,
	downarrow: downarrow,
	DownArrow: DownArrow,
	Downarrow: Downarrow,
	DownArrowUpArrow: DownArrowUpArrow,
	DownBreve: DownBreve,
	downdownarrows: downdownarrows,
	downharpoonleft: downharpoonleft,
	downharpoonright: downharpoonright,
	DownLeftRightVector: DownLeftRightVector,
	DownLeftTeeVector: DownLeftTeeVector,
	DownLeftVectorBar: DownLeftVectorBar,
	DownLeftVector: DownLeftVector,
	DownRightTeeVector: DownRightTeeVector,
	DownRightVectorBar: DownRightVectorBar,
	DownRightVector: DownRightVector,
	DownTeeArrow: DownTeeArrow,
	DownTee: DownTee,
	drbkarow: drbkarow,
	drcorn: drcorn,
	drcrop: drcrop,
	Dscr: Dscr,
	dscr: dscr,
	DScy: DScy,
	dscy: dscy,
	dsol: dsol,
	Dstrok: Dstrok,
	dstrok: dstrok,
	dtdot: dtdot,
	dtri: dtri,
	dtrif: dtrif,
	duarr: duarr,
	duhar: duhar,
	dwangle: dwangle,
	DZcy: DZcy,
	dzcy: dzcy,
	dzigrarr: dzigrarr,
	Eacute: Eacute,
	eacute: eacute,
	easter: easter,
	Ecaron: Ecaron,
	ecaron: ecaron,
	Ecirc: Ecirc,
	ecirc: ecirc,
	ecir: ecir,
	ecolon: ecolon,
	Ecy: Ecy,
	ecy: ecy,
	eDDot: eDDot,
	Edot: Edot,
	edot: edot,
	eDot: eDot,
	ee: ee,
	efDot: efDot,
	Efr: Efr,
	efr: efr,
	eg: eg,
	Egrave: Egrave,
	egrave: egrave,
	egs: egs,
	egsdot: egsdot,
	el: el,
	Element: Element,
	elinters: elinters,
	ell: ell,
	els: els,
	elsdot: elsdot,
	Emacr: Emacr,
	emacr: emacr,
	empty: empty,
	emptyset: emptyset,
	EmptySmallSquare: EmptySmallSquare,
	emptyv: emptyv,
	EmptyVerySmallSquare: EmptyVerySmallSquare,
	emsp13: emsp13,
	emsp14: emsp14,
	emsp: emsp,
	ENG: ENG,
	eng: eng,
	ensp: ensp,
	Eogon: Eogon,
	eogon: eogon,
	Eopf: Eopf,
	eopf: eopf,
	epar: epar,
	eparsl: eparsl,
	eplus: eplus,
	epsi: epsi,
	Epsilon: Epsilon,
	epsilon: epsilon,
	epsiv: epsiv,
	eqcirc: eqcirc,
	eqcolon: eqcolon,
	eqsim: eqsim,
	eqslantgtr: eqslantgtr,
	eqslantless: eqslantless,
	Equal: Equal,
	equals: equals,
	EqualTilde: EqualTilde,
	equest: equest,
	Equilibrium: Equilibrium,
	equiv: equiv,
	equivDD: equivDD,
	eqvparsl: eqvparsl,
	erarr: erarr,
	erDot: erDot,
	escr: escr,
	Escr: Escr,
	esdot: esdot,
	Esim: Esim,
	esim: esim,
	Eta: Eta,
	eta: eta,
	ETH: ETH,
	eth: eth,
	Euml: Euml,
	euml: euml,
	euro: euro,
	excl: excl,
	exist: exist,
	Exists: Exists,
	expectation: expectation,
	exponentiale: exponentiale,
	ExponentialE: ExponentialE,
	fallingdotseq: fallingdotseq,
	Fcy: Fcy,
	fcy: fcy,
	female: female,
	ffilig: ffilig,
	fflig: fflig,
	ffllig: ffllig,
	Ffr: Ffr,
	ffr: ffr,
	filig: filig,
	FilledSmallSquare: FilledSmallSquare,
	FilledVerySmallSquare: FilledVerySmallSquare,
	fjlig: fjlig,
	flat: flat,
	fllig: fllig,
	fltns: fltns,
	fnof: fnof,
	Fopf: Fopf,
	fopf: fopf,
	forall: forall,
	ForAll: ForAll,
	fork: fork,
	forkv: forkv,
	Fouriertrf: Fouriertrf,
	fpartint: fpartint,
	frac12: frac12,
	frac13: frac13,
	frac14: frac14,
	frac15: frac15,
	frac16: frac16,
	frac18: frac18,
	frac23: frac23,
	frac25: frac25,
	frac34: frac34,
	frac35: frac35,
	frac38: frac38,
	frac45: frac45,
	frac56: frac56,
	frac58: frac58,
	frac78: frac78,
	frasl: frasl,
	frown: frown,
	fscr: fscr,
	Fscr: Fscr,
	gacute: gacute,
	Gamma: Gamma,
	gamma: gamma,
	Gammad: Gammad,
	gammad: gammad,
	gap: gap,
	Gbreve: Gbreve,
	gbreve: gbreve,
	Gcedil: Gcedil,
	Gcirc: Gcirc,
	gcirc: gcirc,
	Gcy: Gcy,
	gcy: gcy,
	Gdot: Gdot,
	gdot: gdot,
	ge: ge,
	gE: gE,
	gEl: gEl,
	gel: gel,
	geq: geq,
	geqq: geqq,
	geqslant: geqslant,
	gescc: gescc,
	ges: ges,
	gesdot: gesdot,
	gesdoto: gesdoto,
	gesdotol: gesdotol,
	gesl: gesl,
	gesles: gesles,
	Gfr: Gfr,
	gfr: gfr,
	gg: gg,
	Gg: Gg,
	ggg: ggg,
	gimel: gimel,
	GJcy: GJcy,
	gjcy: gjcy,
	gla: gla,
	gl: gl,
	glE: glE,
	glj: glj,
	gnap: gnap,
	gnapprox: gnapprox,
	gne: gne,
	gnE: gnE,
	gneq: gneq,
	gneqq: gneqq,
	gnsim: gnsim,
	Gopf: Gopf,
	gopf: gopf,
	grave: grave,
	GreaterEqual: GreaterEqual,
	GreaterEqualLess: GreaterEqualLess,
	GreaterFullEqual: GreaterFullEqual,
	GreaterGreater: GreaterGreater,
	GreaterLess: GreaterLess,
	GreaterSlantEqual: GreaterSlantEqual,
	GreaterTilde: GreaterTilde,
	Gscr: Gscr,
	gscr: gscr,
	gsim: gsim,
	gsime: gsime,
	gsiml: gsiml,
	gtcc: gtcc,
	gtcir: gtcir,
	gt: gt$1,
	GT: GT,
	Gt: Gt,
	gtdot: gtdot,
	gtlPar: gtlPar,
	gtquest: gtquest,
	gtrapprox: gtrapprox,
	gtrarr: gtrarr,
	gtrdot: gtrdot,
	gtreqless: gtreqless,
	gtreqqless: gtreqqless,
	gtrless: gtrless,
	gtrsim: gtrsim,
	gvertneqq: gvertneqq,
	gvnE: gvnE,
	Hacek: Hacek,
	hairsp: hairsp,
	half: half,
	hamilt: hamilt,
	HARDcy: HARDcy,
	hardcy: hardcy,
	harrcir: harrcir,
	harr: harr,
	hArr: hArr,
	harrw: harrw,
	Hat: Hat,
	hbar: hbar,
	Hcirc: Hcirc,
	hcirc: hcirc,
	hearts: hearts,
	heartsuit: heartsuit,
	hellip: hellip,
	hercon: hercon,
	hfr: hfr,
	Hfr: Hfr,
	HilbertSpace: HilbertSpace,
	hksearow: hksearow,
	hkswarow: hkswarow,
	hoarr: hoarr,
	homtht: homtht,
	hookleftarrow: hookleftarrow,
	hookrightarrow: hookrightarrow,
	hopf: hopf,
	Hopf: Hopf,
	horbar: horbar,
	HorizontalLine: HorizontalLine,
	hscr: hscr,
	Hscr: Hscr,
	hslash: hslash,
	Hstrok: Hstrok,
	hstrok: hstrok,
	HumpDownHump: HumpDownHump,
	HumpEqual: HumpEqual,
	hybull: hybull,
	hyphen: hyphen,
	Iacute: Iacute,
	iacute: iacute,
	ic: ic,
	Icirc: Icirc,
	icirc: icirc,
	Icy: Icy,
	icy: icy,
	Idot: Idot,
	IEcy: IEcy,
	iecy: iecy,
	iexcl: iexcl,
	iff: iff,
	ifr: ifr,
	Ifr: Ifr,
	Igrave: Igrave,
	igrave: igrave,
	ii: ii,
	iiiint: iiiint,
	iiint: iiint,
	iinfin: iinfin,
	iiota: iiota,
	IJlig: IJlig,
	ijlig: ijlig,
	Imacr: Imacr,
	imacr: imacr,
	image: image,
	ImaginaryI: ImaginaryI,
	imagline: imagline,
	imagpart: imagpart,
	imath: imath,
	Im: Im,
	imof: imof,
	imped: imped,
	Implies: Implies,
	incare: incare,
	infin: infin,
	infintie: infintie,
	inodot: inodot,
	intcal: intcal,
	int: int,
	Int: Int,
	integers: integers,
	Integral: Integral,
	intercal: intercal,
	Intersection: Intersection,
	intlarhk: intlarhk,
	intprod: intprod,
	InvisibleComma: InvisibleComma,
	InvisibleTimes: InvisibleTimes,
	IOcy: IOcy,
	iocy: iocy,
	Iogon: Iogon,
	iogon: iogon,
	Iopf: Iopf,
	iopf: iopf,
	Iota: Iota,
	iota: iota,
	iprod: iprod,
	iquest: iquest,
	iscr: iscr,
	Iscr: Iscr,
	isin: isin,
	isindot: isindot,
	isinE: isinE,
	isins: isins,
	isinsv: isinsv,
	isinv: isinv,
	it: it,
	Itilde: Itilde,
	itilde: itilde,
	Iukcy: Iukcy,
	iukcy: iukcy,
	Iuml: Iuml,
	iuml: iuml,
	Jcirc: Jcirc,
	jcirc: jcirc,
	Jcy: Jcy,
	jcy: jcy,
	Jfr: Jfr,
	jfr: jfr,
	jmath: jmath,
	Jopf: Jopf,
	jopf: jopf,
	Jscr: Jscr,
	jscr: jscr,
	Jsercy: Jsercy,
	jsercy: jsercy,
	Jukcy: Jukcy,
	jukcy: jukcy,
	Kappa: Kappa,
	kappa: kappa,
	kappav: kappav,
	Kcedil: Kcedil,
	kcedil: kcedil,
	Kcy: Kcy,
	kcy: kcy,
	Kfr: Kfr,
	kfr: kfr,
	kgreen: kgreen,
	KHcy: KHcy,
	khcy: khcy,
	KJcy: KJcy,
	kjcy: kjcy,
	Kopf: Kopf,
	kopf: kopf,
	Kscr: Kscr,
	kscr: kscr,
	lAarr: lAarr,
	Lacute: Lacute,
	lacute: lacute,
	laemptyv: laemptyv,
	lagran: lagran,
	Lambda: Lambda,
	lambda: lambda,
	lang: lang,
	Lang: Lang,
	langd: langd,
	langle: langle,
	lap: lap,
	Laplacetrf: Laplacetrf,
	laquo: laquo,
	larrb: larrb,
	larrbfs: larrbfs,
	larr: larr,
	Larr: Larr,
	lArr: lArr,
	larrfs: larrfs,
	larrhk: larrhk,
	larrlp: larrlp,
	larrpl: larrpl,
	larrsim: larrsim,
	larrtl: larrtl,
	latail: latail,
	lAtail: lAtail,
	lat: lat,
	late: late,
	lates: lates,
	lbarr: lbarr,
	lBarr: lBarr,
	lbbrk: lbbrk,
	lbrace: lbrace,
	lbrack: lbrack,
	lbrke: lbrke,
	lbrksld: lbrksld,
	lbrkslu: lbrkslu,
	Lcaron: Lcaron,
	lcaron: lcaron,
	Lcedil: Lcedil,
	lcedil: lcedil,
	lceil: lceil,
	lcub: lcub,
	Lcy: Lcy,
	lcy: lcy,
	ldca: ldca,
	ldquo: ldquo,
	ldquor: ldquor,
	ldrdhar: ldrdhar,
	ldrushar: ldrushar,
	ldsh: ldsh,
	le: le,
	lE: lE,
	LeftAngleBracket: LeftAngleBracket,
	LeftArrowBar: LeftArrowBar,
	leftarrow: leftarrow,
	LeftArrow: LeftArrow,
	Leftarrow: Leftarrow,
	LeftArrowRightArrow: LeftArrowRightArrow,
	leftarrowtail: leftarrowtail,
	LeftCeiling: LeftCeiling,
	LeftDoubleBracket: LeftDoubleBracket,
	LeftDownTeeVector: LeftDownTeeVector,
	LeftDownVectorBar: LeftDownVectorBar,
	LeftDownVector: LeftDownVector,
	LeftFloor: LeftFloor,
	leftharpoondown: leftharpoondown,
	leftharpoonup: leftharpoonup,
	leftleftarrows: leftleftarrows,
	leftrightarrow: leftrightarrow,
	LeftRightArrow: LeftRightArrow,
	Leftrightarrow: Leftrightarrow,
	leftrightarrows: leftrightarrows,
	leftrightharpoons: leftrightharpoons,
	leftrightsquigarrow: leftrightsquigarrow,
	LeftRightVector: LeftRightVector,
	LeftTeeArrow: LeftTeeArrow,
	LeftTee: LeftTee,
	LeftTeeVector: LeftTeeVector,
	leftthreetimes: leftthreetimes,
	LeftTriangleBar: LeftTriangleBar,
	LeftTriangle: LeftTriangle,
	LeftTriangleEqual: LeftTriangleEqual,
	LeftUpDownVector: LeftUpDownVector,
	LeftUpTeeVector: LeftUpTeeVector,
	LeftUpVectorBar: LeftUpVectorBar,
	LeftUpVector: LeftUpVector,
	LeftVectorBar: LeftVectorBar,
	LeftVector: LeftVector,
	lEg: lEg,
	leg: leg,
	leq: leq,
	leqq: leqq,
	leqslant: leqslant,
	lescc: lescc,
	les: les,
	lesdot: lesdot,
	lesdoto: lesdoto,
	lesdotor: lesdotor,
	lesg: lesg,
	lesges: lesges,
	lessapprox: lessapprox,
	lessdot: lessdot,
	lesseqgtr: lesseqgtr,
	lesseqqgtr: lesseqqgtr,
	LessEqualGreater: LessEqualGreater,
	LessFullEqual: LessFullEqual,
	LessGreater: LessGreater,
	lessgtr: lessgtr,
	LessLess: LessLess,
	lesssim: lesssim,
	LessSlantEqual: LessSlantEqual,
	LessTilde: LessTilde,
	lfisht: lfisht,
	lfloor: lfloor,
	Lfr: Lfr,
	lfr: lfr,
	lg: lg,
	lgE: lgE,
	lHar: lHar,
	lhard: lhard,
	lharu: lharu,
	lharul: lharul,
	lhblk: lhblk,
	LJcy: LJcy,
	ljcy: ljcy,
	llarr: llarr,
	ll: ll,
	Ll: Ll,
	llcorner: llcorner,
	Lleftarrow: Lleftarrow,
	llhard: llhard,
	lltri: lltri,
	Lmidot: Lmidot,
	lmidot: lmidot,
	lmoustache: lmoustache,
	lmoust: lmoust,
	lnap: lnap,
	lnapprox: lnapprox,
	lne: lne,
	lnE: lnE,
	lneq: lneq,
	lneqq: lneqq,
	lnsim: lnsim,
	loang: loang,
	loarr: loarr,
	lobrk: lobrk,
	longleftarrow: longleftarrow,
	LongLeftArrow: LongLeftArrow,
	Longleftarrow: Longleftarrow,
	longleftrightarrow: longleftrightarrow,
	LongLeftRightArrow: LongLeftRightArrow,
	Longleftrightarrow: Longleftrightarrow,
	longmapsto: longmapsto,
	longrightarrow: longrightarrow,
	LongRightArrow: LongRightArrow,
	Longrightarrow: Longrightarrow,
	looparrowleft: looparrowleft,
	looparrowright: looparrowright,
	lopar: lopar,
	Lopf: Lopf,
	lopf: lopf,
	loplus: loplus,
	lotimes: lotimes,
	lowast: lowast,
	lowbar: lowbar,
	LowerLeftArrow: LowerLeftArrow,
	LowerRightArrow: LowerRightArrow,
	loz: loz,
	lozenge: lozenge,
	lozf: lozf,
	lpar: lpar,
	lparlt: lparlt,
	lrarr: lrarr,
	lrcorner: lrcorner,
	lrhar: lrhar,
	lrhard: lrhard,
	lrm: lrm,
	lrtri: lrtri,
	lsaquo: lsaquo,
	lscr: lscr,
	Lscr: Lscr,
	lsh: lsh,
	Lsh: Lsh,
	lsim: lsim,
	lsime: lsime,
	lsimg: lsimg,
	lsqb: lsqb,
	lsquo: lsquo,
	lsquor: lsquor,
	Lstrok: Lstrok,
	lstrok: lstrok,
	ltcc: ltcc,
	ltcir: ltcir,
	lt: lt$1,
	LT: LT,
	Lt: Lt,
	ltdot: ltdot,
	lthree: lthree,
	ltimes: ltimes,
	ltlarr: ltlarr,
	ltquest: ltquest,
	ltri: ltri,
	ltrie: ltrie,
	ltrif: ltrif,
	ltrPar: ltrPar,
	lurdshar: lurdshar,
	luruhar: luruhar,
	lvertneqq: lvertneqq,
	lvnE: lvnE,
	macr: macr,
	male: male,
	malt: malt,
	maltese: maltese,
	map: map$1,
	mapsto: mapsto,
	mapstodown: mapstodown,
	mapstoleft: mapstoleft,
	mapstoup: mapstoup,
	marker: marker,
	mcomma: mcomma,
	Mcy: Mcy,
	mcy: mcy,
	mdash: mdash,
	mDDot: mDDot,
	measuredangle: measuredangle,
	MediumSpace: MediumSpace,
	Mellintrf: Mellintrf,
	Mfr: Mfr,
	mfr: mfr,
	mho: mho,
	micro: micro,
	midast: midast,
	midcir: midcir,
	mid: mid,
	middot: middot,
	minusb: minusb,
	minus: minus,
	minusd: minusd,
	minusdu: minusdu,
	MinusPlus: MinusPlus,
	mlcp: mlcp,
	mldr: mldr,
	mnplus: mnplus,
	models: models,
	Mopf: Mopf,
	mopf: mopf,
	mp: mp,
	mscr: mscr,
	Mscr: Mscr,
	mstpos: mstpos,
	Mu: Mu,
	mu: mu,
	multimap: multimap,
	mumap: mumap,
	nabla: nabla,
	Nacute: Nacute,
	nacute: nacute,
	nang: nang,
	nap: nap,
	napE: napE,
	napid: napid,
	napos: napos,
	napprox: napprox,
	natural: natural,
	naturals: naturals,
	natur: natur,
	nbsp: nbsp,
	nbump: nbump,
	nbumpe: nbumpe,
	ncap: ncap,
	Ncaron: Ncaron,
	ncaron: ncaron,
	Ncedil: Ncedil,
	ncedil: ncedil,
	ncong: ncong,
	ncongdot: ncongdot,
	ncup: ncup,
	Ncy: Ncy,
	ncy: ncy,
	ndash: ndash,
	nearhk: nearhk,
	nearr: nearr,
	neArr: neArr,
	nearrow: nearrow,
	ne: ne,
	nedot: nedot,
	NegativeMediumSpace: NegativeMediumSpace,
	NegativeThickSpace: NegativeThickSpace,
	NegativeThinSpace: NegativeThinSpace,
	NegativeVeryThinSpace: NegativeVeryThinSpace,
	nequiv: nequiv,
	nesear: nesear,
	nesim: nesim,
	NestedGreaterGreater: NestedGreaterGreater,
	NestedLessLess: NestedLessLess,
	NewLine: NewLine,
	nexist: nexist,
	nexists: nexists,
	Nfr: Nfr,
	nfr: nfr,
	ngE: ngE,
	nge: nge,
	ngeq: ngeq,
	ngeqq: ngeqq,
	ngeqslant: ngeqslant,
	nges: nges,
	nGg: nGg,
	ngsim: ngsim,
	nGt: nGt,
	ngt: ngt,
	ngtr: ngtr,
	nGtv: nGtv,
	nharr: nharr,
	nhArr: nhArr,
	nhpar: nhpar,
	ni: ni,
	nis: nis,
	nisd: nisd,
	niv: niv,
	NJcy: NJcy,
	njcy: njcy,
	nlarr: nlarr,
	nlArr: nlArr,
	nldr: nldr,
	nlE: nlE,
	nle: nle,
	nleftarrow: nleftarrow,
	nLeftarrow: nLeftarrow,
	nleftrightarrow: nleftrightarrow,
	nLeftrightarrow: nLeftrightarrow,
	nleq: nleq,
	nleqq: nleqq,
	nleqslant: nleqslant,
	nles: nles,
	nless: nless,
	nLl: nLl,
	nlsim: nlsim,
	nLt: nLt,
	nlt: nlt,
	nltri: nltri,
	nltrie: nltrie,
	nLtv: nLtv,
	nmid: nmid,
	NoBreak: NoBreak,
	NonBreakingSpace: NonBreakingSpace,
	nopf: nopf,
	Nopf: Nopf,
	Not: Not,
	not: not,
	NotCongruent: NotCongruent,
	NotCupCap: NotCupCap,
	NotDoubleVerticalBar: NotDoubleVerticalBar,
	NotElement: NotElement,
	NotEqual: NotEqual,
	NotEqualTilde: NotEqualTilde,
	NotExists: NotExists,
	NotGreater: NotGreater,
	NotGreaterEqual: NotGreaterEqual,
	NotGreaterFullEqual: NotGreaterFullEqual,
	NotGreaterGreater: NotGreaterGreater,
	NotGreaterLess: NotGreaterLess,
	NotGreaterSlantEqual: NotGreaterSlantEqual,
	NotGreaterTilde: NotGreaterTilde,
	NotHumpDownHump: NotHumpDownHump,
	NotHumpEqual: NotHumpEqual,
	notin: notin,
	notindot: notindot,
	notinE: notinE,
	notinva: notinva,
	notinvb: notinvb,
	notinvc: notinvc,
	NotLeftTriangleBar: NotLeftTriangleBar,
	NotLeftTriangle: NotLeftTriangle,
	NotLeftTriangleEqual: NotLeftTriangleEqual,
	NotLess: NotLess,
	NotLessEqual: NotLessEqual,
	NotLessGreater: NotLessGreater,
	NotLessLess: NotLessLess,
	NotLessSlantEqual: NotLessSlantEqual,
	NotLessTilde: NotLessTilde,
	NotNestedGreaterGreater: NotNestedGreaterGreater,
	NotNestedLessLess: NotNestedLessLess,
	notni: notni,
	notniva: notniva,
	notnivb: notnivb,
	notnivc: notnivc,
	NotPrecedes: NotPrecedes,
	NotPrecedesEqual: NotPrecedesEqual,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
	NotReverseElement: NotReverseElement,
	NotRightTriangleBar: NotRightTriangleBar,
	NotRightTriangle: NotRightTriangle,
	NotRightTriangleEqual: NotRightTriangleEqual,
	NotSquareSubset: NotSquareSubset,
	NotSquareSubsetEqual: NotSquareSubsetEqual,
	NotSquareSuperset: NotSquareSuperset,
	NotSquareSupersetEqual: NotSquareSupersetEqual,
	NotSubset: NotSubset,
	NotSubsetEqual: NotSubsetEqual,
	NotSucceeds: NotSucceeds,
	NotSucceedsEqual: NotSucceedsEqual,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
	NotSucceedsTilde: NotSucceedsTilde,
	NotSuperset: NotSuperset,
	NotSupersetEqual: NotSupersetEqual,
	NotTilde: NotTilde,
	NotTildeEqual: NotTildeEqual,
	NotTildeFullEqual: NotTildeFullEqual,
	NotTildeTilde: NotTildeTilde,
	NotVerticalBar: NotVerticalBar,
	nparallel: nparallel,
	npar: npar,
	nparsl: nparsl,
	npart: npart,
	npolint: npolint,
	npr: npr,
	nprcue: nprcue,
	nprec: nprec,
	npreceq: npreceq,
	npre: npre,
	nrarrc: nrarrc,
	nrarr: nrarr,
	nrArr: nrArr,
	nrarrw: nrarrw,
	nrightarrow: nrightarrow,
	nRightarrow: nRightarrow,
	nrtri: nrtri,
	nrtrie: nrtrie,
	nsc: nsc,
	nsccue: nsccue,
	nsce: nsce,
	Nscr: Nscr,
	nscr: nscr,
	nshortmid: nshortmid,
	nshortparallel: nshortparallel,
	nsim: nsim,
	nsime: nsime,
	nsimeq: nsimeq,
	nsmid: nsmid,
	nspar: nspar,
	nsqsube: nsqsube,
	nsqsupe: nsqsupe,
	nsub: nsub,
	nsubE: nsubE,
	nsube: nsube,
	nsubset: nsubset,
	nsubseteq: nsubseteq,
	nsubseteqq: nsubseteqq,
	nsucc: nsucc,
	nsucceq: nsucceq,
	nsup: nsup,
	nsupE: nsupE,
	nsupe: nsupe,
	nsupset: nsupset,
	nsupseteq: nsupseteq,
	nsupseteqq: nsupseteqq,
	ntgl: ntgl,
	Ntilde: Ntilde,
	ntilde: ntilde,
	ntlg: ntlg,
	ntriangleleft: ntriangleleft,
	ntrianglelefteq: ntrianglelefteq,
	ntriangleright: ntriangleright,
	ntrianglerighteq: ntrianglerighteq,
	Nu: Nu,
	nu: nu,
	num: num,
	numero: numero,
	numsp: numsp,
	nvap: nvap,
	nvdash: nvdash,
	nvDash: nvDash,
	nVdash: nVdash,
	nVDash: nVDash,
	nvge: nvge,
	nvgt: nvgt,
	nvHarr: nvHarr,
	nvinfin: nvinfin,
	nvlArr: nvlArr,
	nvle: nvle,
	nvlt: nvlt,
	nvltrie: nvltrie,
	nvrArr: nvrArr,
	nvrtrie: nvrtrie,
	nvsim: nvsim,
	nwarhk: nwarhk,
	nwarr: nwarr,
	nwArr: nwArr,
	nwarrow: nwarrow,
	nwnear: nwnear,
	Oacute: Oacute,
	oacute: oacute,
	oast: oast,
	Ocirc: Ocirc,
	ocirc: ocirc,
	ocir: ocir,
	Ocy: Ocy,
	ocy: ocy,
	odash: odash,
	Odblac: Odblac,
	odblac: odblac,
	odiv: odiv,
	odot: odot,
	odsold: odsold,
	OElig: OElig,
	oelig: oelig,
	ofcir: ofcir,
	Ofr: Ofr,
	ofr: ofr,
	ogon: ogon,
	Ograve: Ograve,
	ograve: ograve,
	ogt: ogt,
	ohbar: ohbar,
	ohm: ohm,
	oint: oint,
	olarr: olarr,
	olcir: olcir,
	olcross: olcross,
	oline: oline,
	olt: olt,
	Omacr: Omacr,
	omacr: omacr,
	Omega: Omega,
	omega: omega,
	Omicron: Omicron,
	omicron: omicron,
	omid: omid,
	ominus: ominus,
	Oopf: Oopf,
	oopf: oopf,
	opar: opar,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
	OpenCurlyQuote: OpenCurlyQuote,
	operp: operp,
	oplus: oplus,
	orarr: orarr,
	Or: Or,
	or: or,
	ord: ord,
	order: order,
	orderof: orderof,
	ordf: ordf,
	ordm: ordm,
	origof: origof,
	oror: oror,
	orslope: orslope,
	orv: orv,
	oS: oS,
	Oscr: Oscr,
	oscr: oscr,
	Oslash: Oslash,
	oslash: oslash,
	osol: osol,
	Otilde: Otilde,
	otilde: otilde,
	otimesas: otimesas,
	Otimes: Otimes,
	otimes: otimes,
	Ouml: Ouml,
	ouml: ouml,
	ovbar: ovbar,
	OverBar: OverBar,
	OverBrace: OverBrace,
	OverBracket: OverBracket,
	OverParenthesis: OverParenthesis,
	para: para,
	parallel: parallel,
	par: par,
	parsim: parsim,
	parsl: parsl,
	part: part,
	PartialD: PartialD,
	Pcy: Pcy,
	pcy: pcy,
	percnt: percnt,
	period: period,
	permil: permil,
	perp: perp,
	pertenk: pertenk,
	Pfr: Pfr,
	pfr: pfr,
	Phi: Phi,
	phi: phi,
	phiv: phiv,
	phmmat: phmmat,
	phone: phone,
	Pi: Pi,
	pi: pi,
	pitchfork: pitchfork,
	piv: piv,
	planck: planck,
	planckh: planckh,
	plankv: plankv,
	plusacir: plusacir,
	plusb: plusb,
	pluscir: pluscir,
	plus: plus,
	plusdo: plusdo,
	plusdu: plusdu,
	pluse: pluse,
	PlusMinus: PlusMinus,
	plusmn: plusmn,
	plussim: plussim,
	plustwo: plustwo,
	pm: pm,
	Poincareplane: Poincareplane,
	pointint: pointint,
	popf: popf,
	Popf: Popf,
	pound: pound,
	prap: prap,
	Pr: Pr,
	pr: pr,
	prcue: prcue,
	precapprox: precapprox,
	prec: prec,
	preccurlyeq: preccurlyeq,
	Precedes: Precedes,
	PrecedesEqual: PrecedesEqual,
	PrecedesSlantEqual: PrecedesSlantEqual,
	PrecedesTilde: PrecedesTilde,
	preceq: preceq,
	precnapprox: precnapprox,
	precneqq: precneqq,
	precnsim: precnsim,
	pre: pre,
	prE: prE,
	precsim: precsim,
	prime: prime,
	Prime: Prime,
	primes: primes,
	prnap: prnap,
	prnE: prnE,
	prnsim: prnsim,
	prod: prod,
	Product: Product,
	profalar: profalar,
	profline: profline,
	profsurf: profsurf,
	prop: prop,
	Proportional: Proportional,
	Proportion: Proportion,
	propto: propto,
	prsim: prsim,
	prurel: prurel,
	Pscr: Pscr,
	pscr: pscr,
	Psi: Psi,
	psi: psi,
	puncsp: puncsp,
	Qfr: Qfr,
	qfr: qfr,
	qint: qint,
	qopf: qopf,
	Qopf: Qopf,
	qprime: qprime,
	Qscr: Qscr,
	qscr: qscr,
	quaternions: quaternions,
	quatint: quatint,
	quest: quest,
	questeq: questeq,
	quot: quot$1,
	QUOT: QUOT,
	rAarr: rAarr,
	race: race,
	Racute: Racute,
	racute: racute,
	radic: radic,
	raemptyv: raemptyv,
	rang: rang,
	Rang: Rang,
	rangd: rangd,
	range: range,
	rangle: rangle,
	raquo: raquo,
	rarrap: rarrap,
	rarrb: rarrb,
	rarrbfs: rarrbfs,
	rarrc: rarrc,
	rarr: rarr,
	Rarr: Rarr,
	rArr: rArr,
	rarrfs: rarrfs,
	rarrhk: rarrhk,
	rarrlp: rarrlp,
	rarrpl: rarrpl,
	rarrsim: rarrsim,
	Rarrtl: Rarrtl,
	rarrtl: rarrtl,
	rarrw: rarrw,
	ratail: ratail,
	rAtail: rAtail,
	ratio: ratio,
	rationals: rationals,
	rbarr: rbarr,
	rBarr: rBarr,
	RBarr: RBarr,
	rbbrk: rbbrk,
	rbrace: rbrace,
	rbrack: rbrack,
	rbrke: rbrke,
	rbrksld: rbrksld,
	rbrkslu: rbrkslu,
	Rcaron: Rcaron,
	rcaron: rcaron,
	Rcedil: Rcedil,
	rcedil: rcedil,
	rceil: rceil,
	rcub: rcub,
	Rcy: Rcy,
	rcy: rcy,
	rdca: rdca,
	rdldhar: rdldhar,
	rdquo: rdquo,
	rdquor: rdquor,
	rdsh: rdsh,
	real: real,
	realine: realine,
	realpart: realpart,
	reals: reals,
	Re: Re,
	rect: rect,
	reg: reg,
	REG: REG,
	ReverseElement: ReverseElement,
	ReverseEquilibrium: ReverseEquilibrium,
	ReverseUpEquilibrium: ReverseUpEquilibrium,
	rfisht: rfisht,
	rfloor: rfloor,
	rfr: rfr,
	Rfr: Rfr,
	rHar: rHar,
	rhard: rhard,
	rharu: rharu,
	rharul: rharul,
	Rho: Rho,
	rho: rho,
	rhov: rhov,
	RightAngleBracket: RightAngleBracket,
	RightArrowBar: RightArrowBar,
	rightarrow: rightarrow,
	RightArrow: RightArrow,
	Rightarrow: Rightarrow,
	RightArrowLeftArrow: RightArrowLeftArrow,
	rightarrowtail: rightarrowtail,
	RightCeiling: RightCeiling,
	RightDoubleBracket: RightDoubleBracket,
	RightDownTeeVector: RightDownTeeVector,
	RightDownVectorBar: RightDownVectorBar,
	RightDownVector: RightDownVector,
	RightFloor: RightFloor,
	rightharpoondown: rightharpoondown,
	rightharpoonup: rightharpoonup,
	rightleftarrows: rightleftarrows,
	rightleftharpoons: rightleftharpoons,
	rightrightarrows: rightrightarrows,
	rightsquigarrow: rightsquigarrow,
	RightTeeArrow: RightTeeArrow,
	RightTee: RightTee,
	RightTeeVector: RightTeeVector,
	rightthreetimes: rightthreetimes,
	RightTriangleBar: RightTriangleBar,
	RightTriangle: RightTriangle,
	RightTriangleEqual: RightTriangleEqual,
	RightUpDownVector: RightUpDownVector,
	RightUpTeeVector: RightUpTeeVector,
	RightUpVectorBar: RightUpVectorBar,
	RightUpVector: RightUpVector,
	RightVectorBar: RightVectorBar,
	RightVector: RightVector,
	ring: ring,
	risingdotseq: risingdotseq,
	rlarr: rlarr,
	rlhar: rlhar,
	rlm: rlm,
	rmoustache: rmoustache,
	rmoust: rmoust,
	rnmid: rnmid,
	roang: roang,
	roarr: roarr,
	robrk: robrk,
	ropar: ropar,
	ropf: ropf,
	Ropf: Ropf,
	roplus: roplus,
	rotimes: rotimes,
	RoundImplies: RoundImplies,
	rpar: rpar,
	rpargt: rpargt,
	rppolint: rppolint,
	rrarr: rrarr,
	Rrightarrow: Rrightarrow,
	rsaquo: rsaquo,
	rscr: rscr,
	Rscr: Rscr,
	rsh: rsh,
	Rsh: Rsh,
	rsqb: rsqb,
	rsquo: rsquo,
	rsquor: rsquor,
	rthree: rthree,
	rtimes: rtimes,
	rtri: rtri,
	rtrie: rtrie,
	rtrif: rtrif,
	rtriltri: rtriltri,
	RuleDelayed: RuleDelayed,
	ruluhar: ruluhar,
	rx: rx,
	Sacute: Sacute,
	sacute: sacute,
	sbquo: sbquo,
	scap: scap,
	Scaron: Scaron,
	scaron: scaron,
	Sc: Sc,
	sc: sc,
	sccue: sccue,
	sce: sce,
	scE: scE,
	Scedil: Scedil,
	scedil: scedil,
	Scirc: Scirc,
	scirc: scirc,
	scnap: scnap,
	scnE: scnE,
	scnsim: scnsim,
	scpolint: scpolint,
	scsim: scsim,
	Scy: Scy,
	scy: scy,
	sdotb: sdotb,
	sdot: sdot,
	sdote: sdote,
	searhk: searhk,
	searr: searr,
	seArr: seArr,
	searrow: searrow,
	sect: sect,
	semi: semi,
	seswar: seswar,
	setminus: setminus,
	setmn: setmn,
	sext: sext,
	Sfr: Sfr,
	sfr: sfr,
	sfrown: sfrown,
	sharp: sharp,
	SHCHcy: SHCHcy,
	shchcy: shchcy,
	SHcy: SHcy,
	shcy: shcy,
	ShortDownArrow: ShortDownArrow,
	ShortLeftArrow: ShortLeftArrow,
	shortmid: shortmid,
	shortparallel: shortparallel,
	ShortRightArrow: ShortRightArrow,
	ShortUpArrow: ShortUpArrow,
	shy: shy,
	Sigma: Sigma,
	sigma: sigma,
	sigmaf: sigmaf,
	sigmav: sigmav,
	sim: sim,
	simdot: simdot,
	sime: sime,
	simeq: simeq,
	simg: simg,
	simgE: simgE,
	siml: siml,
	simlE: simlE,
	simne: simne,
	simplus: simplus,
	simrarr: simrarr,
	slarr: slarr,
	SmallCircle: SmallCircle,
	smallsetminus: smallsetminus,
	smashp: smashp,
	smeparsl: smeparsl,
	smid: smid,
	smile: smile,
	smt: smt,
	smte: smte,
	smtes: smtes,
	SOFTcy: SOFTcy,
	softcy: softcy,
	solbar: solbar,
	solb: solb,
	sol: sol,
	Sopf: Sopf,
	sopf: sopf,
	spades: spades,
	spadesuit: spadesuit,
	spar: spar,
	sqcap: sqcap,
	sqcaps: sqcaps,
	sqcup: sqcup,
	sqcups: sqcups,
	Sqrt: Sqrt,
	sqsub: sqsub,
	sqsube: sqsube,
	sqsubset: sqsubset,
	sqsubseteq: sqsubseteq,
	sqsup: sqsup,
	sqsupe: sqsupe,
	sqsupset: sqsupset,
	sqsupseteq: sqsupseteq,
	square: square,
	Square: Square,
	SquareIntersection: SquareIntersection,
	SquareSubset: SquareSubset,
	SquareSubsetEqual: SquareSubsetEqual,
	SquareSuperset: SquareSuperset,
	SquareSupersetEqual: SquareSupersetEqual,
	SquareUnion: SquareUnion,
	squarf: squarf,
	squ: squ,
	squf: squf,
	srarr: srarr,
	Sscr: Sscr,
	sscr: sscr,
	ssetmn: ssetmn,
	ssmile: ssmile,
	sstarf: sstarf,
	Star: Star,
	star: star,
	starf: starf,
	straightepsilon: straightepsilon,
	straightphi: straightphi,
	strns: strns,
	sub: sub,
	Sub: Sub,
	subdot: subdot,
	subE: subE,
	sube: sube,
	subedot: subedot,
	submult: submult,
	subnE: subnE,
	subne: subne,
	subplus: subplus,
	subrarr: subrarr,
	subset: subset,
	Subset: Subset,
	subseteq: subseteq,
	subseteqq: subseteqq,
	SubsetEqual: SubsetEqual,
	subsetneq: subsetneq,
	subsetneqq: subsetneqq,
	subsim: subsim,
	subsub: subsub,
	subsup: subsup,
	succapprox: succapprox,
	succ: succ,
	succcurlyeq: succcurlyeq,
	Succeeds: Succeeds,
	SucceedsEqual: SucceedsEqual,
	SucceedsSlantEqual: SucceedsSlantEqual,
	SucceedsTilde: SucceedsTilde,
	succeq: succeq,
	succnapprox: succnapprox,
	succneqq: succneqq,
	succnsim: succnsim,
	succsim: succsim,
	SuchThat: SuchThat,
	sum: sum,
	Sum: Sum,
	sung: sung,
	sup1: sup1,
	sup2: sup2,
	sup3: sup3,
	sup: sup,
	Sup: Sup,
	supdot: supdot,
	supdsub: supdsub,
	supE: supE,
	supe: supe,
	supedot: supedot,
	Superset: Superset,
	SupersetEqual: SupersetEqual,
	suphsol: suphsol,
	suphsub: suphsub,
	suplarr: suplarr,
	supmult: supmult,
	supnE: supnE,
	supne: supne,
	supplus: supplus,
	supset: supset,
	Supset: Supset,
	supseteq: supseteq,
	supseteqq: supseteqq,
	supsetneq: supsetneq,
	supsetneqq: supsetneqq,
	supsim: supsim,
	supsub: supsub,
	supsup: supsup,
	swarhk: swarhk,
	swarr: swarr,
	swArr: swArr,
	swarrow: swarrow,
	swnwar: swnwar,
	szlig: szlig,
	Tab: Tab,
	target: target,
	Tau: Tau,
	tau: tau,
	tbrk: tbrk,
	Tcaron: Tcaron,
	tcaron: tcaron,
	Tcedil: Tcedil,
	tcedil: tcedil,
	Tcy: Tcy,
	tcy: tcy,
	tdot: tdot,
	telrec: telrec,
	Tfr: Tfr,
	tfr: tfr,
	there4: there4,
	therefore: therefore,
	Therefore: Therefore,
	Theta: Theta,
	theta: theta,
	thetasym: thetasym,
	thetav: thetav,
	thickapprox: thickapprox,
	thicksim: thicksim,
	ThickSpace: ThickSpace,
	ThinSpace: ThinSpace,
	thinsp: thinsp,
	thkap: thkap,
	thksim: thksim,
	THORN: THORN,
	thorn: thorn,
	tilde: tilde,
	Tilde: Tilde,
	TildeEqual: TildeEqual,
	TildeFullEqual: TildeFullEqual,
	TildeTilde: TildeTilde,
	timesbar: timesbar,
	timesb: timesb,
	times: times$1,
	timesd: timesd,
	tint: tint,
	toea: toea,
	topbot: topbot,
	topcir: topcir,
	top: top,
	Topf: Topf,
	topf: topf,
	topfork: topfork,
	tosa: tosa,
	tprime: tprime,
	trade: trade,
	TRADE: TRADE,
	triangle: triangle,
	triangledown: triangledown,
	triangleleft: triangleleft,
	trianglelefteq: trianglelefteq,
	triangleq: triangleq,
	triangleright: triangleright,
	trianglerighteq: trianglerighteq,
	tridot: tridot,
	trie: trie,
	triminus: triminus,
	TripleDot: TripleDot,
	triplus: triplus,
	trisb: trisb,
	tritime: tritime,
	trpezium: trpezium,
	Tscr: Tscr,
	tscr: tscr,
	TScy: TScy,
	tscy: tscy,
	TSHcy: TSHcy,
	tshcy: tshcy,
	Tstrok: Tstrok,
	tstrok: tstrok,
	twixt: twixt,
	twoheadleftarrow: twoheadleftarrow,
	twoheadrightarrow: twoheadrightarrow,
	Uacute: Uacute,
	uacute: uacute,
	uarr: uarr,
	Uarr: Uarr,
	uArr: uArr,
	Uarrocir: Uarrocir,
	Ubrcy: Ubrcy,
	ubrcy: ubrcy,
	Ubreve: Ubreve,
	ubreve: ubreve,
	Ucirc: Ucirc,
	ucirc: ucirc,
	Ucy: Ucy,
	ucy: ucy,
	udarr: udarr,
	Udblac: Udblac,
	udblac: udblac,
	udhar: udhar,
	ufisht: ufisht,
	Ufr: Ufr,
	ufr: ufr,
	Ugrave: Ugrave,
	ugrave: ugrave,
	uHar: uHar,
	uharl: uharl,
	uharr: uharr,
	uhblk: uhblk,
	ulcorn: ulcorn,
	ulcorner: ulcorner,
	ulcrop: ulcrop,
	ultri: ultri,
	Umacr: Umacr,
	umacr: umacr,
	uml: uml,
	UnderBar: UnderBar,
	UnderBrace: UnderBrace,
	UnderBracket: UnderBracket,
	UnderParenthesis: UnderParenthesis,
	Union: Union,
	UnionPlus: UnionPlus,
	Uogon: Uogon,
	uogon: uogon,
	Uopf: Uopf,
	uopf: uopf,
	UpArrowBar: UpArrowBar,
	uparrow: uparrow,
	UpArrow: UpArrow,
	Uparrow: Uparrow,
	UpArrowDownArrow: UpArrowDownArrow,
	updownarrow: updownarrow,
	UpDownArrow: UpDownArrow,
	Updownarrow: Updownarrow,
	UpEquilibrium: UpEquilibrium,
	upharpoonleft: upharpoonleft,
	upharpoonright: upharpoonright,
	uplus: uplus,
	UpperLeftArrow: UpperLeftArrow,
	UpperRightArrow: UpperRightArrow,
	upsi: upsi,
	Upsi: Upsi,
	upsih: upsih,
	Upsilon: Upsilon,
	upsilon: upsilon,
	UpTeeArrow: UpTeeArrow,
	UpTee: UpTee,
	upuparrows: upuparrows,
	urcorn: urcorn,
	urcorner: urcorner,
	urcrop: urcrop,
	Uring: Uring,
	uring: uring,
	urtri: urtri,
	Uscr: Uscr,
	uscr: uscr,
	utdot: utdot,
	Utilde: Utilde,
	utilde: utilde,
	utri: utri,
	utrif: utrif,
	uuarr: uuarr,
	Uuml: Uuml,
	uuml: uuml,
	uwangle: uwangle,
	vangrt: vangrt,
	varepsilon: varepsilon,
	varkappa: varkappa,
	varnothing: varnothing,
	varphi: varphi,
	varpi: varpi,
	varpropto: varpropto,
	varr: varr,
	vArr: vArr,
	varrho: varrho,
	varsigma: varsigma,
	varsubsetneq: varsubsetneq,
	varsubsetneqq: varsubsetneqq,
	varsupsetneq: varsupsetneq,
	varsupsetneqq: varsupsetneqq,
	vartheta: vartheta,
	vartriangleleft: vartriangleleft,
	vartriangleright: vartriangleright,
	vBar: vBar,
	Vbar: Vbar,
	vBarv: vBarv,
	Vcy: Vcy,
	vcy: vcy,
	vdash: vdash,
	vDash: vDash,
	Vdash: Vdash,
	VDash: VDash,
	Vdashl: Vdashl,
	veebar: veebar,
	vee: vee,
	Vee: Vee,
	veeeq: veeeq,
	vellip: vellip,
	verbar: verbar,
	Verbar: Verbar,
	vert: vert,
	Vert: Vert,
	VerticalBar: VerticalBar,
	VerticalLine: VerticalLine,
	VerticalSeparator: VerticalSeparator,
	VerticalTilde: VerticalTilde,
	VeryThinSpace: VeryThinSpace,
	Vfr: Vfr,
	vfr: vfr,
	vltri: vltri,
	vnsub: vnsub,
	vnsup: vnsup,
	Vopf: Vopf,
	vopf: vopf,
	vprop: vprop,
	vrtri: vrtri,
	Vscr: Vscr,
	vscr: vscr,
	vsubnE: vsubnE,
	vsubne: vsubne,
	vsupnE: vsupnE,
	vsupne: vsupne,
	Vvdash: Vvdash,
	vzigzag: vzigzag,
	Wcirc: Wcirc,
	wcirc: wcirc,
	wedbar: wedbar,
	wedge: wedge,
	Wedge: Wedge,
	wedgeq: wedgeq,
	weierp: weierp,
	Wfr: Wfr,
	wfr: wfr,
	Wopf: Wopf,
	wopf: wopf,
	wp: wp,
	wr: wr,
	wreath: wreath,
	Wscr: Wscr,
	wscr: wscr,
	xcap: xcap,
	xcirc: xcirc,
	xcup: xcup,
	xdtri: xdtri,
	Xfr: Xfr,
	xfr: xfr,
	xharr: xharr,
	xhArr: xhArr,
	Xi: Xi,
	xi: xi,
	xlarr: xlarr,
	xlArr: xlArr,
	xmap: xmap,
	xnis: xnis,
	xodot: xodot,
	Xopf: Xopf,
	xopf: xopf,
	xoplus: xoplus,
	xotime: xotime,
	xrarr: xrarr,
	xrArr: xrArr,
	Xscr: Xscr,
	xscr: xscr,
	xsqcup: xsqcup,
	xuplus: xuplus,
	xutri: xutri,
	xvee: xvee,
	xwedge: xwedge,
	Yacute: Yacute,
	yacute: yacute,
	YAcy: YAcy,
	yacy: yacy,
	Ycirc: Ycirc,
	ycirc: ycirc,
	Ycy: Ycy,
	ycy: ycy,
	yen: yen,
	Yfr: Yfr,
	yfr: yfr,
	YIcy: YIcy,
	yicy: yicy,
	Yopf: Yopf,
	yopf: yopf,
	Yscr: Yscr,
	yscr: yscr,
	YUcy: YUcy,
	yucy: yucy,
	yuml: yuml,
	Yuml: Yuml,
	Zacute: Zacute,
	zacute: zacute,
	Zcaron: Zcaron,
	zcaron: zcaron,
	Zcy: Zcy,
	zcy: zcy,
	Zdot: Zdot,
	zdot: zdot,
	zeetrf: zeetrf,
	ZeroWidthSpace: ZeroWidthSpace,
	Zeta: Zeta,
	zeta: zeta,
	zfr: zfr,
	Zfr: Zfr,
	ZHcy: ZHcy,
	zhcy: zhcy,
	zigrarr: zigrarr,
	zopf: zopf,
	Zopf: Zopf,
	Zscr: Zscr,
	zscr: zscr,
	zwj: zwj,
	zwnj: zwnj,
	"in": "",
	"Map": ""
};

var entities = Object.freeze({
	Aacute: Aacute,
	aacute: aacute,
	Abreve: Abreve,
	abreve: abreve,
	ac: ac,
	acd: acd,
	acE: acE,
	Acirc: Acirc,
	acirc: acirc,
	acute: acute,
	Acy: Acy,
	acy: acy,
	AElig: AElig,
	aelig: aelig,
	af: af,
	Afr: Afr,
	afr: afr,
	Agrave: Agrave,
	agrave: agrave,
	alefsym: alefsym,
	aleph: aleph,
	Alpha: Alpha,
	alpha: alpha,
	Amacr: Amacr,
	amacr: amacr,
	amalg: amalg,
	amp: amp$1,
	AMP: AMP,
	andand: andand,
	And: And,
	and: and,
	andd: andd,
	andslope: andslope,
	andv: andv,
	ang: ang,
	ange: ange,
	angle: angle,
	angmsdaa: angmsdaa,
	angmsdab: angmsdab,
	angmsdac: angmsdac,
	angmsdad: angmsdad,
	angmsdae: angmsdae,
	angmsdaf: angmsdaf,
	angmsdag: angmsdag,
	angmsdah: angmsdah,
	angmsd: angmsd,
	angrt: angrt,
	angrtvb: angrtvb,
	angrtvbd: angrtvbd,
	angsph: angsph,
	angst: angst,
	angzarr: angzarr,
	Aogon: Aogon,
	aogon: aogon,
	Aopf: Aopf,
	aopf: aopf,
	apacir: apacir,
	ap: ap,
	apE: apE,
	ape: ape,
	apid: apid,
	apos: apos$1,
	ApplyFunction: ApplyFunction,
	approx: approx,
	approxeq: approxeq,
	Aring: Aring,
	aring: aring,
	Ascr: Ascr,
	ascr: ascr,
	Assign: Assign,
	ast: ast,
	asymp: asymp,
	asympeq: asympeq,
	Atilde: Atilde,
	atilde: atilde,
	Auml: Auml,
	auml: auml,
	awconint: awconint,
	awint: awint,
	backcong: backcong,
	backepsilon: backepsilon,
	backprime: backprime,
	backsim: backsim,
	backsimeq: backsimeq,
	Backslash: Backslash,
	Barv: Barv,
	barvee: barvee,
	barwed: barwed,
	Barwed: Barwed,
	barwedge: barwedge,
	bbrk: bbrk,
	bbrktbrk: bbrktbrk,
	bcong: bcong,
	Bcy: Bcy,
	bcy: bcy,
	bdquo: bdquo,
	becaus: becaus,
	because: because,
	Because: Because,
	bemptyv: bemptyv,
	bepsi: bepsi,
	bernou: bernou,
	Bernoullis: Bernoullis,
	Beta: Beta,
	beta: beta,
	beth: beth,
	between: between,
	Bfr: Bfr,
	bfr: bfr,
	bigcap: bigcap,
	bigcirc: bigcirc,
	bigcup: bigcup,
	bigodot: bigodot,
	bigoplus: bigoplus,
	bigotimes: bigotimes,
	bigsqcup: bigsqcup,
	bigstar: bigstar,
	bigtriangledown: bigtriangledown,
	bigtriangleup: bigtriangleup,
	biguplus: biguplus,
	bigvee: bigvee,
	bigwedge: bigwedge,
	bkarow: bkarow,
	blacklozenge: blacklozenge,
	blacksquare: blacksquare,
	blacktriangle: blacktriangle,
	blacktriangledown: blacktriangledown,
	blacktriangleleft: blacktriangleleft,
	blacktriangleright: blacktriangleright,
	blank: blank,
	blk12: blk12,
	blk14: blk14,
	blk34: blk34,
	block: block,
	bne: bne,
	bnequiv: bnequiv,
	bNot: bNot,
	bnot: bnot,
	Bopf: Bopf,
	bopf: bopf,
	bot: bot,
	bottom: bottom,
	bowtie: bowtie,
	boxbox: boxbox,
	boxdl: boxdl,
	boxdL: boxdL,
	boxDl: boxDl,
	boxDL: boxDL,
	boxdr: boxdr,
	boxdR: boxdR,
	boxDr: boxDr,
	boxDR: boxDR,
	boxh: boxh,
	boxH: boxH,
	boxhd: boxhd,
	boxHd: boxHd,
	boxhD: boxhD,
	boxHD: boxHD,
	boxhu: boxhu,
	boxHu: boxHu,
	boxhU: boxhU,
	boxHU: boxHU,
	boxminus: boxminus,
	boxplus: boxplus,
	boxtimes: boxtimes,
	boxul: boxul,
	boxuL: boxuL,
	boxUl: boxUl,
	boxUL: boxUL,
	boxur: boxur,
	boxuR: boxuR,
	boxUr: boxUr,
	boxUR: boxUR,
	boxv: boxv,
	boxV: boxV,
	boxvh: boxvh,
	boxvH: boxvH,
	boxVh: boxVh,
	boxVH: boxVH,
	boxvl: boxvl,
	boxvL: boxvL,
	boxVl: boxVl,
	boxVL: boxVL,
	boxvr: boxvr,
	boxvR: boxvR,
	boxVr: boxVr,
	boxVR: boxVR,
	bprime: bprime,
	breve: breve,
	Breve: Breve,
	brvbar: brvbar,
	bscr: bscr,
	Bscr: Bscr,
	bsemi: bsemi,
	bsim: bsim,
	bsime: bsime,
	bsolb: bsolb,
	bsol: bsol,
	bsolhsub: bsolhsub,
	bull: bull,
	bullet: bullet,
	bump: bump,
	bumpE: bumpE,
	bumpe: bumpe,
	Bumpeq: Bumpeq,
	bumpeq: bumpeq,
	Cacute: Cacute,
	cacute: cacute,
	capand: capand,
	capbrcup: capbrcup,
	capcap: capcap,
	cap: cap,
	Cap: Cap,
	capcup: capcup,
	capdot: capdot,
	CapitalDifferentialD: CapitalDifferentialD,
	caps: caps,
	caret: caret,
	caron: caron,
	Cayleys: Cayleys,
	ccaps: ccaps,
	Ccaron: Ccaron,
	ccaron: ccaron,
	Ccedil: Ccedil,
	ccedil: ccedil,
	Ccirc: Ccirc,
	ccirc: ccirc,
	Cconint: Cconint,
	ccups: ccups,
	ccupssm: ccupssm,
	Cdot: Cdot,
	cdot: cdot,
	cedil: cedil,
	Cedilla: Cedilla,
	cemptyv: cemptyv,
	cent: cent,
	centerdot: centerdot,
	CenterDot: CenterDot,
	cfr: cfr,
	Cfr: Cfr,
	CHcy: CHcy,
	chcy: chcy,
	check: check,
	checkmark: checkmark,
	Chi: Chi,
	chi: chi,
	circ: circ,
	circeq: circeq,
	circlearrowleft: circlearrowleft,
	circlearrowright: circlearrowright,
	circledast: circledast,
	circledcirc: circledcirc,
	circleddash: circleddash,
	CircleDot: CircleDot,
	circledR: circledR,
	circledS: circledS,
	CircleMinus: CircleMinus,
	CirclePlus: CirclePlus,
	CircleTimes: CircleTimes,
	cir: cir,
	cirE: cirE,
	cire: cire,
	cirfnint: cirfnint,
	cirmid: cirmid,
	cirscir: cirscir,
	ClockwiseContourIntegral: ClockwiseContourIntegral,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
	CloseCurlyQuote: CloseCurlyQuote,
	clubs: clubs,
	clubsuit: clubsuit,
	colon: colon,
	Colon: Colon,
	Colone: Colone,
	colone: colone,
	coloneq: coloneq,
	comma: comma,
	commat: commat,
	comp: comp,
	compfn: compfn,
	complement: complement,
	complexes: complexes,
	cong: cong,
	congdot: congdot,
	Congruent: Congruent,
	conint: conint,
	Conint: Conint,
	ContourIntegral: ContourIntegral,
	copf: copf,
	Copf: Copf,
	coprod: coprod,
	Coproduct: Coproduct,
	copy: copy,
	COPY: COPY,
	copysr: copysr,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
	crarr: crarr,
	cross: cross,
	Cross: Cross,
	Cscr: Cscr,
	cscr: cscr,
	csub: csub,
	csube: csube,
	csup: csup,
	csupe: csupe,
	ctdot: ctdot,
	cudarrl: cudarrl,
	cudarrr: cudarrr,
	cuepr: cuepr,
	cuesc: cuesc,
	cularr: cularr,
	cularrp: cularrp,
	cupbrcap: cupbrcap,
	cupcap: cupcap,
	CupCap: CupCap,
	cup: cup,
	Cup: Cup,
	cupcup: cupcup,
	cupdot: cupdot,
	cupor: cupor,
	cups: cups,
	curarr: curarr,
	curarrm: curarrm,
	curlyeqprec: curlyeqprec,
	curlyeqsucc: curlyeqsucc,
	curlyvee: curlyvee,
	curlywedge: curlywedge,
	curren: curren,
	curvearrowleft: curvearrowleft,
	curvearrowright: curvearrowright,
	cuvee: cuvee,
	cuwed: cuwed,
	cwconint: cwconint,
	cwint: cwint,
	cylcty: cylcty,
	dagger: dagger,
	Dagger: Dagger,
	daleth: daleth,
	darr: darr,
	Darr: Darr,
	dArr: dArr,
	dash: dash,
	Dashv: Dashv,
	dashv: dashv,
	dbkarow: dbkarow,
	dblac: dblac,
	Dcaron: Dcaron,
	dcaron: dcaron,
	Dcy: Dcy,
	dcy: dcy,
	ddagger: ddagger,
	ddarr: ddarr,
	DD: DD,
	dd: dd,
	DDotrahd: DDotrahd,
	ddotseq: ddotseq,
	deg: deg,
	Del: Del,
	Delta: Delta,
	delta: delta,
	demptyv: demptyv,
	dfisht: dfisht,
	Dfr: Dfr,
	dfr: dfr,
	dHar: dHar,
	dharl: dharl,
	dharr: dharr,
	DiacriticalAcute: DiacriticalAcute,
	DiacriticalDot: DiacriticalDot,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
	DiacriticalGrave: DiacriticalGrave,
	DiacriticalTilde: DiacriticalTilde,
	diam: diam,
	diamond: diamond,
	Diamond: Diamond,
	diamondsuit: diamondsuit,
	diams: diams,
	die: die,
	DifferentialD: DifferentialD,
	digamma: digamma,
	disin: disin,
	div: div,
	divide: divide,
	divideontimes: divideontimes,
	divonx: divonx,
	DJcy: DJcy,
	djcy: djcy,
	dlcorn: dlcorn,
	dlcrop: dlcrop,
	dollar: dollar,
	Dopf: Dopf,
	dopf: dopf,
	Dot: Dot,
	dot: dot,
	DotDot: DotDot,
	doteq: doteq,
	doteqdot: doteqdot,
	DotEqual: DotEqual,
	dotminus: dotminus,
	dotplus: dotplus,
	dotsquare: dotsquare,
	doublebarwedge: doublebarwedge,
	DoubleContourIntegral: DoubleContourIntegral,
	DoubleDot: DoubleDot,
	DoubleDownArrow: DoubleDownArrow,
	DoubleLeftArrow: DoubleLeftArrow,
	DoubleLeftRightArrow: DoubleLeftRightArrow,
	DoubleLeftTee: DoubleLeftTee,
	DoubleLongLeftArrow: DoubleLongLeftArrow,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
	DoubleLongRightArrow: DoubleLongRightArrow,
	DoubleRightArrow: DoubleRightArrow,
	DoubleRightTee: DoubleRightTee,
	DoubleUpArrow: DoubleUpArrow,
	DoubleUpDownArrow: DoubleUpDownArrow,
	DoubleVerticalBar: DoubleVerticalBar,
	DownArrowBar: DownArrowBar,
	downarrow: downarrow,
	DownArrow: DownArrow,
	Downarrow: Downarrow,
	DownArrowUpArrow: DownArrowUpArrow,
	DownBreve: DownBreve,
	downdownarrows: downdownarrows,
	downharpoonleft: downharpoonleft,
	downharpoonright: downharpoonright,
	DownLeftRightVector: DownLeftRightVector,
	DownLeftTeeVector: DownLeftTeeVector,
	DownLeftVectorBar: DownLeftVectorBar,
	DownLeftVector: DownLeftVector,
	DownRightTeeVector: DownRightTeeVector,
	DownRightVectorBar: DownRightVectorBar,
	DownRightVector: DownRightVector,
	DownTeeArrow: DownTeeArrow,
	DownTee: DownTee,
	drbkarow: drbkarow,
	drcorn: drcorn,
	drcrop: drcrop,
	Dscr: Dscr,
	dscr: dscr,
	DScy: DScy,
	dscy: dscy,
	dsol: dsol,
	Dstrok: Dstrok,
	dstrok: dstrok,
	dtdot: dtdot,
	dtri: dtri,
	dtrif: dtrif,
	duarr: duarr,
	duhar: duhar,
	dwangle: dwangle,
	DZcy: DZcy,
	dzcy: dzcy,
	dzigrarr: dzigrarr,
	Eacute: Eacute,
	eacute: eacute,
	easter: easter,
	Ecaron: Ecaron,
	ecaron: ecaron,
	Ecirc: Ecirc,
	ecirc: ecirc,
	ecir: ecir,
	ecolon: ecolon,
	Ecy: Ecy,
	ecy: ecy,
	eDDot: eDDot,
	Edot: Edot,
	edot: edot,
	eDot: eDot,
	ee: ee,
	efDot: efDot,
	Efr: Efr,
	efr: efr,
	eg: eg,
	Egrave: Egrave,
	egrave: egrave,
	egs: egs,
	egsdot: egsdot,
	el: el,
	Element: Element,
	elinters: elinters,
	ell: ell,
	els: els,
	elsdot: elsdot,
	Emacr: Emacr,
	emacr: emacr,
	empty: empty,
	emptyset: emptyset,
	EmptySmallSquare: EmptySmallSquare,
	emptyv: emptyv,
	EmptyVerySmallSquare: EmptyVerySmallSquare,
	emsp13: emsp13,
	emsp14: emsp14,
	emsp: emsp,
	ENG: ENG,
	eng: eng,
	ensp: ensp,
	Eogon: Eogon,
	eogon: eogon,
	Eopf: Eopf,
	eopf: eopf,
	epar: epar,
	eparsl: eparsl,
	eplus: eplus,
	epsi: epsi,
	Epsilon: Epsilon,
	epsilon: epsilon,
	epsiv: epsiv,
	eqcirc: eqcirc,
	eqcolon: eqcolon,
	eqsim: eqsim,
	eqslantgtr: eqslantgtr,
	eqslantless: eqslantless,
	Equal: Equal,
	equals: equals,
	EqualTilde: EqualTilde,
	equest: equest,
	Equilibrium: Equilibrium,
	equiv: equiv,
	equivDD: equivDD,
	eqvparsl: eqvparsl,
	erarr: erarr,
	erDot: erDot,
	escr: escr,
	Escr: Escr,
	esdot: esdot,
	Esim: Esim,
	esim: esim,
	Eta: Eta,
	eta: eta,
	ETH: ETH,
	eth: eth,
	Euml: Euml,
	euml: euml,
	euro: euro,
	excl: excl,
	exist: exist,
	Exists: Exists,
	expectation: expectation,
	exponentiale: exponentiale,
	ExponentialE: ExponentialE,
	fallingdotseq: fallingdotseq,
	Fcy: Fcy,
	fcy: fcy,
	female: female,
	ffilig: ffilig,
	fflig: fflig,
	ffllig: ffllig,
	Ffr: Ffr,
	ffr: ffr,
	filig: filig,
	FilledSmallSquare: FilledSmallSquare,
	FilledVerySmallSquare: FilledVerySmallSquare,
	fjlig: fjlig,
	flat: flat,
	fllig: fllig,
	fltns: fltns,
	fnof: fnof,
	Fopf: Fopf,
	fopf: fopf,
	forall: forall,
	ForAll: ForAll,
	fork: fork,
	forkv: forkv,
	Fouriertrf: Fouriertrf,
	fpartint: fpartint,
	frac12: frac12,
	frac13: frac13,
	frac14: frac14,
	frac15: frac15,
	frac16: frac16,
	frac18: frac18,
	frac23: frac23,
	frac25: frac25,
	frac34: frac34,
	frac35: frac35,
	frac38: frac38,
	frac45: frac45,
	frac56: frac56,
	frac58: frac58,
	frac78: frac78,
	frasl: frasl,
	frown: frown,
	fscr: fscr,
	Fscr: Fscr,
	gacute: gacute,
	Gamma: Gamma,
	gamma: gamma,
	Gammad: Gammad,
	gammad: gammad,
	gap: gap,
	Gbreve: Gbreve,
	gbreve: gbreve,
	Gcedil: Gcedil,
	Gcirc: Gcirc,
	gcirc: gcirc,
	Gcy: Gcy,
	gcy: gcy,
	Gdot: Gdot,
	gdot: gdot,
	ge: ge,
	gE: gE,
	gEl: gEl,
	gel: gel,
	geq: geq,
	geqq: geqq,
	geqslant: geqslant,
	gescc: gescc,
	ges: ges,
	gesdot: gesdot,
	gesdoto: gesdoto,
	gesdotol: gesdotol,
	gesl: gesl,
	gesles: gesles,
	Gfr: Gfr,
	gfr: gfr,
	gg: gg,
	Gg: Gg,
	ggg: ggg,
	gimel: gimel,
	GJcy: GJcy,
	gjcy: gjcy,
	gla: gla,
	gl: gl,
	glE: glE,
	glj: glj,
	gnap: gnap,
	gnapprox: gnapprox,
	gne: gne,
	gnE: gnE,
	gneq: gneq,
	gneqq: gneqq,
	gnsim: gnsim,
	Gopf: Gopf,
	gopf: gopf,
	grave: grave,
	GreaterEqual: GreaterEqual,
	GreaterEqualLess: GreaterEqualLess,
	GreaterFullEqual: GreaterFullEqual,
	GreaterGreater: GreaterGreater,
	GreaterLess: GreaterLess,
	GreaterSlantEqual: GreaterSlantEqual,
	GreaterTilde: GreaterTilde,
	Gscr: Gscr,
	gscr: gscr,
	gsim: gsim,
	gsime: gsime,
	gsiml: gsiml,
	gtcc: gtcc,
	gtcir: gtcir,
	gt: gt$1,
	GT: GT,
	Gt: Gt,
	gtdot: gtdot,
	gtlPar: gtlPar,
	gtquest: gtquest,
	gtrapprox: gtrapprox,
	gtrarr: gtrarr,
	gtrdot: gtrdot,
	gtreqless: gtreqless,
	gtreqqless: gtreqqless,
	gtrless: gtrless,
	gtrsim: gtrsim,
	gvertneqq: gvertneqq,
	gvnE: gvnE,
	Hacek: Hacek,
	hairsp: hairsp,
	half: half,
	hamilt: hamilt,
	HARDcy: HARDcy,
	hardcy: hardcy,
	harrcir: harrcir,
	harr: harr,
	hArr: hArr,
	harrw: harrw,
	Hat: Hat,
	hbar: hbar,
	Hcirc: Hcirc,
	hcirc: hcirc,
	hearts: hearts,
	heartsuit: heartsuit,
	hellip: hellip,
	hercon: hercon,
	hfr: hfr,
	Hfr: Hfr,
	HilbertSpace: HilbertSpace,
	hksearow: hksearow,
	hkswarow: hkswarow,
	hoarr: hoarr,
	homtht: homtht,
	hookleftarrow: hookleftarrow,
	hookrightarrow: hookrightarrow,
	hopf: hopf,
	Hopf: Hopf,
	horbar: horbar,
	HorizontalLine: HorizontalLine,
	hscr: hscr,
	Hscr: Hscr,
	hslash: hslash,
	Hstrok: Hstrok,
	hstrok: hstrok,
	HumpDownHump: HumpDownHump,
	HumpEqual: HumpEqual,
	hybull: hybull,
	hyphen: hyphen,
	Iacute: Iacute,
	iacute: iacute,
	ic: ic,
	Icirc: Icirc,
	icirc: icirc,
	Icy: Icy,
	icy: icy,
	Idot: Idot,
	IEcy: IEcy,
	iecy: iecy,
	iexcl: iexcl,
	iff: iff,
	ifr: ifr,
	Ifr: Ifr,
	Igrave: Igrave,
	igrave: igrave,
	ii: ii,
	iiiint: iiiint,
	iiint: iiint,
	iinfin: iinfin,
	iiota: iiota,
	IJlig: IJlig,
	ijlig: ijlig,
	Imacr: Imacr,
	imacr: imacr,
	image: image,
	ImaginaryI: ImaginaryI,
	imagline: imagline,
	imagpart: imagpart,
	imath: imath,
	Im: Im,
	imof: imof,
	imped: imped,
	Implies: Implies,
	incare: incare,
	infin: infin,
	infintie: infintie,
	inodot: inodot,
	intcal: intcal,
	int: int,
	Int: Int,
	integers: integers,
	Integral: Integral,
	intercal: intercal,
	Intersection: Intersection,
	intlarhk: intlarhk,
	intprod: intprod,
	InvisibleComma: InvisibleComma,
	InvisibleTimes: InvisibleTimes,
	IOcy: IOcy,
	iocy: iocy,
	Iogon: Iogon,
	iogon: iogon,
	Iopf: Iopf,
	iopf: iopf,
	Iota: Iota,
	iota: iota,
	iprod: iprod,
	iquest: iquest,
	iscr: iscr,
	Iscr: Iscr,
	isin: isin,
	isindot: isindot,
	isinE: isinE,
	isins: isins,
	isinsv: isinsv,
	isinv: isinv,
	it: it,
	Itilde: Itilde,
	itilde: itilde,
	Iukcy: Iukcy,
	iukcy: iukcy,
	Iuml: Iuml,
	iuml: iuml,
	Jcirc: Jcirc,
	jcirc: jcirc,
	Jcy: Jcy,
	jcy: jcy,
	Jfr: Jfr,
	jfr: jfr,
	jmath: jmath,
	Jopf: Jopf,
	jopf: jopf,
	Jscr: Jscr,
	jscr: jscr,
	Jsercy: Jsercy,
	jsercy: jsercy,
	Jukcy: Jukcy,
	jukcy: jukcy,
	Kappa: Kappa,
	kappa: kappa,
	kappav: kappav,
	Kcedil: Kcedil,
	kcedil: kcedil,
	Kcy: Kcy,
	kcy: kcy,
	Kfr: Kfr,
	kfr: kfr,
	kgreen: kgreen,
	KHcy: KHcy,
	khcy: khcy,
	KJcy: KJcy,
	kjcy: kjcy,
	Kopf: Kopf,
	kopf: kopf,
	Kscr: Kscr,
	kscr: kscr,
	lAarr: lAarr,
	Lacute: Lacute,
	lacute: lacute,
	laemptyv: laemptyv,
	lagran: lagran,
	Lambda: Lambda,
	lambda: lambda,
	lang: lang,
	Lang: Lang,
	langd: langd,
	langle: langle,
	lap: lap,
	Laplacetrf: Laplacetrf,
	laquo: laquo,
	larrb: larrb,
	larrbfs: larrbfs,
	larr: larr,
	Larr: Larr,
	lArr: lArr,
	larrfs: larrfs,
	larrhk: larrhk,
	larrlp: larrlp,
	larrpl: larrpl,
	larrsim: larrsim,
	larrtl: larrtl,
	latail: latail,
	lAtail: lAtail,
	lat: lat,
	late: late,
	lates: lates,
	lbarr: lbarr,
	lBarr: lBarr,
	lbbrk: lbbrk,
	lbrace: lbrace,
	lbrack: lbrack,
	lbrke: lbrke,
	lbrksld: lbrksld,
	lbrkslu: lbrkslu,
	Lcaron: Lcaron,
	lcaron: lcaron,
	Lcedil: Lcedil,
	lcedil: lcedil,
	lceil: lceil,
	lcub: lcub,
	Lcy: Lcy,
	lcy: lcy,
	ldca: ldca,
	ldquo: ldquo,
	ldquor: ldquor,
	ldrdhar: ldrdhar,
	ldrushar: ldrushar,
	ldsh: ldsh,
	le: le,
	lE: lE,
	LeftAngleBracket: LeftAngleBracket,
	LeftArrowBar: LeftArrowBar,
	leftarrow: leftarrow,
	LeftArrow: LeftArrow,
	Leftarrow: Leftarrow,
	LeftArrowRightArrow: LeftArrowRightArrow,
	leftarrowtail: leftarrowtail,
	LeftCeiling: LeftCeiling,
	LeftDoubleBracket: LeftDoubleBracket,
	LeftDownTeeVector: LeftDownTeeVector,
	LeftDownVectorBar: LeftDownVectorBar,
	LeftDownVector: LeftDownVector,
	LeftFloor: LeftFloor,
	leftharpoondown: leftharpoondown,
	leftharpoonup: leftharpoonup,
	leftleftarrows: leftleftarrows,
	leftrightarrow: leftrightarrow,
	LeftRightArrow: LeftRightArrow,
	Leftrightarrow: Leftrightarrow,
	leftrightarrows: leftrightarrows,
	leftrightharpoons: leftrightharpoons,
	leftrightsquigarrow: leftrightsquigarrow,
	LeftRightVector: LeftRightVector,
	LeftTeeArrow: LeftTeeArrow,
	LeftTee: LeftTee,
	LeftTeeVector: LeftTeeVector,
	leftthreetimes: leftthreetimes,
	LeftTriangleBar: LeftTriangleBar,
	LeftTriangle: LeftTriangle,
	LeftTriangleEqual: LeftTriangleEqual,
	LeftUpDownVector: LeftUpDownVector,
	LeftUpTeeVector: LeftUpTeeVector,
	LeftUpVectorBar: LeftUpVectorBar,
	LeftUpVector: LeftUpVector,
	LeftVectorBar: LeftVectorBar,
	LeftVector: LeftVector,
	lEg: lEg,
	leg: leg,
	leq: leq,
	leqq: leqq,
	leqslant: leqslant,
	lescc: lescc,
	les: les,
	lesdot: lesdot,
	lesdoto: lesdoto,
	lesdotor: lesdotor,
	lesg: lesg,
	lesges: lesges,
	lessapprox: lessapprox,
	lessdot: lessdot,
	lesseqgtr: lesseqgtr,
	lesseqqgtr: lesseqqgtr,
	LessEqualGreater: LessEqualGreater,
	LessFullEqual: LessFullEqual,
	LessGreater: LessGreater,
	lessgtr: lessgtr,
	LessLess: LessLess,
	lesssim: lesssim,
	LessSlantEqual: LessSlantEqual,
	LessTilde: LessTilde,
	lfisht: lfisht,
	lfloor: lfloor,
	Lfr: Lfr,
	lfr: lfr,
	lg: lg,
	lgE: lgE,
	lHar: lHar,
	lhard: lhard,
	lharu: lharu,
	lharul: lharul,
	lhblk: lhblk,
	LJcy: LJcy,
	ljcy: ljcy,
	llarr: llarr,
	ll: ll,
	Ll: Ll,
	llcorner: llcorner,
	Lleftarrow: Lleftarrow,
	llhard: llhard,
	lltri: lltri,
	Lmidot: Lmidot,
	lmidot: lmidot,
	lmoustache: lmoustache,
	lmoust: lmoust,
	lnap: lnap,
	lnapprox: lnapprox,
	lne: lne,
	lnE: lnE,
	lneq: lneq,
	lneqq: lneqq,
	lnsim: lnsim,
	loang: loang,
	loarr: loarr,
	lobrk: lobrk,
	longleftarrow: longleftarrow,
	LongLeftArrow: LongLeftArrow,
	Longleftarrow: Longleftarrow,
	longleftrightarrow: longleftrightarrow,
	LongLeftRightArrow: LongLeftRightArrow,
	Longleftrightarrow: Longleftrightarrow,
	longmapsto: longmapsto,
	longrightarrow: longrightarrow,
	LongRightArrow: LongRightArrow,
	Longrightarrow: Longrightarrow,
	looparrowleft: looparrowleft,
	looparrowright: looparrowright,
	lopar: lopar,
	Lopf: Lopf,
	lopf: lopf,
	loplus: loplus,
	lotimes: lotimes,
	lowast: lowast,
	lowbar: lowbar,
	LowerLeftArrow: LowerLeftArrow,
	LowerRightArrow: LowerRightArrow,
	loz: loz,
	lozenge: lozenge,
	lozf: lozf,
	lpar: lpar,
	lparlt: lparlt,
	lrarr: lrarr,
	lrcorner: lrcorner,
	lrhar: lrhar,
	lrhard: lrhard,
	lrm: lrm,
	lrtri: lrtri,
	lsaquo: lsaquo,
	lscr: lscr,
	Lscr: Lscr,
	lsh: lsh,
	Lsh: Lsh,
	lsim: lsim,
	lsime: lsime,
	lsimg: lsimg,
	lsqb: lsqb,
	lsquo: lsquo,
	lsquor: lsquor,
	Lstrok: Lstrok,
	lstrok: lstrok,
	ltcc: ltcc,
	ltcir: ltcir,
	lt: lt$1,
	LT: LT,
	Lt: Lt,
	ltdot: ltdot,
	lthree: lthree,
	ltimes: ltimes,
	ltlarr: ltlarr,
	ltquest: ltquest,
	ltri: ltri,
	ltrie: ltrie,
	ltrif: ltrif,
	ltrPar: ltrPar,
	lurdshar: lurdshar,
	luruhar: luruhar,
	lvertneqq: lvertneqq,
	lvnE: lvnE,
	macr: macr,
	male: male,
	malt: malt,
	maltese: maltese,
	map: map$1,
	mapsto: mapsto,
	mapstodown: mapstodown,
	mapstoleft: mapstoleft,
	mapstoup: mapstoup,
	marker: marker,
	mcomma: mcomma,
	Mcy: Mcy,
	mcy: mcy,
	mdash: mdash,
	mDDot: mDDot,
	measuredangle: measuredangle,
	MediumSpace: MediumSpace,
	Mellintrf: Mellintrf,
	Mfr: Mfr,
	mfr: mfr,
	mho: mho,
	micro: micro,
	midast: midast,
	midcir: midcir,
	mid: mid,
	middot: middot,
	minusb: minusb,
	minus: minus,
	minusd: minusd,
	minusdu: minusdu,
	MinusPlus: MinusPlus,
	mlcp: mlcp,
	mldr: mldr,
	mnplus: mnplus,
	models: models,
	Mopf: Mopf,
	mopf: mopf,
	mp: mp,
	mscr: mscr,
	Mscr: Mscr,
	mstpos: mstpos,
	Mu: Mu,
	mu: mu,
	multimap: multimap,
	mumap: mumap,
	nabla: nabla,
	Nacute: Nacute,
	nacute: nacute,
	nang: nang,
	nap: nap,
	napE: napE,
	napid: napid,
	napos: napos,
	napprox: napprox,
	natural: natural,
	naturals: naturals,
	natur: natur,
	nbsp: nbsp,
	nbump: nbump,
	nbumpe: nbumpe,
	ncap: ncap,
	Ncaron: Ncaron,
	ncaron: ncaron,
	Ncedil: Ncedil,
	ncedil: ncedil,
	ncong: ncong,
	ncongdot: ncongdot,
	ncup: ncup,
	Ncy: Ncy,
	ncy: ncy,
	ndash: ndash,
	nearhk: nearhk,
	nearr: nearr,
	neArr: neArr,
	nearrow: nearrow,
	ne: ne,
	nedot: nedot,
	NegativeMediumSpace: NegativeMediumSpace,
	NegativeThickSpace: NegativeThickSpace,
	NegativeThinSpace: NegativeThinSpace,
	NegativeVeryThinSpace: NegativeVeryThinSpace,
	nequiv: nequiv,
	nesear: nesear,
	nesim: nesim,
	NestedGreaterGreater: NestedGreaterGreater,
	NestedLessLess: NestedLessLess,
	NewLine: NewLine,
	nexist: nexist,
	nexists: nexists,
	Nfr: Nfr,
	nfr: nfr,
	ngE: ngE,
	nge: nge,
	ngeq: ngeq,
	ngeqq: ngeqq,
	ngeqslant: ngeqslant,
	nges: nges,
	nGg: nGg,
	ngsim: ngsim,
	nGt: nGt,
	ngt: ngt,
	ngtr: ngtr,
	nGtv: nGtv,
	nharr: nharr,
	nhArr: nhArr,
	nhpar: nhpar,
	ni: ni,
	nis: nis,
	nisd: nisd,
	niv: niv,
	NJcy: NJcy,
	njcy: njcy,
	nlarr: nlarr,
	nlArr: nlArr,
	nldr: nldr,
	nlE: nlE,
	nle: nle,
	nleftarrow: nleftarrow,
	nLeftarrow: nLeftarrow,
	nleftrightarrow: nleftrightarrow,
	nLeftrightarrow: nLeftrightarrow,
	nleq: nleq,
	nleqq: nleqq,
	nleqslant: nleqslant,
	nles: nles,
	nless: nless,
	nLl: nLl,
	nlsim: nlsim,
	nLt: nLt,
	nlt: nlt,
	nltri: nltri,
	nltrie: nltrie,
	nLtv: nLtv,
	nmid: nmid,
	NoBreak: NoBreak,
	NonBreakingSpace: NonBreakingSpace,
	nopf: nopf,
	Nopf: Nopf,
	Not: Not,
	not: not,
	NotCongruent: NotCongruent,
	NotCupCap: NotCupCap,
	NotDoubleVerticalBar: NotDoubleVerticalBar,
	NotElement: NotElement,
	NotEqual: NotEqual,
	NotEqualTilde: NotEqualTilde,
	NotExists: NotExists,
	NotGreater: NotGreater,
	NotGreaterEqual: NotGreaterEqual,
	NotGreaterFullEqual: NotGreaterFullEqual,
	NotGreaterGreater: NotGreaterGreater,
	NotGreaterLess: NotGreaterLess,
	NotGreaterSlantEqual: NotGreaterSlantEqual,
	NotGreaterTilde: NotGreaterTilde,
	NotHumpDownHump: NotHumpDownHump,
	NotHumpEqual: NotHumpEqual,
	notin: notin,
	notindot: notindot,
	notinE: notinE,
	notinva: notinva,
	notinvb: notinvb,
	notinvc: notinvc,
	NotLeftTriangleBar: NotLeftTriangleBar,
	NotLeftTriangle: NotLeftTriangle,
	NotLeftTriangleEqual: NotLeftTriangleEqual,
	NotLess: NotLess,
	NotLessEqual: NotLessEqual,
	NotLessGreater: NotLessGreater,
	NotLessLess: NotLessLess,
	NotLessSlantEqual: NotLessSlantEqual,
	NotLessTilde: NotLessTilde,
	NotNestedGreaterGreater: NotNestedGreaterGreater,
	NotNestedLessLess: NotNestedLessLess,
	notni: notni,
	notniva: notniva,
	notnivb: notnivb,
	notnivc: notnivc,
	NotPrecedes: NotPrecedes,
	NotPrecedesEqual: NotPrecedesEqual,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
	NotReverseElement: NotReverseElement,
	NotRightTriangleBar: NotRightTriangleBar,
	NotRightTriangle: NotRightTriangle,
	NotRightTriangleEqual: NotRightTriangleEqual,
	NotSquareSubset: NotSquareSubset,
	NotSquareSubsetEqual: NotSquareSubsetEqual,
	NotSquareSuperset: NotSquareSuperset,
	NotSquareSupersetEqual: NotSquareSupersetEqual,
	NotSubset: NotSubset,
	NotSubsetEqual: NotSubsetEqual,
	NotSucceeds: NotSucceeds,
	NotSucceedsEqual: NotSucceedsEqual,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
	NotSucceedsTilde: NotSucceedsTilde,
	NotSuperset: NotSuperset,
	NotSupersetEqual: NotSupersetEqual,
	NotTilde: NotTilde,
	NotTildeEqual: NotTildeEqual,
	NotTildeFullEqual: NotTildeFullEqual,
	NotTildeTilde: NotTildeTilde,
	NotVerticalBar: NotVerticalBar,
	nparallel: nparallel,
	npar: npar,
	nparsl: nparsl,
	npart: npart,
	npolint: npolint,
	npr: npr,
	nprcue: nprcue,
	nprec: nprec,
	npreceq: npreceq,
	npre: npre,
	nrarrc: nrarrc,
	nrarr: nrarr,
	nrArr: nrArr,
	nrarrw: nrarrw,
	nrightarrow: nrightarrow,
	nRightarrow: nRightarrow,
	nrtri: nrtri,
	nrtrie: nrtrie,
	nsc: nsc,
	nsccue: nsccue,
	nsce: nsce,
	Nscr: Nscr,
	nscr: nscr,
	nshortmid: nshortmid,
	nshortparallel: nshortparallel,
	nsim: nsim,
	nsime: nsime,
	nsimeq: nsimeq,
	nsmid: nsmid,
	nspar: nspar,
	nsqsube: nsqsube,
	nsqsupe: nsqsupe,
	nsub: nsub,
	nsubE: nsubE,
	nsube: nsube,
	nsubset: nsubset,
	nsubseteq: nsubseteq,
	nsubseteqq: nsubseteqq,
	nsucc: nsucc,
	nsucceq: nsucceq,
	nsup: nsup,
	nsupE: nsupE,
	nsupe: nsupe,
	nsupset: nsupset,
	nsupseteq: nsupseteq,
	nsupseteqq: nsupseteqq,
	ntgl: ntgl,
	Ntilde: Ntilde,
	ntilde: ntilde,
	ntlg: ntlg,
	ntriangleleft: ntriangleleft,
	ntrianglelefteq: ntrianglelefteq,
	ntriangleright: ntriangleright,
	ntrianglerighteq: ntrianglerighteq,
	Nu: Nu,
	nu: nu,
	num: num,
	numero: numero,
	numsp: numsp,
	nvap: nvap,
	nvdash: nvdash,
	nvDash: nvDash,
	nVdash: nVdash,
	nVDash: nVDash,
	nvge: nvge,
	nvgt: nvgt,
	nvHarr: nvHarr,
	nvinfin: nvinfin,
	nvlArr: nvlArr,
	nvle: nvle,
	nvlt: nvlt,
	nvltrie: nvltrie,
	nvrArr: nvrArr,
	nvrtrie: nvrtrie,
	nvsim: nvsim,
	nwarhk: nwarhk,
	nwarr: nwarr,
	nwArr: nwArr,
	nwarrow: nwarrow,
	nwnear: nwnear,
	Oacute: Oacute,
	oacute: oacute,
	oast: oast,
	Ocirc: Ocirc,
	ocirc: ocirc,
	ocir: ocir,
	Ocy: Ocy,
	ocy: ocy,
	odash: odash,
	Odblac: Odblac,
	odblac: odblac,
	odiv: odiv,
	odot: odot,
	odsold: odsold,
	OElig: OElig,
	oelig: oelig,
	ofcir: ofcir,
	Ofr: Ofr,
	ofr: ofr,
	ogon: ogon,
	Ograve: Ograve,
	ograve: ograve,
	ogt: ogt,
	ohbar: ohbar,
	ohm: ohm,
	oint: oint,
	olarr: olarr,
	olcir: olcir,
	olcross: olcross,
	oline: oline,
	olt: olt,
	Omacr: Omacr,
	omacr: omacr,
	Omega: Omega,
	omega: omega,
	Omicron: Omicron,
	omicron: omicron,
	omid: omid,
	ominus: ominus,
	Oopf: Oopf,
	oopf: oopf,
	opar: opar,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
	OpenCurlyQuote: OpenCurlyQuote,
	operp: operp,
	oplus: oplus,
	orarr: orarr,
	Or: Or,
	or: or,
	ord: ord,
	order: order,
	orderof: orderof,
	ordf: ordf,
	ordm: ordm,
	origof: origof,
	oror: oror,
	orslope: orslope,
	orv: orv,
	oS: oS,
	Oscr: Oscr,
	oscr: oscr,
	Oslash: Oslash,
	oslash: oslash,
	osol: osol,
	Otilde: Otilde,
	otilde: otilde,
	otimesas: otimesas,
	Otimes: Otimes,
	otimes: otimes,
	Ouml: Ouml,
	ouml: ouml,
	ovbar: ovbar,
	OverBar: OverBar,
	OverBrace: OverBrace,
	OverBracket: OverBracket,
	OverParenthesis: OverParenthesis,
	para: para,
	parallel: parallel,
	par: par,
	parsim: parsim,
	parsl: parsl,
	part: part,
	PartialD: PartialD,
	Pcy: Pcy,
	pcy: pcy,
	percnt: percnt,
	period: period,
	permil: permil,
	perp: perp,
	pertenk: pertenk,
	Pfr: Pfr,
	pfr: pfr,
	Phi: Phi,
	phi: phi,
	phiv: phiv,
	phmmat: phmmat,
	phone: phone,
	Pi: Pi,
	pi: pi,
	pitchfork: pitchfork,
	piv: piv,
	planck: planck,
	planckh: planckh,
	plankv: plankv,
	plusacir: plusacir,
	plusb: plusb,
	pluscir: pluscir,
	plus: plus,
	plusdo: plusdo,
	plusdu: plusdu,
	pluse: pluse,
	PlusMinus: PlusMinus,
	plusmn: plusmn,
	plussim: plussim,
	plustwo: plustwo,
	pm: pm,
	Poincareplane: Poincareplane,
	pointint: pointint,
	popf: popf,
	Popf: Popf,
	pound: pound,
	prap: prap,
	Pr: Pr,
	pr: pr,
	prcue: prcue,
	precapprox: precapprox,
	prec: prec,
	preccurlyeq: preccurlyeq,
	Precedes: Precedes,
	PrecedesEqual: PrecedesEqual,
	PrecedesSlantEqual: PrecedesSlantEqual,
	PrecedesTilde: PrecedesTilde,
	preceq: preceq,
	precnapprox: precnapprox,
	precneqq: precneqq,
	precnsim: precnsim,
	pre: pre,
	prE: prE,
	precsim: precsim,
	prime: prime,
	Prime: Prime,
	primes: primes,
	prnap: prnap,
	prnE: prnE,
	prnsim: prnsim,
	prod: prod,
	Product: Product,
	profalar: profalar,
	profline: profline,
	profsurf: profsurf,
	prop: prop,
	Proportional: Proportional,
	Proportion: Proportion,
	propto: propto,
	prsim: prsim,
	prurel: prurel,
	Pscr: Pscr,
	pscr: pscr,
	Psi: Psi,
	psi: psi,
	puncsp: puncsp,
	Qfr: Qfr,
	qfr: qfr,
	qint: qint,
	qopf: qopf,
	Qopf: Qopf,
	qprime: qprime,
	Qscr: Qscr,
	qscr: qscr,
	quaternions: quaternions,
	quatint: quatint,
	quest: quest,
	questeq: questeq,
	quot: quot$1,
	QUOT: QUOT,
	rAarr: rAarr,
	race: race,
	Racute: Racute,
	racute: racute,
	radic: radic,
	raemptyv: raemptyv,
	rang: rang,
	Rang: Rang,
	rangd: rangd,
	range: range,
	rangle: rangle,
	raquo: raquo,
	rarrap: rarrap,
	rarrb: rarrb,
	rarrbfs: rarrbfs,
	rarrc: rarrc,
	rarr: rarr,
	Rarr: Rarr,
	rArr: rArr,
	rarrfs: rarrfs,
	rarrhk: rarrhk,
	rarrlp: rarrlp,
	rarrpl: rarrpl,
	rarrsim: rarrsim,
	Rarrtl: Rarrtl,
	rarrtl: rarrtl,
	rarrw: rarrw,
	ratail: ratail,
	rAtail: rAtail,
	ratio: ratio,
	rationals: rationals,
	rbarr: rbarr,
	rBarr: rBarr,
	RBarr: RBarr,
	rbbrk: rbbrk,
	rbrace: rbrace,
	rbrack: rbrack,
	rbrke: rbrke,
	rbrksld: rbrksld,
	rbrkslu: rbrkslu,
	Rcaron: Rcaron,
	rcaron: rcaron,
	Rcedil: Rcedil,
	rcedil: rcedil,
	rceil: rceil,
	rcub: rcub,
	Rcy: Rcy,
	rcy: rcy,
	rdca: rdca,
	rdldhar: rdldhar,
	rdquo: rdquo,
	rdquor: rdquor,
	rdsh: rdsh,
	real: real,
	realine: realine,
	realpart: realpart,
	reals: reals,
	Re: Re,
	rect: rect,
	reg: reg,
	REG: REG,
	ReverseElement: ReverseElement,
	ReverseEquilibrium: ReverseEquilibrium,
	ReverseUpEquilibrium: ReverseUpEquilibrium,
	rfisht: rfisht,
	rfloor: rfloor,
	rfr: rfr,
	Rfr: Rfr,
	rHar: rHar,
	rhard: rhard,
	rharu: rharu,
	rharul: rharul,
	Rho: Rho,
	rho: rho,
	rhov: rhov,
	RightAngleBracket: RightAngleBracket,
	RightArrowBar: RightArrowBar,
	rightarrow: rightarrow,
	RightArrow: RightArrow,
	Rightarrow: Rightarrow,
	RightArrowLeftArrow: RightArrowLeftArrow,
	rightarrowtail: rightarrowtail,
	RightCeiling: RightCeiling,
	RightDoubleBracket: RightDoubleBracket,
	RightDownTeeVector: RightDownTeeVector,
	RightDownVectorBar: RightDownVectorBar,
	RightDownVector: RightDownVector,
	RightFloor: RightFloor,
	rightharpoondown: rightharpoondown,
	rightharpoonup: rightharpoonup,
	rightleftarrows: rightleftarrows,
	rightleftharpoons: rightleftharpoons,
	rightrightarrows: rightrightarrows,
	rightsquigarrow: rightsquigarrow,
	RightTeeArrow: RightTeeArrow,
	RightTee: RightTee,
	RightTeeVector: RightTeeVector,
	rightthreetimes: rightthreetimes,
	RightTriangleBar: RightTriangleBar,
	RightTriangle: RightTriangle,
	RightTriangleEqual: RightTriangleEqual,
	RightUpDownVector: RightUpDownVector,
	RightUpTeeVector: RightUpTeeVector,
	RightUpVectorBar: RightUpVectorBar,
	RightUpVector: RightUpVector,
	RightVectorBar: RightVectorBar,
	RightVector: RightVector,
	ring: ring,
	risingdotseq: risingdotseq,
	rlarr: rlarr,
	rlhar: rlhar,
	rlm: rlm,
	rmoustache: rmoustache,
	rmoust: rmoust,
	rnmid: rnmid,
	roang: roang,
	roarr: roarr,
	robrk: robrk,
	ropar: ropar,
	ropf: ropf,
	Ropf: Ropf,
	roplus: roplus,
	rotimes: rotimes,
	RoundImplies: RoundImplies,
	rpar: rpar,
	rpargt: rpargt,
	rppolint: rppolint,
	rrarr: rrarr,
	Rrightarrow: Rrightarrow,
	rsaquo: rsaquo,
	rscr: rscr,
	Rscr: Rscr,
	rsh: rsh,
	Rsh: Rsh,
	rsqb: rsqb,
	rsquo: rsquo,
	rsquor: rsquor,
	rthree: rthree,
	rtimes: rtimes,
	rtri: rtri,
	rtrie: rtrie,
	rtrif: rtrif,
	rtriltri: rtriltri,
	RuleDelayed: RuleDelayed,
	ruluhar: ruluhar,
	rx: rx,
	Sacute: Sacute,
	sacute: sacute,
	sbquo: sbquo,
	scap: scap,
	Scaron: Scaron,
	scaron: scaron,
	Sc: Sc,
	sc: sc,
	sccue: sccue,
	sce: sce,
	scE: scE,
	Scedil: Scedil,
	scedil: scedil,
	Scirc: Scirc,
	scirc: scirc,
	scnap: scnap,
	scnE: scnE,
	scnsim: scnsim,
	scpolint: scpolint,
	scsim: scsim,
	Scy: Scy,
	scy: scy,
	sdotb: sdotb,
	sdot: sdot,
	sdote: sdote,
	searhk: searhk,
	searr: searr,
	seArr: seArr,
	searrow: searrow,
	sect: sect,
	semi: semi,
	seswar: seswar,
	setminus: setminus,
	setmn: setmn,
	sext: sext,
	Sfr: Sfr,
	sfr: sfr,
	sfrown: sfrown,
	sharp: sharp,
	SHCHcy: SHCHcy,
	shchcy: shchcy,
	SHcy: SHcy,
	shcy: shcy,
	ShortDownArrow: ShortDownArrow,
	ShortLeftArrow: ShortLeftArrow,
	shortmid: shortmid,
	shortparallel: shortparallel,
	ShortRightArrow: ShortRightArrow,
	ShortUpArrow: ShortUpArrow,
	shy: shy,
	Sigma: Sigma,
	sigma: sigma,
	sigmaf: sigmaf,
	sigmav: sigmav,
	sim: sim,
	simdot: simdot,
	sime: sime,
	simeq: simeq,
	simg: simg,
	simgE: simgE,
	siml: siml,
	simlE: simlE,
	simne: simne,
	simplus: simplus,
	simrarr: simrarr,
	slarr: slarr,
	SmallCircle: SmallCircle,
	smallsetminus: smallsetminus,
	smashp: smashp,
	smeparsl: smeparsl,
	smid: smid,
	smile: smile,
	smt: smt,
	smte: smte,
	smtes: smtes,
	SOFTcy: SOFTcy,
	softcy: softcy,
	solbar: solbar,
	solb: solb,
	sol: sol,
	Sopf: Sopf,
	sopf: sopf,
	spades: spades,
	spadesuit: spadesuit,
	spar: spar,
	sqcap: sqcap,
	sqcaps: sqcaps,
	sqcup: sqcup,
	sqcups: sqcups,
	Sqrt: Sqrt,
	sqsub: sqsub,
	sqsube: sqsube,
	sqsubset: sqsubset,
	sqsubseteq: sqsubseteq,
	sqsup: sqsup,
	sqsupe: sqsupe,
	sqsupset: sqsupset,
	sqsupseteq: sqsupseteq,
	square: square,
	Square: Square,
	SquareIntersection: SquareIntersection,
	SquareSubset: SquareSubset,
	SquareSubsetEqual: SquareSubsetEqual,
	SquareSuperset: SquareSuperset,
	SquareSupersetEqual: SquareSupersetEqual,
	SquareUnion: SquareUnion,
	squarf: squarf,
	squ: squ,
	squf: squf,
	srarr: srarr,
	Sscr: Sscr,
	sscr: sscr,
	ssetmn: ssetmn,
	ssmile: ssmile,
	sstarf: sstarf,
	Star: Star,
	star: star,
	starf: starf,
	straightepsilon: straightepsilon,
	straightphi: straightphi,
	strns: strns,
	sub: sub,
	Sub: Sub,
	subdot: subdot,
	subE: subE,
	sube: sube,
	subedot: subedot,
	submult: submult,
	subnE: subnE,
	subne: subne,
	subplus: subplus,
	subrarr: subrarr,
	subset: subset,
	Subset: Subset,
	subseteq: subseteq,
	subseteqq: subseteqq,
	SubsetEqual: SubsetEqual,
	subsetneq: subsetneq,
	subsetneqq: subsetneqq,
	subsim: subsim,
	subsub: subsub,
	subsup: subsup,
	succapprox: succapprox,
	succ: succ,
	succcurlyeq: succcurlyeq,
	Succeeds: Succeeds,
	SucceedsEqual: SucceedsEqual,
	SucceedsSlantEqual: SucceedsSlantEqual,
	SucceedsTilde: SucceedsTilde,
	succeq: succeq,
	succnapprox: succnapprox,
	succneqq: succneqq,
	succnsim: succnsim,
	succsim: succsim,
	SuchThat: SuchThat,
	sum: sum,
	Sum: Sum,
	sung: sung,
	sup1: sup1,
	sup2: sup2,
	sup3: sup3,
	sup: sup,
	Sup: Sup,
	supdot: supdot,
	supdsub: supdsub,
	supE: supE,
	supe: supe,
	supedot: supedot,
	Superset: Superset,
	SupersetEqual: SupersetEqual,
	suphsol: suphsol,
	suphsub: suphsub,
	suplarr: suplarr,
	supmult: supmult,
	supnE: supnE,
	supne: supne,
	supplus: supplus,
	supset: supset,
	Supset: Supset,
	supseteq: supseteq,
	supseteqq: supseteqq,
	supsetneq: supsetneq,
	supsetneqq: supsetneqq,
	supsim: supsim,
	supsub: supsub,
	supsup: supsup,
	swarhk: swarhk,
	swarr: swarr,
	swArr: swArr,
	swarrow: swarrow,
	swnwar: swnwar,
	szlig: szlig,
	Tab: Tab,
	target: target,
	Tau: Tau,
	tau: tau,
	tbrk: tbrk,
	Tcaron: Tcaron,
	tcaron: tcaron,
	Tcedil: Tcedil,
	tcedil: tcedil,
	Tcy: Tcy,
	tcy: tcy,
	tdot: tdot,
	telrec: telrec,
	Tfr: Tfr,
	tfr: tfr,
	there4: there4,
	therefore: therefore,
	Therefore: Therefore,
	Theta: Theta,
	theta: theta,
	thetasym: thetasym,
	thetav: thetav,
	thickapprox: thickapprox,
	thicksim: thicksim,
	ThickSpace: ThickSpace,
	ThinSpace: ThinSpace,
	thinsp: thinsp,
	thkap: thkap,
	thksim: thksim,
	THORN: THORN,
	thorn: thorn,
	tilde: tilde,
	Tilde: Tilde,
	TildeEqual: TildeEqual,
	TildeFullEqual: TildeFullEqual,
	TildeTilde: TildeTilde,
	timesbar: timesbar,
	timesb: timesb,
	times: times$1,
	timesd: timesd,
	tint: tint,
	toea: toea,
	topbot: topbot,
	topcir: topcir,
	top: top,
	Topf: Topf,
	topf: topf,
	topfork: topfork,
	tosa: tosa,
	tprime: tprime,
	trade: trade,
	TRADE: TRADE,
	triangle: triangle,
	triangledown: triangledown,
	triangleleft: triangleleft,
	trianglelefteq: trianglelefteq,
	triangleq: triangleq,
	triangleright: triangleright,
	trianglerighteq: trianglerighteq,
	tridot: tridot,
	trie: trie,
	triminus: triminus,
	TripleDot: TripleDot,
	triplus: triplus,
	trisb: trisb,
	tritime: tritime,
	trpezium: trpezium,
	Tscr: Tscr,
	tscr: tscr,
	TScy: TScy,
	tscy: tscy,
	TSHcy: TSHcy,
	tshcy: tshcy,
	Tstrok: Tstrok,
	tstrok: tstrok,
	twixt: twixt,
	twoheadleftarrow: twoheadleftarrow,
	twoheadrightarrow: twoheadrightarrow,
	Uacute: Uacute,
	uacute: uacute,
	uarr: uarr,
	Uarr: Uarr,
	uArr: uArr,
	Uarrocir: Uarrocir,
	Ubrcy: Ubrcy,
	ubrcy: ubrcy,
	Ubreve: Ubreve,
	ubreve: ubreve,
	Ucirc: Ucirc,
	ucirc: ucirc,
	Ucy: Ucy,
	ucy: ucy,
	udarr: udarr,
	Udblac: Udblac,
	udblac: udblac,
	udhar: udhar,
	ufisht: ufisht,
	Ufr: Ufr,
	ufr: ufr,
	Ugrave: Ugrave,
	ugrave: ugrave,
	uHar: uHar,
	uharl: uharl,
	uharr: uharr,
	uhblk: uhblk,
	ulcorn: ulcorn,
	ulcorner: ulcorner,
	ulcrop: ulcrop,
	ultri: ultri,
	Umacr: Umacr,
	umacr: umacr,
	uml: uml,
	UnderBar: UnderBar,
	UnderBrace: UnderBrace,
	UnderBracket: UnderBracket,
	UnderParenthesis: UnderParenthesis,
	Union: Union,
	UnionPlus: UnionPlus,
	Uogon: Uogon,
	uogon: uogon,
	Uopf: Uopf,
	uopf: uopf,
	UpArrowBar: UpArrowBar,
	uparrow: uparrow,
	UpArrow: UpArrow,
	Uparrow: Uparrow,
	UpArrowDownArrow: UpArrowDownArrow,
	updownarrow: updownarrow,
	UpDownArrow: UpDownArrow,
	Updownarrow: Updownarrow,
	UpEquilibrium: UpEquilibrium,
	upharpoonleft: upharpoonleft,
	upharpoonright: upharpoonright,
	uplus: uplus,
	UpperLeftArrow: UpperLeftArrow,
	UpperRightArrow: UpperRightArrow,
	upsi: upsi,
	Upsi: Upsi,
	upsih: upsih,
	Upsilon: Upsilon,
	upsilon: upsilon,
	UpTeeArrow: UpTeeArrow,
	UpTee: UpTee,
	upuparrows: upuparrows,
	urcorn: urcorn,
	urcorner: urcorner,
	urcrop: urcrop,
	Uring: Uring,
	uring: uring,
	urtri: urtri,
	Uscr: Uscr,
	uscr: uscr,
	utdot: utdot,
	Utilde: Utilde,
	utilde: utilde,
	utri: utri,
	utrif: utrif,
	uuarr: uuarr,
	Uuml: Uuml,
	uuml: uuml,
	uwangle: uwangle,
	vangrt: vangrt,
	varepsilon: varepsilon,
	varkappa: varkappa,
	varnothing: varnothing,
	varphi: varphi,
	varpi: varpi,
	varpropto: varpropto,
	varr: varr,
	vArr: vArr,
	varrho: varrho,
	varsigma: varsigma,
	varsubsetneq: varsubsetneq,
	varsubsetneqq: varsubsetneqq,
	varsupsetneq: varsupsetneq,
	varsupsetneqq: varsupsetneqq,
	vartheta: vartheta,
	vartriangleleft: vartriangleleft,
	vartriangleright: vartriangleright,
	vBar: vBar,
	Vbar: Vbar,
	vBarv: vBarv,
	Vcy: Vcy,
	vcy: vcy,
	vdash: vdash,
	vDash: vDash,
	Vdash: Vdash,
	VDash: VDash,
	Vdashl: Vdashl,
	veebar: veebar,
	vee: vee,
	Vee: Vee,
	veeeq: veeeq,
	vellip: vellip,
	verbar: verbar,
	Verbar: Verbar,
	vert: vert,
	Vert: Vert,
	VerticalBar: VerticalBar,
	VerticalLine: VerticalLine,
	VerticalSeparator: VerticalSeparator,
	VerticalTilde: VerticalTilde,
	VeryThinSpace: VeryThinSpace,
	Vfr: Vfr,
	vfr: vfr,
	vltri: vltri,
	vnsub: vnsub,
	vnsup: vnsup,
	Vopf: Vopf,
	vopf: vopf,
	vprop: vprop,
	vrtri: vrtri,
	Vscr: Vscr,
	vscr: vscr,
	vsubnE: vsubnE,
	vsubne: vsubne,
	vsupnE: vsupnE,
	vsupne: vsupne,
	Vvdash: Vvdash,
	vzigzag: vzigzag,
	Wcirc: Wcirc,
	wcirc: wcirc,
	wedbar: wedbar,
	wedge: wedge,
	Wedge: Wedge,
	wedgeq: wedgeq,
	weierp: weierp,
	Wfr: Wfr,
	wfr: wfr,
	Wopf: Wopf,
	wopf: wopf,
	wp: wp,
	wr: wr,
	wreath: wreath,
	Wscr: Wscr,
	wscr: wscr,
	xcap: xcap,
	xcirc: xcirc,
	xcup: xcup,
	xdtri: xdtri,
	Xfr: Xfr,
	xfr: xfr,
	xharr: xharr,
	xhArr: xhArr,
	Xi: Xi,
	xi: xi,
	xlarr: xlarr,
	xlArr: xlArr,
	xmap: xmap,
	xnis: xnis,
	xodot: xodot,
	Xopf: Xopf,
	xopf: xopf,
	xoplus: xoplus,
	xotime: xotime,
	xrarr: xrarr,
	xrArr: xrArr,
	Xscr: Xscr,
	xscr: xscr,
	xsqcup: xsqcup,
	xuplus: xuplus,
	xutri: xutri,
	xvee: xvee,
	xwedge: xwedge,
	Yacute: Yacute,
	yacute: yacute,
	YAcy: YAcy,
	yacy: yacy,
	Ycirc: Ycirc,
	ycirc: ycirc,
	Ycy: Ycy,
	ycy: ycy,
	yen: yen,
	Yfr: Yfr,
	yfr: yfr,
	YIcy: YIcy,
	yicy: yicy,
	Yopf: Yopf,
	yopf: yopf,
	Yscr: Yscr,
	yscr: yscr,
	YUcy: YUcy,
	yucy: yucy,
	yuml: yuml,
	Yuml: Yuml,
	Zacute: Zacute,
	zacute: zacute,
	Zcaron: Zcaron,
	zcaron: zcaron,
	Zcy: Zcy,
	zcy: zcy,
	Zdot: Zdot,
	zdot: zdot,
	zeetrf: zeetrf,
	ZeroWidthSpace: ZeroWidthSpace,
	Zeta: Zeta,
	zeta: zeta,
	zfr: zfr,
	Zfr: Zfr,
	ZHcy: ZHcy,
	zhcy: zhcy,
	zigrarr: zigrarr,
	zopf: zopf,
	Zopf: Zopf,
	Zscr: Zscr,
	zscr: zscr,
	zwj: zwj,
	zwnj: zwnj,
	default: entitiesJSON
});

var require$$0$1 = ( xml && xmlJSON ) || xml;

var require$$1 = ( entities && entitiesJSON ) || entities;

var inverseXML = getInverseObj(require$$0$1);
var xmlReplacer = getInverseReplacer(inverseXML);

var XML = getInverse(inverseXML, xmlReplacer);

var inverseHTML = getInverseObj(require$$1);
var htmlReplacer = getInverseReplacer(inverseHTML);

var HTML = getInverse(inverseHTML, htmlReplacer);

function getInverseObj(obj){
	return Object.keys(obj).sort().reduce(function(inverse, name){
		inverse[obj[name]] = "&" + name + ";";
		return inverse;
	}, {});
}

function getInverseReplacer(inverse){
	var single = [],
	    multiple = [];

	Object.keys(inverse).forEach(function(k){
		if(k.length === 1){
			single.push("\\" + k);
		} else {
			multiple.push(k);
		}
	});

	
	multiple.unshift("[" + single.join("") + "]");

	return new RegExp(multiple.join("|"), "g");
}

var re_nonASCII = /[^\0-\x7F]/g;
var re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

function singleCharReplacer(c){
	return "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";";
}

function astralReplacer(c){
	
	var high = c.charCodeAt(0);
	var low  = c.charCodeAt(1);
	var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
	return "&#x" + codePoint.toString(16).toUpperCase() + ";";
}

function getInverse(inverse, re){
	function func(name){
		return inverse[name];
	}

	return function(data){
		return data
				.replace(re, func)
				.replace(re_astralSymbols, astralReplacer)
				.replace(re_nonASCII, singleCharReplacer);
	};
}

var re_xmlChars = getInverseReplacer(inverseXML);

function escapeXML(data){
	return data
			.replace(re_xmlChars, singleCharReplacer)
			.replace(re_astralSymbols, astralReplacer)
			.replace(re_nonASCII, singleCharReplacer);
}

var escape = escapeXML;

var encode = {
	XML: XML,
	HTML: HTML,
	escape: escape
};

var decode = {
	"0": 65533,
	"128": 8364,
	"130": 8218,
	"131": 402,
	"132": 8222,
	"133": 8230,
	"134": 8224,
	"135": 8225,
	"136": 710,
	"137": 8240,
	"138": 352,
	"139": 8249,
	"140": 338,
	"142": 381,
	"145": 8216,
	"146": 8217,
	"147": 8220,
	"148": 8221,
	"149": 8226,
	"150": 8211,
	"151": 8212,
	"152": 732,
	"153": 8482,
	"154": 353,
	"155": 8250,
	"156": 339,
	"158": 382,
	"159": 376
};

var decode$1 = Object.freeze({
	default: decode
});

var require$$0$1$1 = ( decode$1 && decode ) || decode$1;

var decodeMap = require$$0$1$1;

var decode_codepoint = decodeCodePoint;


function decodeCodePoint(codePoint){

	if((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF){
		return "\uFFFD";
	}

	if(codePoint in decodeMap){
		codePoint = decodeMap[codePoint];
	}

	var output = "";

	if(codePoint > 0xFFFF){
		codePoint -= 0x10000;
		output += String.fromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
		codePoint = 0xDC00 | codePoint & 0x3FF;
	}

	output += String.fromCharCode(codePoint);
	return output;
}

var Aacute$1 = "";
var aacute$1 = "";
var Acirc$1 = "";
var acirc$1 = "";
var acute$1 = "";
var AElig$1 = "";
var aelig$1 = "";
var Agrave$1 = "";
var agrave$1 = "";
var amp$2 = "&";
var AMP$1 = "&";
var Aring$1 = "";
var aring$1 = "";
var Atilde$1 = "";
var atilde$1 = "";
var Auml$1 = "";
var auml$1 = "";
var brvbar$1 = "";
var Ccedil$1 = "";
var ccedil$1 = "";
var cedil$1 = "";
var cent$1 = "";
var copy$1 = "";
var COPY$1 = "";
var curren$1 = "";
var deg$1 = "";
var divide$1 = "";
var Eacute$1 = "";
var eacute$1 = "";
var Ecirc$1 = "";
var ecirc$1 = "";
var Egrave$1 = "";
var egrave$1 = "";
var ETH$1 = "";
var eth$1 = "";
var Euml$1 = "";
var euml$1 = "";
var frac12$1 = "";
var frac14$1 = "";
var frac34$1 = "";
var gt$2 = ">";
var GT$1 = ">";
var Iacute$1 = "";
var iacute$1 = "";
var Icirc$1 = "";
var icirc$1 = "";
var iexcl$1 = "";
var Igrave$1 = "";
var igrave$1 = "";
var iquest$1 = "";
var Iuml$1 = "";
var iuml$1 = "";
var laquo$1 = "";
var lt$2 = "<";
var LT$1 = "<";
var macr$1 = "";
var micro$1 = "";
var middot$1 = "";
var nbsp$1 = "";
var not$1 = "";
var Ntilde$1 = "";
var ntilde$1 = "";
var Oacute$1 = "";
var oacute$1 = "";
var Ocirc$1 = "";
var ocirc$1 = "";
var Ograve$1 = "";
var ograve$1 = "";
var ordf$1 = "";
var ordm$1 = "";
var Oslash$1 = "";
var oslash$1 = "";
var Otilde$1 = "";
var otilde$1 = "";
var Ouml$1 = "";
var ouml$1 = "";
var para$1 = "";
var plusmn$1 = "";
var pound$1 = "";
var quot$2 = "\"";
var QUOT$1 = "\"";
var raquo$1 = "";
var reg$1 = "";
var REG$1 = "";
var sect$1 = "";
var shy$1 = "";
var sup1$1 = "";
var sup2$1 = "";
var sup3$1 = "";
var szlig$1 = "";
var THORN$1 = "";
var thorn$1 = "";
var times$1$1 = "";
var Uacute$1 = "";
var uacute$1 = "";
var Ucirc$1 = "";
var ucirc$1 = "";
var Ugrave$1 = "";
var ugrave$1 = "";
var uml$1 = "";
var Uuml$1 = "";
var uuml$1 = "";
var Yacute$1 = "";
var yacute$1 = "";
var yen$1 = "";
var yuml$1 = "";
var legacyJSON = {
	Aacute: Aacute$1,
	aacute: aacute$1,
	Acirc: Acirc$1,
	acirc: acirc$1,
	acute: acute$1,
	AElig: AElig$1,
	aelig: aelig$1,
	Agrave: Agrave$1,
	agrave: agrave$1,
	amp: amp$2,
	AMP: AMP$1,
	Aring: Aring$1,
	aring: aring$1,
	Atilde: Atilde$1,
	atilde: atilde$1,
	Auml: Auml$1,
	auml: auml$1,
	brvbar: brvbar$1,
	Ccedil: Ccedil$1,
	ccedil: ccedil$1,
	cedil: cedil$1,
	cent: cent$1,
	copy: copy$1,
	COPY: COPY$1,
	curren: curren$1,
	deg: deg$1,
	divide: divide$1,
	Eacute: Eacute$1,
	eacute: eacute$1,
	Ecirc: Ecirc$1,
	ecirc: ecirc$1,
	Egrave: Egrave$1,
	egrave: egrave$1,
	ETH: ETH$1,
	eth: eth$1,
	Euml: Euml$1,
	euml: euml$1,
	frac12: frac12$1,
	frac14: frac14$1,
	frac34: frac34$1,
	gt: gt$2,
	GT: GT$1,
	Iacute: Iacute$1,
	iacute: iacute$1,
	Icirc: Icirc$1,
	icirc: icirc$1,
	iexcl: iexcl$1,
	Igrave: Igrave$1,
	igrave: igrave$1,
	iquest: iquest$1,
	Iuml: Iuml$1,
	iuml: iuml$1,
	laquo: laquo$1,
	lt: lt$2,
	LT: LT$1,
	macr: macr$1,
	micro: micro$1,
	middot: middot$1,
	nbsp: nbsp$1,
	not: not$1,
	Ntilde: Ntilde$1,
	ntilde: ntilde$1,
	Oacute: Oacute$1,
	oacute: oacute$1,
	Ocirc: Ocirc$1,
	ocirc: ocirc$1,
	Ograve: Ograve$1,
	ograve: ograve$1,
	ordf: ordf$1,
	ordm: ordm$1,
	Oslash: Oslash$1,
	oslash: oslash$1,
	Otilde: Otilde$1,
	otilde: otilde$1,
	Ouml: Ouml$1,
	ouml: ouml$1,
	para: para$1,
	plusmn: plusmn$1,
	pound: pound$1,
	quot: quot$2,
	QUOT: QUOT$1,
	raquo: raquo$1,
	reg: reg$1,
	REG: REG$1,
	sect: sect$1,
	shy: shy$1,
	sup1: sup1$1,
	sup2: sup2$1,
	sup3: sup3$1,
	szlig: szlig$1,
	THORN: THORN$1,
	thorn: thorn$1,
	times: times$1$1,
	Uacute: Uacute$1,
	uacute: uacute$1,
	Ucirc: Ucirc$1,
	ucirc: ucirc$1,
	Ugrave: Ugrave$1,
	ugrave: ugrave$1,
	uml: uml$1,
	Uuml: Uuml$1,
	uuml: uuml$1,
	Yacute: Yacute$1,
	yacute: yacute$1,
	yen: yen$1,
	yuml: yuml$1
};

var _entities = {
  encodeXML: encode.XML,
  decodeCodepoint: decode_codepoint,
  entitiesJSON: entitiesJSON,
  legacyJSON: legacyJSON,
  xmlJSON: xmlJSON
};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var ElementType$1 = index;
var entities$1 = _entities;

var booleanAttributes = {
  __proto__: null,
  allowfullscreen: true,
  async: true,
  autofocus: true,
  autoplay: true,
  checked: true,
  controls: true,
  default: true,
  defer: true,
  disabled: true,
  hidden: true,
  ismap: true,
  loop: true,
  multiple: true,
  muted: true,
  open: true,
  readonly: true,
  required: true,
  reversed: true,
  scoped: true,
  seamless: true,
  selected: true,
  typemustmatch: true
};

var unencodedElements = {
  __proto__: null,
  style: true,
  script: true,
  xmp: true,
  iframe: true,
  noembed: true,
  noframes: true,
  plaintext: true,
  noscript: true
};

var singleTag = {
  __proto__: null,
  area: true,
  base: true,
  basefont: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  isindex: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true,
};

function formatAttribs(el, opts) {
  var output = [];
  var attributes = el.attributes;
  
  attributes.forEach(function (value, key) {
    if (!value && booleanAttributes[key]) {
      output.push(key);
    } else {
      output.push(key + '="' + (opts.decodeEntities ? entities$1.encodeXML(value) : value) + '"');
    }
  });
  return output.join(' ')
}

function render(dom, opts) {
  if (!Array.isArray(dom)) { dom = [dom]; }
  opts = opts || {};

  var output = [];

  for(var i = 0; i < dom.length; i++){
    var elem = dom[i];

    if (elem.type === 'root') {
      output.push(render(elem.childNodes, opts));
    } else if (ElementType$1.isTag(elem)) {
      output.push(renderTag(elem, opts));
    } else if (elem.type === ElementType$1.Directive) {
      output.push(renderDirective(elem));
    } else if (elem.type === ElementType$1.Comment) {
      output.push(renderComment(elem));
    } else if (elem.type === ElementType$1.CDATA) {
      output.push(renderCdata(elem));
    } else {
      output.push(renderText(elem, opts));
    }
  }

  return output.join('')
}

function renderTag(elem, opts) {
  
  if (elem.name === "svg") { opts = {decodeEntities: opts.decodeEntities, xmlMode: true}; }

  var tag = '<' + elem.name;
  var attribs = formatAttribs(elem, opts);

  if (attribs) {
    tag += ' ' + attribs;
  }

  if (
    opts.xmlMode
    && (!elem.childNodes || elem.childNodes.length === 0)
  ) {
    tag += '/>';
  } else {
    tag += '>';
    if (elem.childNodes) {
      tag += render(elem.childNodes, opts);
    }

    if (!singleTag[elem.name] || opts.xmlMode) {
      tag += '</' + elem.name + '>';
    }
  }

  return tag
}

function renderDirective(elem) {
  return '<' + elem.data + '>'
}

function renderText(elem, opts) {
  var data = elem.data || '';
  
  if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) {
    data = entities$1.encodeXML(data);
  }
  return data
}

function renderCdata(elem) {
  return '<![CDATA[' + elem.childNodes[0].data + ']]>'
}

function renderComment(elem) {
  return '<!--' + elem.data + '-->'
}

var serialize$1 = render;

var ElementType$1$1 = index;
var serialize = serialize$1;
var stringify = {
	getInnerHTML: getInnerHTML,
	getOuterHTML: serialize,
	getText: getText
};

function getInnerHTML(elem, opts){
	return elem.childNodes ? elem.childNodes.map(function(elem){
		return serialize(elem, opts);
	}).join("") : "";
}

function getText(elem){
	if(Array.isArray(elem)) { return elem.map(getText).join(""); }
	switch(elem.type) {
		case ElementType$1$1.Tag:
		case ElementType$1$1.Script:
		case ElementType$1$1.Style:
			return getText(elem.childNodes)
		case ElementType$1$1.Text:
		case ElementType$1$1.Comment:
		case ElementType$1$1.CDATA:
			return elem.data
		default:
			return ""
	}
}

var traversal = createCommonjsModule(function (module, exports) {
var getChildren = exports.getChildren = function(elem){
	return elem.childNodes;
};

var getParent = exports.getParent = function(elem){
	return elem.parent;
};

exports.getSiblings = function(elem){
	var parent = getParent(elem);
	return parent ? getChildren(parent) : [elem];
};

exports.getAttributeValue = function(elem, name){
	return elem.getAttribute(name);
};

exports.hasAttrib = function(elem, name){
	return elem.hasAttribute(name);
};

exports.getName = function(elem){
	return elem.name
};

exports.getNameWithoutNS = function(elem){
  return elem.nameWithoutNS
};
});

var manipulation = createCommonjsModule(function (module, exports) {
function removeElement(elem){
	if(elem.prev) { elem.prev.next = elem.next; }
	if(elem.next) { elem.next.prev = elem.prev; }
	if(elem.parent){
		var childs = elem.parent.childNodes;
		var pos = childs.lastIndexOf(elem);
		if (pos < 0) { throw new Error('Invalid state') }
		childs.splice(pos, 1);
		elem.parent = null;
	}
}

function replaceElement(elem, replacement){
	if (replacement.parent) { exports.removeElement(replacement); }
	var prev = replacement.prev = elem.prev;
	if(prev){
		prev.next = replacement;
	}

	var next = replacement.next = elem.next;
	if(next){
		next.prev = replacement;
	}

	var parent = replacement.parent = elem.parent;
	if(parent){
		var childs = parent.childNodes;
		var pos = childs.lastIndexOf(elem);
		if (pos < 0) { throw new Error('Invalid state') }
		childs[pos] = replacement;
	}
}

function appendChild(elem, child){
	if (child.parent) { removeElement(child); }
	child.parent = elem;

	if(elem.childNodes.push(child) !== 1){
		var sibling = elem.childNodes[elem.childNodes.length - 2];
		sibling.next = child;
		child.prev = sibling;
		child.next = null;
	}
}

function append(elem, next){
	if (next.parent) { removeElement(next); }
	var parent = elem.parent,
		currNext = elem.next;

	next.next = currNext;
	next.prev = elem;
	elem.next = next;
	next.parent = parent;

	if(currNext){
		currNext.prev = next;
		if(parent){
			var childs = parent.childNodes;
			var pos = childs.lastIndexOf(currNext);
			if (pos < 0) { throw new Error('Invalid state') }
			childs.splice(pos, 0, next);
		}
	} else if(parent){
		parent.childNodes.push(next);
	}
}

function prepend(elem, prev){
	if (prev.parent) { removeElement(prev); }
	var parent = elem.parent;
	if(parent){
		var childs = parent.childNodes;
		var pos = childs.lastIndexOf(elem);
		if (pos < 0) { throw new Error('Invalid state') }
		childs.splice(pos, 0, prev);
	}

	if(elem.prev){
		elem.prev.next = prev;
	}

	prev.parent = parent;
	prev.prev = elem.prev;
	prev.next = elem;
	elem.prev = prev;
}

exports.removeElement = removeElement;
exports.replaceElement = replaceElement;
exports.appendChild = appendChild;
exports.append = append;
exports.prepend = prepend;
});

var isTag$1 = index.isTag;

var querying = {
	filter: filter$1,
	find: find$1,
	findOneChild: findOneChild,
	findOne: findOne,
	existsOne: existsOne,
	findAll: findAll
};

function filter$1(test, element, recurse, limit){
	if(!Array.isArray(element)) { element = [element]; }

	if(typeof limit !== "number" || !isFinite(limit)){
		limit = Infinity;
	}
	return find$1(test, element, recurse !== false, limit);
}

function find$1(test, elems, recurse, limit){
	var result = [], childs;

	for(var i = 0, j = elems.length; i < j; i++){
		if(test(elems[i])){
			result.push(elems[i]);
			if(--limit <= 0) { break; }
		}

		childs = elems[i].childNodes;
		if(recurse && childs && childs.length > 0){
			childs = find$1(test, childs, recurse, limit);
			result = result.concat(childs);
			limit -= childs.length;
			if(limit <= 0) { break; }
		}
	}

	return result;
}

function findOneChild(test, elems){
	for(var i = 0, l = elems.length; i < l; i++){
		if(test(elems[i])) { return elems[i]; }
	}

	return null;
}

function findOne(test, elems){
	var elem = null;

	for(var i = 0, l = elems.length; i < l && !elem; i++){
		var child = elems[i];
		if(!isTag$1(child)){
			continue;
		} else if(test(child)){
			elem = child;
		} else if(child.childNodes.length > 0){
			elem = findOne(test, child.childNodes);
		}
	}

	return elem;
}

function existsOne(test, elems){
	for(var i = 0, l = elems.length; i < l; i++){
		if(
			isTag$1(elems[i]) && (
				test(elems[i]) || (
					elems[i].childNodes.length > 0 &&
					existsOne(test, elems[i].childNodes)
				)
			)
		){
			return true;
		}
	}

	return false;
}

function findAll(test, elems){
	var result = [];
	for(var i = 0, j = elems.length; i < j; i++){
		if(!isTag$1(elems[i])) { continue; }
		if(test(elems[i])) { result.push(elems[i]); }

		if(elems[i].childNodes.length > 0){
			result = result.concat(findAll(test, elems[i].childNodes));
		}
	}
	return result;
}

var legacy = createCommonjsModule(function (module, exports) {
var ElementType = index;
var isTag = exports.isTag = ElementType.isTag;

exports.testElement = function(options, element){
	for(var key in options){
		if(!options.hasOwnProperty(key)){  }
		else if(key === "tag_name"){
			if(!isTag(element) || !options.tag_name(element.name)){
				return false;
			}
		} else if(key === "tag_type"){
			if(!options.tag_type(element.type)) { return false; }
		} else if(key === "tag_contains"){
			if(isTag(element) || !options.tag_contains(element.data)){
				return false;
			}
		} else if(!element.attributes || !options[key](element.getAttribute(key))) {
			return false;
		}
	}
	return true;
};

var Checks = {
	tag_name: function(name){
		if(typeof name === "function"){
			return function(elem){ return isTag(elem) && name(elem.name); };
		} else if(name === "*"){
			return isTag;
		} else {
			return function(elem){ return isTag(elem) && elem.name === name; };
		}
	},
	tag_type: function(type){
		if(typeof type === "function"){
			return function(elem){ return type(elem.type); };
		} else {
			return function(elem){ return elem.type === type; };
		}
	},
	tag_contains: function(data){
		if(typeof data === "function"){
			return function(elem){ return !isTag(elem) && data(elem.data); };
		} else {
			return function(elem){ return !isTag(elem) && elem.data === data; };
		}
	}
};

function getAttribCheck(attrib, value){
	if(typeof value === "function"){
		return function(elem){ return value(elem.getAttribute(attrib)); };
	} else {
		return function(elem){ return elem.getAttribute(attrib) === value; };
	}
}

function combineFuncs(a, b){
	return function(elem){
		return a(elem) || b(elem);
	};
}

exports.getElements = function(options, element, recurse, limit){
	var funcs = Object.keys(options).map(function(key){
		var value = options[key];
		return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
	});

	return funcs.length === 0 ? [] : this.filter(
		funcs.reduce(combineFuncs),
		element, recurse, limit
	);
};

exports.getElementById = function(id, element, recurse){
	if(!Array.isArray(element)) { element = [element]; }
	return this.findOne(getAttribCheck("id", id), element, recurse !== false);
};

exports.getElementsByTagName = function(name, element, recurse, limit){
	return this.filter(Checks.tag_name(name), element, recurse, limit);
};

exports.getElementsByTagType = function(type, element, recurse, limit){
	return this.filter(Checks.tag_type(type), element, recurse, limit);
};
});

var helpers = createCommonjsModule(function (module, exports) {


exports.removeSubsets = function(nodes) {
	var idx = nodes.length, node, ancestor, replace;

	
	
	while (--idx > -1) {
		node = ancestor = nodes[idx];

		
		nodes[idx] = null;
		replace = true;

		while (ancestor) {
			if (nodes.indexOf(ancestor) > -1) {
				replace = false;
				nodes.splice(idx, 1);
				break;
			}
			ancestor = ancestor.parent;
		}

		
		if (replace) {
			nodes[idx] = node;
		}
	}

	return nodes;
};


var POSITION = {
	DISCONNECTED: 1,
	PRECEDING: 2,
	FOLLOWING: 4,
	CONTAINS: 8,
	CONTAINED_BY: 16
};























var comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {
	var aParents = [];
	var bParents = [];
	var current, sharedParent, siblings, aSibling, bSibling, idx;

	if (nodeA === nodeB) {
		return 0;
	}

	current = nodeA;
	while (current) {
		aParents.unshift(current);
		current = current.parent;
	}
	current = nodeB;
	while (current) {
		bParents.unshift(current);
		current = current.parent;
	}

	idx = 0;
	while (aParents[idx] === bParents[idx]) {
		idx++;
	}

	if (idx === 0) {
		return POSITION.DISCONNECTED;
	}

	sharedParent = aParents[idx - 1];
	siblings = sharedParent.childNodes;
	aSibling = aParents[idx];
	bSibling = bParents[idx];

	if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
		if (sharedParent === nodeB) {
			return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
		}
		return POSITION.FOLLOWING;
	} else {
		if (sharedParent === nodeA) {
			return POSITION.PRECEDING | POSITION.CONTAINS;
		}
		return POSITION.PRECEDING;
	}
};








exports.uniqueSort = function(nodes) {
	var idx = nodes.length, node, position;

	nodes = nodes.slice();

	while (--idx > -1) {
		node = nodes[idx];
		position = nodes.indexOf(node);
		if (position > -1 && position < idx) {
			nodes.splice(idx, 1);
		}
	}
	nodes.sort(function(a, b) {
		var relative = comparePos(a, b);
		if (relative & POSITION.PRECEDING) {
			return -1;
		} else if (relative & POSITION.FOLLOWING) {
			return 1;
		}
		return 0;
	});

	return nodes;
};
});

var index$2 = createCommonjsModule(function (module) {
var DomUtils = module.exports;

[
	stringify,
	traversal,
	manipulation,
	querying,
	legacy,
	helpers
].forEach(function(ext){
	Object.keys(ext).forEach(function(key){
		DomUtils[key] = ext[key].bind(DomUtils);
	});
});
});

var index$3 = {
	trueFunc: function trueFunc(){
		return true;
	},
	falseFunc: function falseFunc(){
		return false;
	}
};

var index$4 = parse$1;

var re_name = /^(?:\\.|[\w\-\u00c0-\uFFFF])+/;
var re_escape = /\\([\da-f]{1,6}\s?|(\s)|.)/ig;
var re_attr = /^\s*((?:\\.|[\w\u00c0-\uFFFF\-])+)\s*(?:(\S?)=\s*(?:(['"])(.*?)\3|(#?(?:\\.|[\w\u00c0-\uFFFF\-])*)|)|)\s*(i)?\]/;

var actionTypes = {
	__proto__: null,
	"undefined": "exists",
	"":  "equals",
	"~": "element",
	"^": "start",
	"$": "end",
	"*": "any",
	"!": "not",
	"|": "hyphen"
};

var simpleSelectors = {
	__proto__: null,
	">": "child",
	"<": "parent",
	"~": "sibling",
	"+": "adjacent"
};

var attribSelectors = {
	__proto__: null,
	"#": ["id", "equals"],
	".": ["class", "element"]
};


var unpackPseudos = {
	__proto__: null,
	"has": true,
	"not": true,
	"matches": true
};

var stripQuotesFromPseudos = {
	__proto__: null,
	"contains": true,
	"icontains": true
};

var quotes = {
	__proto__: null,
	"\"": true,
	"'": true
};


function funescape( _, escaped, escapedWhitespace ) {
	var high = "0x" + escaped - 0x10000;
	
	
	
	return high !== high || escapedWhitespace ?
		escaped :
		
		high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
}

function unescapeCSS(str){
	return str.replace(re_escape, funescape);
}

function isWhitespace(c){
	return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function parse$1(selector, options){
	var subselects = [];

	selector = parseSelector(subselects, selector + "", options);

	if(selector !== ""){
		throw new SyntaxError("Unmatched selector: " + selector);
	}

	return subselects;
}

function parseSelector(subselects, selector, options){
	var tokens = [],
		sawWS = false,
		data, firstChar, name, quot;

	function getName(){
		var sub = selector.match(re_name)[0];
		selector = selector.substr(sub.length);
		return unescapeCSS(sub);
	}

	function stripWhitespace(start){
		while(isWhitespace(selector.charAt(start))) { start++; }
		selector = selector.substr(start);
	}

	stripWhitespace(0);

	while(selector !== ""){
		firstChar = selector.charAt(0);

		if(isWhitespace(firstChar)){
			sawWS = true;
			stripWhitespace(1);
		} else if(firstChar in simpleSelectors){
			tokens.push({type: simpleSelectors[firstChar]});
			sawWS = false;

			stripWhitespace(1);
		} else if(firstChar === ","){
			if(tokens.length === 0){
				throw new SyntaxError("empty sub-selector");
			}
			subselects.push(tokens);
			tokens = [];
			sawWS = false;
			stripWhitespace(1);
		} else {
			if(sawWS){
				if(tokens.length > 0){
					tokens.push({type: "descendant"});
				}
				sawWS = false;
			}

			if(firstChar === "*"){
				selector = selector.substr(1);
				tokens.push({type: "universal"});
			} else if(firstChar in attribSelectors){
				selector = selector.substr(1);
				tokens.push({
					type: "attribute",
					name: attribSelectors[firstChar][0],
					action: attribSelectors[firstChar][1],
					value: getName(),
					ignoreCase: false
				});
			} else if(firstChar === "["){
				selector = selector.substr(1);
				data = selector.match(re_attr);
				if(!data){
					throw new SyntaxError("Malformed attribute selector: " + selector);
				}
				selector = selector.substr(data[0].length);
				name = unescapeCSS(data[1]);

				if(
					!options || (
						"lowerCaseAttributeNames" in options ?
							options.lowerCaseAttributeNames :
							!options.xmlMode
					)
				){
					name = name.toLowerCase();
				}

				tokens.push({
					type: "attribute",
					name: name,
					action: actionTypes[data[2]],
					value: unescapeCSS(data[4] || data[5] || ""),
					ignoreCase: !!data[6]
				});

			} else if(firstChar === ":"){
				if(selector.charAt(1) === ":"){
					selector = selector.substr(2);
					tokens.push({type: "pseudo-element", name: getName().toLowerCase()});
					continue;
				}

				selector = selector.substr(1);

				name = getName().toLowerCase();
				data = null;

				if(selector.charAt(0) === "("){
					if(name in unpackPseudos){
						quot = selector.charAt(1);
						var quoted = quot in quotes;

						selector = selector.substr(quoted + 1);

						data = [];
						selector = parseSelector(data, selector, options);

						if(quoted){
							if(selector.charAt(0) !== quot){
								throw new SyntaxError("unmatched quotes in :" + name);
							} else {
								selector = selector.substr(1);
							}
						}

						if(selector.charAt(0) !== ")"){
							throw new SyntaxError("missing closing parenthesis in :" + name + " " + selector);
						}

						selector = selector.substr(1);
					} else {
						var pos = 1, counter = 1;

						for(; counter > 0 && pos < selector.length; pos++){
							if(selector.charAt(pos) === "(") { counter++; }
							else if(selector.charAt(pos) === ")") { counter--; }
						}

						if(counter){
							throw new SyntaxError("parenthesis not matched");
						}

						data = selector.substr(1, pos - 2);
						selector = selector.substr(pos);

						if(name in stripQuotesFromPseudos){
							quot = data.charAt(0);

							if(quot === data.slice(-1) && quot in quotes){
								data = data.slice(1, -1);
							}

							data = unescapeCSS(data);
						}
					}
				}

				tokens.push({type: "pseudo", name: name, data: data});
			} else if(re_name.test(selector)){
				name = getName();

				if(!options || ("lowerCaseTags" in options ? options.lowerCaseTags : !options.xmlMode)){
					name = name.toLowerCase();
				}

				tokens.push({type: "tag", name: name});
			} else {
				if(tokens.length && tokens[tokens.length - 1].type === "descendant"){
					tokens.pop();
				}
				addToken(subselects, tokens);
				return selector;
			}
		}
	}

	addToken(subselects, tokens);

	return selector;
}

function addToken(subselects, tokens){
	if(subselects.length > 0 && tokens.length === 0){
		throw new SyntaxError("empty sub-selector");
	}

	subselects.push(tokens);
}

var parse_1$1 = parse$2;




var re_nthElement = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;


function parse$2(formula){
	formula = formula.trim().toLowerCase();

	if(formula === "even"){
		return [2, 0];
	} else if(formula === "odd"){
		return [2, 1];
	} else {
		var parsed = formula.match(re_nthElement);

		if(!parsed){
			throw new SyntaxError("n-th rule couldn't be parsed ('" + formula + "')");
		}

		var a;

		if(parsed[1]){
			a = parseInt(parsed[1], 10);
			if(isNaN(a)){
				if(parsed[1].charAt(0) === "-") { a = -1; }
				else { a = 1; }
			}
		} else { a = 0; }

		return [
			a,
			parsed[3] ? parseInt((parsed[2] || "") + parsed[3], 10) : 0
		];
	}
}

var compile_1$1 = compile$1;

var trueFunc$1$1  = index$3.trueFunc;
var falseFunc$1$1 = index$3.falseFunc;


function compile$1(parsed){
	var a = parsed[0],
	    b = parsed[1] - 1;

	
	
	if(b < 0 && a <= 0) { return falseFunc$1$1; }

	
	if(a ===-1) { return function(pos){ return pos <= b; }; }
	if(a === 0) { return function(pos){ return pos === b; }; }
	
	if(a === 1) { return b < 0 ? trueFunc$1$1 : function(pos){ return pos >= b; }; }

	
	var bMod = b % a;
	if(bMod < 0) { bMod += a; }

	if(a > 1){
		return function(pos){
			return pos >= b && pos % a === bMod;
		};
	}

	a *= -1; 

	return function(pos){
		return pos <= b && pos % a === bMod;
	};
}

var index$5 = function nthCheck(formula){
	return compile_1$1(parse_1$1(formula));
};

var parse_1 = parse_1$1;
var compile_1 = compile_1$1;

index$5.parse = parse_1;
index$5.compile = compile_1;

var universal = 50;
var tag = 30;
var attribute = 1;
var pseudo = 0;
var descendant = -1;
var child = -1;
var parent$1 = -1;
var sibling = -1;
var adjacent = -1;
var procedure$2 = {
	universal: universal,
	tag: tag,
	attribute: attribute,
	pseudo: pseudo,
	descendant: descendant,
	child: child,
	parent: parent$1,
	sibling: sibling,
	adjacent: adjacent
};

var procedure$3 = Object.freeze({
	universal: universal,
	tag: tag,
	attribute: attribute,
	pseudo: pseudo,
	descendant: descendant,
	child: child,
	parent: parent$1,
	sibling: sibling,
	adjacent: adjacent,
	default: procedure$2
});

var require$$0 = ( procedure$3 && procedure$2 ) || procedure$3;

var sort = sortByProcedure;



var procedure$1 = require$$0;

var attributes = {
	__proto__: null,
	exists: 10,
	equals: 8,
	not: 7,
	start: 6,
	end: 6,
	any: 5,
	hyphen: 4,
	element: 4
};

function sortByProcedure(arr){
	var procs = arr.map(getProcedure);
	for(var i = 1; i < arr.length; i++){
		var procNew = procs[i];

		if(procNew < 0) { continue; }

		for(var j = i - 1; j >= 0 && procNew < procs[j]; j--){
			var token = arr[j + 1];
			arr[j + 1] = arr[j];
			arr[j] = token;
			procs[j + 1] = procs[j];
			procs[j] = procNew;
		}
	}
}

function getProcedure(token){
	var proc = procedure$1[token.type];

	if(proc === procedure$1.attribute){
		proc = attributes[token.action];

		if(proc === attributes.equals && token.name === "id"){
			
			proc = 9;
		}

		if(token.ignoreCase){
			
			
			proc >>= 1;
		}
	} else if(proc === procedure$1.pseudo){
		if(!token.data){
			proc = 3;
		} else if(token.name === "has" || token.name === "contains"){
			proc = 0; 
		} else if(token.name === "matches" || token.name === "not"){
			proc = 0;
			for(var i = 0; i < token.data.length; i++){
				
				if(token.data[i].length !== 1) { continue; }
				var cur = getProcedure(token.data[i][0]);
				
				if(cur === 0){
					proc = 0;
					break;
				}
				if(cur > proc) { proc = cur; }
			}
			if(token.data.length > 1 && proc > 0) { proc -= 1; }
		} else {
			proc = 1;
		}
	}
	return proc;
}

var falseFunc$2 = index$3.falseFunc;


var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;

function factory(adapter){
	
	var attributeRules = {
		__proto__: null,
		equals: function(next, data){
			var name  = data.name,
				value = data.value;

			if(data.ignoreCase){
				value = value.toLowerCase();

				return function equalsIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null && attr.toLowerCase() === value && next(elem);
				};
			}

			return function equals(elem){
				return adapter.getAttributeValue(elem, name) === value && next(elem);
			};
		},
		hyphen: function(next, data){
			var name  = data.name,
				value = data.value,
				len = value.length;

			if(data.ignoreCase){
				value = value.toLowerCase();

				return function hyphenIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null &&
							(attr.length === len || attr.charAt(len) === "-") &&
							attr.substr(0, len).toLowerCase() === value &&
							next(elem);
				};
			}

			return function hyphen(elem){
				var attr = adapter.getAttributeValue(elem, name);
				return attr != null &&
						attr.substr(0, len) === value &&
						(attr.length === len || attr.charAt(len) === "-") &&
						next(elem);
			};
		},
		element: function(next, data){
			var name = data.name,
				value = data.value;
			if (data.name === 'class') {
				var value$1 = data.value;
				if (/\s/.test(value$1)) { return function() { return false } }
				return function clazz(elem) {
					var classes = elem.classes;
					return classes && classes.has(value$1) && next(elem)
				}
			} else {
				if(/\s/.test(value)){
					return falseFunc$2;
				}

				value = value.replace(reChars, "\\$&");

				var pattern = "(?:^|\\s)" + value + "(?:$|\\s)",
					flags = data.ignoreCase ? "i" : "",
					regex = new RegExp(pattern, flags);

				return function element(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null && regex.test(attr) && next(elem);
				};
			}
		},
		exists: function(next, data){
			var name = data.name;
			return function exists(elem){
				return adapter.hasAttrib(elem, name) && next(elem);
			};
		},
		start: function(next, data){
			var name  = data.name,
				value = data.value,
				len = value.length;

			if(len === 0){
				return falseFunc$2;
			}

			if(data.ignoreCase){
				value = value.toLowerCase();

				return function startIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null && attr.substr(0, len).toLowerCase() === value && next(elem);
				};
			}

			return function start(elem){
				var attr = adapter.getAttributeValue(elem, name);
				return attr != null && attr.substr(0, len) === value && next(elem);
			};
		},
		end: function(next, data){
			var name  = data.name,
				value = data.value,
				len   = -value.length;

			if(len === 0){
				return falseFunc$2;
			}

			if(data.ignoreCase){
				value = value.toLowerCase();

				return function endIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null && attr.substr(len).toLowerCase() === value && next(elem);
				};
			}

			return function end(elem){
				var attr = adapter.getAttributeValue(elem, name);
				return attr != null && attr.substr(len) === value && next(elem);
			};
		},
		any: function(next, data){
			var name  = data.name,
				value = data.value;

			if(value === ""){
				return falseFunc$2;
			}

			if(data.ignoreCase){
				var regex = new RegExp(value.replace(reChars, "\\$&"), "i");

				return function anyIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null && regex.test(attr) && next(elem);
				};
			}

			return function any(elem){
				var attr = adapter.getAttributeValue(elem, name);
				return attr != null && attr.indexOf(value) >= 0 && next(elem);
			};
		},
		not: function(next, data){
			var name  = data.name,
				value = data.value;

			if(value === ""){
				return function notEmpty(elem){
					return !!adapter.getAttributeValue(elem, name) && next(elem);
				};
			} else if(data.ignoreCase){
				value = value.toLowerCase();

				return function notIC(elem){
					var attr = adapter.getAttributeValue(elem, name);
					return attr != null && attr.toLowerCase() !== value && next(elem);
				};
			}

			return function not(elem){
				return adapter.getAttributeValue(elem, name) !== value && next(elem);
			};
		}
	};

	return {
		compile: function(next, data, options){
			if(options && options.strict && (
				data.ignoreCase || data.action === "not"
			)) { throw new Error("Unsupported attribute selector"); }
			return attributeRules[data.action](next, data);
		},
		rules: attributeRules
	};
}

var attributes$1 = factory;

var attributeFactory = attributes$1;

function generalFactory(adapter, Pseudos){
	
	return {
		__proto__: null,

		attribute: attributeFactory(adapter).compile,
		pseudo: Pseudos.compile,

		
		tag: function(next, data){
			var name = data.name;
			return function tag(elem){
				return adapter.getNameWithoutNS(elem) === name && next(elem);
			}
		},

		
		descendant: function(next){
			return function descendant(elem){

				var found = false;

				while(!found && (elem = adapter.getParent(elem))){
					found = next(elem);
				}

				return found;
			};
		},
		_flexibleDescendant: function(next){
			
			return function descendant(elem){

				var found = next(elem);

				while(!found && (elem = adapter.getParent(elem))){
					found = next(elem);
				}

				return found;
			};
		},
		parent: function(next, data, options){
			if(options && options.strict) { throw new Error("Parent selector isn't part of CSS3"); }

			return function parent(elem){
				return adapter.getChildren(elem).some(test);
			};

			function test(elem){
				return adapter.isTag(elem) && next(elem);
			}
		},
		child: function(next){
			return function child(elem){
				var parent = adapter.getParent(elem);
				return !!parent && next(parent);
			};
		},
		sibling: function(next){
			return function sibling(elem){
				var siblings = adapter.getSiblings(elem);

				for(var i = 0; i < siblings.length; i++){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) { break; }
						if(next(siblings[i])) { return true; }
					}
				}

				return false;
			};
		},
		adjacent: function(next){
			return function adjacent(elem){
				var siblings = adapter.getSiblings(elem),
					lastElement;

				for(var i = 0; i < siblings.length; i++){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) { break; }
						lastElement = siblings[i];
					}
				}

				return !!lastElement && next(lastElement);
			};
		},
		universal: function(next){
			return next;
		}
	};
}

var general = generalFactory;

var getNCheck         = index$5;
var BaseFuncs$1         = index$3;
var attributesFactory = attributes$1;
var trueFunc$1          = BaseFuncs$1.trueFunc;
var falseFunc$3         = BaseFuncs$1.falseFunc;

function filtersFactory(adapter){
	var attributes  = attributesFactory(adapter),
		checkAttrib = attributes.rules.equals;

	
	function equals(a, b){
		if(typeof adapter.equals === "function") { return adapter.equals(a, b); }

		return a === b;
	}

	function getAttribFunc(name, value){
		var data = {name: name, value: value};
		return function attribFunc(next){
			return checkAttrib(next, data);
		};
	}

	function getChildFunc(next){
		return function(elem){
			return !!adapter.getParent(elem) && next(elem);
		};
	}

	var filters = {
		contains: function(next, text){
			return function contains(elem){
				return next(elem) && adapter.getText(elem).indexOf(text) >= 0;
			};
		},
		icontains: function(next, text){
			var itext = text.toLowerCase();
			return function icontains(elem){
				return next(elem) &&
					adapter.getText(elem).toLowerCase().indexOf(itext) >= 0;
			};
		},

		
		"nth-child": function(next, rule){
			var func = getNCheck(rule);

			if(func === falseFunc$3) { return func; }
			if(func === trueFunc$1)  { return getChildFunc(next); }

			return function nthChild(elem){
				var siblings = adapter.getSiblings(elem);

				for(var i = 0, pos = 0; i < siblings.length; i++){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) { break; }
						else { pos++; }
					}
				}

				return func(pos) && next(elem);
			};
		},
		"nth-last-child": function(next, rule){
			var func = getNCheck(rule);

			if(func === falseFunc$3) { return func; }
			if(func === trueFunc$1)  { return getChildFunc(next); }

			return function nthLastChild(elem){
				var siblings = adapter.getSiblings(elem);

				for(var pos = 0, i = siblings.length - 1; i >= 0; i--){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) { break; }
						else { pos++; }
					}
				}

				return func(pos) && next(elem);
			};
		},
		"nth-of-type": function(next, rule){
			var func = getNCheck(rule);

			if(func === falseFunc$3) { return func; }
			if(func === trueFunc$1)  { return getChildFunc(next); }

			return function nthOfType(elem){
				var siblings = adapter.getSiblings(elem);

				for(var pos = 0, i = 0; i < siblings.length; i++){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) { break; }
						if(adapter.getName(siblings[i]) === adapter.getName(elem)) { pos++; }
					}
				}

				return func(pos) && next(elem);
			};
		},
		"nth-last-of-type": function(next, rule){
			var func = getNCheck(rule);

			if(func === falseFunc$3) { return func; }
			if(func === trueFunc$1)  { return getChildFunc(next); }

			return function nthLastOfType(elem){
				var siblings = adapter.getSiblings(elem);

				for(var pos = 0, i = siblings.length - 1; i >= 0; i--){
					if(adapter.isTag(siblings[i])){
						if(siblings[i] === elem) { break; }
						if(adapter.getName(siblings[i]) === adapter.getName(elem)) { pos++; }
					}
				}

				return func(pos) && next(elem);
			};
		},

		
		root: function(next){
			return function(elem){
				return !adapter.getParent(elem) && next(elem);
			};
		},

		scope: function(next, rule, options, context){
			if(!context || context.length === 0){
				
				return filters.root(next);
			}

			if(context.length === 1){
				
				return function(elem){
					return equals(context[0], elem) && next(elem);
				};
			}

			return function(elem){
				return context.indexOf(elem) >= 0 && next(elem);
			};
		},

		
		checkbox: getAttribFunc("type", "checkbox"),
		file: getAttribFunc("type", "file"),
		password: getAttribFunc("type", "password"),
		radio: getAttribFunc("type", "radio"),
		reset: getAttribFunc("type", "reset"),
		image: getAttribFunc("type", "image"),
		submit: getAttribFunc("type", "submit")
	};
	return filters;
}

function pseudosFactory$1(adapter){
	
	function getFirstElement(elems){
		for(var i = 0; elems && i < elems.length; i++){
			if(adapter.isTag(elems[i])) { return elems[i]; }
		}
	}

	
	var pseudos = {
		empty: function(elem){
			return !adapter.getChildren(elem).some(function(elem){
				return adapter.isTag(elem) || elem.type === "text";
			});
		},

		"first-child": function(elem){
			return getFirstElement(adapter.getSiblings(elem)) === elem;
		},
		"last-child": function(elem){
			var siblings = adapter.getSiblings(elem);

			for(var i = siblings.length - 1; i >= 0; i--){
				if(siblings[i] === elem) { return true; }
				if(adapter.isTag(siblings[i])) { break; }
			}

			return false;
		},
		"first-of-type": function(elem){
			var siblings = adapter.getSiblings(elem);

			for(var i = 0; i < siblings.length; i++){
				if(adapter.isTag(siblings[i])){
					if(siblings[i] === elem) { return true; }
					if(adapter.getName(siblings[i]) === adapter.getName(elem)) { break; }
				}
			}

			return false;
		},
		"last-of-type": function(elem){
			var siblings = adapter.getSiblings(elem);

			for(var i = siblings.length - 1; i >= 0; i--){
				if(adapter.isTag(siblings[i])){
					if(siblings[i] === elem) { return true; }
					if(adapter.getName(siblings[i]) === adapter.getName(elem)) { break; }
				}
			}

			return false;
		},
		"only-of-type": function(elem){
			var siblings = adapter.getSiblings(elem);

			for(var i = 0, j = siblings.length; i < j; i++){
				if(adapter.isTag(siblings[i])){
					if(siblings[i] === elem) { continue; }
					if(adapter.getName(siblings[i]) === adapter.getName(elem)) { return false; }
				}
			}

			return true;
		},
		"only-child": function(elem){
			var siblings = adapter.getSiblings(elem);

			for(var i = 0; i < siblings.length; i++){
				if(adapter.isTag(siblings[i]) && siblings[i] !== elem) { return false; }
			}

			return true;
		},

		
		link: function(elem){
			return adapter.hasAttrib(elem, "href");
		},
		visited: falseFunc$3, 
		

		
		

		
		selected: function(elem){
			if(adapter.hasAttrib(elem, "selected")) { return true; }
			else if(adapter.getName(elem) !== "option") { return false; }

			
			var parent = adapter.getParent(elem);

			if(
				!parent ||
				adapter.getName(parent) !== "select" ||
				adapter.hasAttrib(parent, "multiple")
			) { return false; }

			var siblings = adapter.getChildren(parent),
				sawElem  = false;

			for(var i = 0; i < siblings.length; i++){
				if(adapter.isTag(siblings[i])){
					if(siblings[i] === elem){
						sawElem = true;
					} else if(!sawElem){
						return false;
					} else if(adapter.hasAttrib(siblings[i], "selected")){
						return false;
					}
				}
			}

			return sawElem;
		},
		
		
		
		
		
		
		disabled: function(elem){
			return adapter.hasAttrib(elem, "disabled");
		},
		enabled: function(elem){
			return !adapter.hasAttrib(elem, "disabled");
		},
		
		checked: function(elem){
			return adapter.hasAttrib(elem, "checked") || pseudos.selected(elem);
		},
		
		required: function(elem){
			return adapter.hasAttrib(elem, "required");
		},
		
		optional: function(elem){
			return !adapter.hasAttrib(elem, "required");
		},

		

		
		parent: function(elem){
			return !pseudos.empty(elem);
		},
		
		header: function(elem){
			var name = adapter.getName(elem);
			return name === "h1" ||
					name === "h2" ||
					name === "h3" ||
					name === "h4" ||
					name === "h5" ||
					name === "h6";
		},

		
		button: function(elem){
			var name = adapter.getName(elem);
			return name === "button" ||
					name === "input" &&
					adapter.getAttributeValue(elem, "type") === "button";
		},
		
		input: function(elem){
			var name = adapter.getName(elem);
			return name === "input" ||
					name === "textarea" ||
					name === "select" ||
					name === "button";
		},
		
		text: function(elem){
			var attr;
			return adapter.getName(elem) === "input" && (
				!(attr = adapter.getAttributeValue(elem, "type")) ||
				attr.toLowerCase() === "text"
			);
		}
	};

	return pseudos;
}

function verifyArgs(func, name, subselect){
	if(subselect === null){
		if(func.length > 1 && name !== "scope"){
			throw new Error("pseudo-selector :" + name + " requires an argument");
		}
	} else {
		if(func.length === 1){
			throw new Error("pseudo-selector :" + name + " doesn't have any arguments");
		}
	}
}


var re_CSS3 = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;

function factory$1(adapter){
	var pseudos = pseudosFactory$1(adapter);
	var filters = filtersFactory(adapter);

	return {
		compile: function(next, data, options, context){
			var name = data.name,
				subselect = data.data;

			if(options && options.strict && !re_CSS3.test(name)){
				throw new Error(":" + name + " isn't part of CSS3");
			}

			if(typeof filters[name] === "function"){
				verifyArgs(filters[name], name,  subselect);
				return filters[name](next, subselect, options, context);
			} else if(typeof pseudos[name] === "function"){
				var func = pseudos[name];
				verifyArgs(func, name, subselect);

				if(next === trueFunc$1) { return func; }

				return function pseudoArgs(elem){
					return func(elem, subselect) && next(elem);
				};
			} else {
				throw new Error("unmatched pseudo-class :" + name);
			}
		},
		filters: filters,
		pseudos: pseudos
	};
}

var pseudos = factory$1;

var compile$$1 = compileFactory$1;

var parse$$1          = index$4;
var BaseFuncs      = index$3;
var sortRules      = sort;
var procedure      = require$$0;
var rulesFactory   = general;
var pseudosFactory = pseudos;
var trueFunc       = BaseFuncs.trueFunc;
var falseFunc$1      = BaseFuncs.falseFunc;

function compileFactory$1(adapter){
	var Pseudos     = pseudosFactory(adapter),
		filters     = Pseudos.filters,
		Rules 			= rulesFactory(adapter, Pseudos);

	function compile$$1(selector, options, context){
		var next = compileUnsafe(selector, options, context);
		return wrap(next);
	}

	function wrap(next){
		return function base(elem){
			return adapter.isTag(elem) && next(elem);
		};
	}

	function compileUnsafe(selector, options, context){
		var token = parse$$1(selector, options);
		return compileToken(token, options, context);
	}

	function includesScopePseudo(t){
		return t.type === "pseudo" && (
			t.name === "scope" || (
				Array.isArray(t.data) &&
				t.data.some(function(data){
					return data.some(includesScopePseudo);
				})
			)
		);
	}

	var DESCENDANT_TOKEN = {type: "descendant"},
		FLEXIBLE_DESCENDANT_TOKEN = {type: "_flexibleDescendant"},
		SCOPE_TOKEN = {type: "pseudo", name: "scope"},
		PLACEHOLDER_ELEMENT = {};

	
	
	function absolutize(token, context){
		
		var hasContext = !!context && !!context.length && context.every(function(e){
			return e === PLACEHOLDER_ELEMENT || !!adapter.getParent(e);
		});


		token.forEach(function(t){
			if(t.length > 0 && isTraversal(t[0]) && t[0].type !== "descendant"){
				
			} else if(hasContext && !includesScopePseudo(t)){
				t.unshift(DESCENDANT_TOKEN);
			} else {
				return;
			}

			t.unshift(SCOPE_TOKEN);
		});
	}

	function compileToken(token, options, context){
		token = token.filter(function(t){ return t.length > 0; });

		token.forEach(sortRules);

		var isArrayContext = Array.isArray(context);

		context = (options && options.context) || context;

		if(context && !isArrayContext) { context = [context]; }

		absolutize(token, context);

		var shouldTestNextSiblings = false;

		var query = token
			.map(function(rules){
				if(rules[0] && rules[1] && rules[0].name === "scope"){
					var ruleType = rules[1].type;
					if(isArrayContext && ruleType === "descendant") { rules[1] = FLEXIBLE_DESCENDANT_TOKEN; }
					else if(ruleType === "adjacent" || ruleType === "sibling") { shouldTestNextSiblings = true; }
				}
				return compileRules(rules, options, context);
			})
			.reduce(reduceRules, falseFunc$1);

		query.shouldTestNextSiblings = shouldTestNextSiblings;

		return query;
	}

	function isTraversal(t){
		return procedure[t.type] < 0;
	}

	function compileRules(rules, options, context){
		return rules.reduce(function(func, rule){
			if(func === falseFunc$1) { return func; }
			return Rules[rule.type](func, rule, options, context);
		}, options && options.rootFunc || trueFunc);
	}

	function reduceRules(a, b){
		if(b === falseFunc$1 || a === trueFunc){
			return a;
		}
		if(a === falseFunc$1 || b === trueFunc){
			return b;
		}

		return function combine(elem){
			return a(elem) || b(elem);
		};
	}

	function containsTraversal(t){
		return t.some(isTraversal);
	}

	
	
	
	filters.not = function(next, token, options, context){
		var opts = {
			xmlMode: !!(options && options.xmlMode),
			strict: !!(options && options.strict)
		};

		if(opts.strict){
			if(token.length > 1 || token.some(containsTraversal)){
				throw new Error("complex selectors in :not aren't allowed in strict mode");
			}
		}

		var func = compileToken(token, opts, context);

		if(func === falseFunc$1) { return next; }
		if(func === trueFunc)  { return falseFunc$1; }

		return function(elem){
			return !func(elem) && next(elem);
		};
	};

	filters.has = function(next, token, options){
		var opts = {
			xmlMode: !!(options && options.xmlMode),
			strict: !!(options && options.strict)
		};

		
		var context = token.some(containsTraversal) ? [PLACEHOLDER_ELEMENT] : null;

		var func = compileToken(token, opts, context);

		if(func === falseFunc$1) { return falseFunc$1; }
		if(func === trueFunc){
			return function(elem){
				return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
			};
		}

		func = wrap(func);

		if(context){
			return function has(elem){
				return next(elem) && (
					(context[0] = elem), adapter.existsOne(func, adapter.getChildren(elem))
				);
			};
		}

		return function has(elem){
			return next(elem) && adapter.existsOne(func, adapter.getChildren(elem));
		};
	};

	filters.matches = function(next, token, options, context){
		var opts = {
			xmlMode: !!(options && options.xmlMode),
			strict: !!(options && options.strict),
			rootFunc: next
		};

		return compileToken(token, opts, context);
	};

	compile$$1.compileToken = compileToken;
	compile$$1.compileUnsafe = compileUnsafe;
	compile$$1.Pseudos = Pseudos;

	return compile$$1;
}

var index$1 = CSSselect$1;

var DomUtils       = index$2;
var falseFunc      = index$3.falseFunc;
var compileFactory = compile$$1;
var defaultCompile = compileFactory(DomUtils);

function adapterCompile(adapter){
	return adapter === DomUtils ? defaultCompile : compileFactory(adapter);
}

function getSelectorFunc(searchFunc){
	return function select(query, elems, options){
		options = options || {};
		options.adapter = options.adapter || DomUtils;
		var compile$$1 = adapterCompile(options.adapter);

		if(typeof query !== "function") { query = compile$$1.compileUnsafe(query, options, elems); }
		if(query.shouldTestNextSiblings) { elems = appendNextSiblings((options && options.context) || elems, options.adapter); }
		if(!Array.isArray(elems)) { elems = options.adapter.getChildren(elems); }
		else { elems = options.adapter.removeSubsets(elems); }
		return searchFunc(query, elems, options);
	};
}

function getNextSiblings(elem, adapter){
	var siblings = adapter.getSiblings(elem);
	if(!Array.isArray(siblings)) { return []; }
	siblings = siblings.slice(0);
	while(siblings.shift() !== elem){  }
	return siblings;
}

function appendNextSiblings(elems, adapter){
	
	if(!Array.isArray(elems)) { elems = [elems]; }
	var newElems = elems.slice(0);

	for(var i = 0, len = elems.length; i < len; i++){
		var nextSiblings = getNextSiblings(newElems[i], adapter);
		newElems.push.apply(newElems, nextSiblings);
	}
	return newElems;
}

var selectAll = getSelectorFunc(function selectAll(query, elems, options){
	return (query === falseFunc || !elems || elems.length === 0) ? [] : options.adapter.findAll(query, elems);
});

var selectOne = getSelectorFunc(function selectOne(query, elems, options){
	return (query === falseFunc || !elems || elems.length === 0) ? null : options.adapter.findOne(query, elems);
});

function is(elem, query, options){
	options = options || {};
	options.adapter = options.adapter || DomUtils;
	var compile$$1 = adapterCompile(options.adapter);
	return (typeof query === "function" ? query : compile$$1(query, options))(elem);
}


function CSSselect$1(query, elems, options){
	return selectAll(query, elems, options);
}

CSSselect$1.compile = defaultCompile;
CSSselect$1.filters = defaultCompile.Pseudos.filters;
CSSselect$1.pseudos = defaultCompile.Pseudos.pseudos;

CSSselect$1.selectAll = selectAll;
CSSselect$1.selectOne = selectOne;

CSSselect$1.is = is;


CSSselect$1.parse = defaultCompile;
CSSselect$1.iterate = selectAll;


CSSselect$1._compileUnsafe = defaultCompile.compileUnsafe;
CSSselect$1._compileToken = defaultCompile.compileToken;

var amp$1$1 = "&";
var apos$1$1 = "'";
var gt$1$1 = ">";
var lt$1$1 = "<";
var quot$1$1 = "\"";
var xmlJSON$1 = {
	amp: amp$1$1,
	apos: apos$1$1,
	gt: gt$1$1,
	lt: lt$1$1,
	quot: quot$1$1
};

var xml$1 = Object.freeze({
	amp: amp$1$1,
	apos: apos$1$1,
	gt: gt$1$1,
	lt: lt$1$1,
	quot: quot$1$1,
	default: xmlJSON$1
});

var Aacute$1$1 = "";
var aacute$1$1 = "";
var Abreve$1 = "";
var abreve$1 = "";
var ac$1 = "";
var acd$1 = "";
var acE$1 = "";
var Acirc$1$1 = "";
var acirc$1$1 = "";
var acute$1$1 = "";
var Acy$1 = "";
var acy$1 = "";
var AElig$1$1 = "";
var aelig$1$1 = "";
var af$1 = "";
var Afr$1 = "";
var afr$1 = "";
var Agrave$1$1 = "";
var agrave$1$1 = "";
var alefsym$1 = "";
var aleph$1 = "";
var Alpha$1 = "";
var alpha$1 = "";
var Amacr$1 = "";
var amacr$1 = "";
var amalg$1 = "";
var amp$1$2 = "&";
var AMP$1$1 = "&";
var andand$1 = "";
var And$1 = "";
var and$1 = "";
var andd$1 = "";
var andslope$1 = "";
var andv$1 = "";
var ang$1 = "";
var ange$1 = "";
var angle$1 = "";
var angmsdaa$1 = "";
var angmsdab$1 = "";
var angmsdac$1 = "";
var angmsdad$1 = "";
var angmsdae$1 = "";
var angmsdaf$1 = "";
var angmsdag$1 = "";
var angmsdah$1 = "";
var angmsd$1 = "";
var angrt$1 = "";
var angrtvb$1 = "";
var angrtvbd$1 = "";
var angsph$1 = "";
var angst$1 = "";
var angzarr$1 = "";
var Aogon$1 = "";
var aogon$1 = "";
var Aopf$1 = "";
var aopf$1 = "";
var apacir$1 = "";
var ap$1 = "";
var apE$1 = "";
var ape$1 = "";
var apid$1 = "";
var apos$1$2 = "'";
var ApplyFunction$1 = "";
var approx$1 = "";
var approxeq$1 = "";
var Aring$1$1 = "";
var aring$1$1 = "";
var Ascr$1 = "";
var ascr$1 = "";
var Assign$1 = "";
var ast$1 = "*";
var asymp$1 = "";
var asympeq$1 = "";
var Atilde$1$1 = "";
var atilde$1$1 = "";
var Auml$1$1 = "";
var auml$1$1 = "";
var awconint$1 = "";
var awint$1 = "";
var backcong$1 = "";
var backepsilon$1 = "";
var backprime$1 = "";
var backsim$1 = "";
var backsimeq$1 = "";
var Backslash$1 = "";
var Barv$1 = "";
var barvee$1 = "";
var barwed$1 = "";
var Barwed$1 = "";
var barwedge$1 = "";
var bbrk$1 = "";
var bbrktbrk$1 = "";
var bcong$1 = "";
var Bcy$1 = "";
var bcy$1 = "";
var bdquo$1 = "";
var becaus$1 = "";
var because$1 = "";
var Because$1 = "";
var bemptyv$1 = "";
var bepsi$1 = "";
var bernou$1 = "";
var Bernoullis$1 = "";
var Beta$1 = "";
var beta$1 = "";
var beth$1 = "";
var between$1 = "";
var Bfr$1 = "";
var bfr$1 = "";
var bigcap$1 = "";
var bigcirc$1 = "";
var bigcup$1 = "";
var bigodot$1 = "";
var bigoplus$1 = "";
var bigotimes$1 = "";
var bigsqcup$1 = "";
var bigstar$1 = "";
var bigtriangledown$1 = "";
var bigtriangleup$1 = "";
var biguplus$1 = "";
var bigvee$1 = "";
var bigwedge$1 = "";
var bkarow$1 = "";
var blacklozenge$1 = "";
var blacksquare$1 = "";
var blacktriangle$1 = "";
var blacktriangledown$1 = "";
var blacktriangleleft$1 = "";
var blacktriangleright$1 = "";
var blank$1 = "";
var blk12$1 = "";
var blk14$1 = "";
var blk34$1 = "";
var block$1 = "";
var bne$1 = "=";
var bnequiv$1 = "";
var bNot$1 = "";
var bnot$1 = "";
var Bopf$1 = "";
var bopf$1 = "";
var bot$1 = "";
var bottom$1 = "";
var bowtie$1 = "";
var boxbox$1 = "";
var boxdl$1 = "";
var boxdL$1 = "";
var boxDl$1 = "";
var boxDL$1 = "";
var boxdr$1 = "";
var boxdR$1 = "";
var boxDr$1 = "";
var boxDR$1 = "";
var boxh$1 = "";
var boxH$1 = "";
var boxhd$1 = "";
var boxHd$1 = "";
var boxhD$1 = "";
var boxHD$1 = "";
var boxhu$1 = "";
var boxHu$1 = "";
var boxhU$1 = "";
var boxHU$1 = "";
var boxminus$1 = "";
var boxplus$1 = "";
var boxtimes$1 = "";
var boxul$1 = "";
var boxuL$1 = "";
var boxUl$1 = "";
var boxUL$1 = "";
var boxur$1 = "";
var boxuR$1 = "";
var boxUr$1 = "";
var boxUR$1 = "";
var boxv$1 = "";
var boxV$1 = "";
var boxvh$1 = "";
var boxvH$1 = "";
var boxVh$1 = "";
var boxVH$1 = "";
var boxvl$1 = "";
var boxvL$1 = "";
var boxVl$1 = "";
var boxVL$1 = "";
var boxvr$1 = "";
var boxvR$1 = "";
var boxVr$1 = "";
var boxVR$1 = "";
var bprime$1 = "";
var breve$1 = "";
var Breve$1 = "";
var brvbar$1$1 = "";
var bscr$1 = "";
var Bscr$1 = "";
var bsemi$1 = "";
var bsim$1 = "";
var bsime$1 = "";
var bsolb$1 = "";
var bsol$1 = "\\";
var bsolhsub$1 = "";
var bull$1 = "";
var bullet$1 = "";
var bump$1 = "";
var bumpE$1 = "";
var bumpe$1 = "";
var Bumpeq$1 = "";
var bumpeq$1 = "";
var Cacute$1 = "";
var cacute$1 = "";
var capand$1 = "";
var capbrcup$1 = "";
var capcap$1 = "";
var cap$1 = "";
var Cap$1 = "";
var capcup$1 = "";
var capdot$1 = "";
var CapitalDifferentialD$1 = "";
var caps$1 = "";
var caret$1 = "";
var caron$1 = "";
var Cayleys$1 = "";
var ccaps$1 = "";
var Ccaron$1 = "";
var ccaron$1 = "";
var Ccedil$1$1 = "";
var ccedil$1$1 = "";
var Ccirc$1 = "";
var ccirc$1 = "";
var Cconint$1 = "";
var ccups$1 = "";
var ccupssm$1 = "";
var Cdot$1 = "";
var cdot$1 = "";
var cedil$1$1 = "";
var Cedilla$1 = "";
var cemptyv$1 = "";
var cent$1$1 = "";
var centerdot$1 = "";
var CenterDot$1 = "";
var cfr$1 = "";
var Cfr$1 = "";
var CHcy$1 = "";
var chcy$1 = "";
var check$1 = "";
var checkmark$1 = "";
var Chi$1 = "";
var chi$1 = "";
var circ$1 = "";
var circeq$1 = "";
var circlearrowleft$1 = "";
var circlearrowright$1 = "";
var circledast$1 = "";
var circledcirc$1 = "";
var circleddash$1 = "";
var CircleDot$1 = "";
var circledR$1 = "";
var circledS$1 = "";
var CircleMinus$1 = "";
var CirclePlus$1 = "";
var CircleTimes$1 = "";
var cir$1 = "";
var cirE$1 = "";
var cire$1 = "";
var cirfnint$1 = "";
var cirmid$1 = "";
var cirscir$1 = "";
var ClockwiseContourIntegral$1 = "";
var CloseCurlyDoubleQuote$1 = "";
var CloseCurlyQuote$1 = "";
var clubs$1 = "";
var clubsuit$1 = "";
var colon$1 = ":";
var Colon$1 = "";
var Colone$1 = "";
var colone$1 = "";
var coloneq$1 = "";
var comma$1 = ",";
var commat$1 = "@";
var comp$1 = "";
var compfn$1 = "";
var complement$1 = "";
var complexes$1 = "";
var cong$1 = "";
var congdot$1 = "";
var Congruent$1 = "";
var conint$1 = "";
var Conint$1 = "";
var ContourIntegral$1 = "";
var copf$1 = "";
var Copf$1 = "";
var coprod$1 = "";
var Coproduct$1 = "";
var copy$1$1 = "";
var COPY$1$1 = "";
var copysr$1 = "";
var CounterClockwiseContourIntegral$1 = "";
var crarr$1 = "";
var cross$1 = "";
var Cross$1 = "";
var Cscr$1 = "";
var cscr$1 = "";
var csub$1 = "";
var csube$1 = "";
var csup$1 = "";
var csupe$1 = "";
var ctdot$1 = "";
var cudarrl$1 = "";
var cudarrr$1 = "";
var cuepr$1 = "";
var cuesc$1 = "";
var cularr$1 = "";
var cularrp$1 = "";
var cupbrcap$1 = "";
var cupcap$1 = "";
var CupCap$1 = "";
var cup$1 = "";
var Cup$1 = "";
var cupcup$1 = "";
var cupdot$1 = "";
var cupor$1 = "";
var cups$1 = "";
var curarr$1 = "";
var curarrm$1 = "";
var curlyeqprec$1 = "";
var curlyeqsucc$1 = "";
var curlyvee$1 = "";
var curlywedge$1 = "";
var curren$1$1 = "";
var curvearrowleft$1 = "";
var curvearrowright$1 = "";
var cuvee$1 = "";
var cuwed$1 = "";
var cwconint$1 = "";
var cwint$1 = "";
var cylcty$1 = "";
var dagger$1 = "";
var Dagger$1 = "";
var daleth$1 = "";
var darr$1 = "";
var Darr$1 = "";
var dArr$1 = "";
var dash$1 = "";
var Dashv$1 = "";
var dashv$1 = "";
var dbkarow$1 = "";
var dblac$1 = "";
var Dcaron$1 = "";
var dcaron$1 = "";
var Dcy$1 = "";
var dcy$1 = "";
var ddagger$1 = "";
var ddarr$1 = "";
var DD$1 = "";
var dd$1 = "";
var DDotrahd$1 = "";
var ddotseq$1 = "";
var deg$1$1 = "";
var Del$1 = "";
var Delta$1 = "";
var delta$1 = "";
var demptyv$1 = "";
var dfisht$1 = "";
var Dfr$1 = "";
var dfr$1 = "";
var dHar$1 = "";
var dharl$1 = "";
var dharr$1 = "";
var DiacriticalAcute$1 = "";
var DiacriticalDot$1 = "";
var DiacriticalDoubleAcute$1 = "";
var DiacriticalGrave$1 = "`";
var DiacriticalTilde$1 = "";
var diam$1 = "";
var diamond$1 = "";
var Diamond$1 = "";
var diamondsuit$1 = "";
var diams$1 = "";
var die$1 = "";
var DifferentialD$1 = "";
var digamma$1 = "";
var disin$1 = "";
var div$1 = "";
var divide$1$1 = "";
var divideontimes$1 = "";
var divonx$1 = "";
var DJcy$1 = "";
var djcy$1 = "";
var dlcorn$1 = "";
var dlcrop$1 = "";
var dollar$1 = "$";
var Dopf$1 = "";
var dopf$1 = "";
var Dot$1 = "";
var dot$1 = "";
var DotDot$1 = "";
var doteq$1 = "";
var doteqdot$1 = "";
var DotEqual$1 = "";
var dotminus$1 = "";
var dotplus$1 = "";
var dotsquare$1 = "";
var doublebarwedge$1 = "";
var DoubleContourIntegral$1 = "";
var DoubleDot$1 = "";
var DoubleDownArrow$1 = "";
var DoubleLeftArrow$1 = "";
var DoubleLeftRightArrow$1 = "";
var DoubleLeftTee$1 = "";
var DoubleLongLeftArrow$1 = "";
var DoubleLongLeftRightArrow$1 = "";
var DoubleLongRightArrow$1 = "";
var DoubleRightArrow$1 = "";
var DoubleRightTee$1 = "";
var DoubleUpArrow$1 = "";
var DoubleUpDownArrow$1 = "";
var DoubleVerticalBar$1 = "";
var DownArrowBar$1 = "";
var downarrow$1 = "";
var DownArrow$1 = "";
var Downarrow$1 = "";
var DownArrowUpArrow$1 = "";
var DownBreve$1 = "";
var downdownarrows$1 = "";
var downharpoonleft$1 = "";
var downharpoonright$1 = "";
var DownLeftRightVector$1 = "";
var DownLeftTeeVector$1 = "";
var DownLeftVectorBar$1 = "";
var DownLeftVector$1 = "";
var DownRightTeeVector$1 = "";
var DownRightVectorBar$1 = "";
var DownRightVector$1 = "";
var DownTeeArrow$1 = "";
var DownTee$1 = "";
var drbkarow$1 = "";
var drcorn$1 = "";
var drcrop$1 = "";
var Dscr$1 = "";
var dscr$1 = "";
var DScy$1 = "";
var dscy$1 = "";
var dsol$1 = "";
var Dstrok$1 = "";
var dstrok$1 = "";
var dtdot$1 = "";
var dtri$1 = "";
var dtrif$1 = "";
var duarr$1 = "";
var duhar$1 = "";
var dwangle$1 = "";
var DZcy$1 = "";
var dzcy$1 = "";
var dzigrarr$1 = "";
var Eacute$1$1 = "";
var eacute$1$1 = "";
var easter$1 = "";
var Ecaron$1 = "";
var ecaron$1 = "";
var Ecirc$1$1 = "";
var ecirc$1$1 = "";
var ecir$1 = "";
var ecolon$1 = "";
var Ecy$1 = "";
var ecy$1 = "";
var eDDot$1 = "";
var Edot$1 = "";
var edot$1 = "";
var eDot$1 = "";
var ee$1 = "";
var efDot$1 = "";
var Efr$1 = "";
var efr$1 = "";
var eg$1 = "";
var Egrave$1$1 = "";
var egrave$1$1 = "";
var egs$1 = "";
var egsdot$1 = "";
var el$1 = "";
var Element$1 = "";
var elinters$1 = "";
var ell$1 = "";
var els$1 = "";
var elsdot$1 = "";
var Emacr$1 = "";
var emacr$1 = "";
var empty$1 = "";
var emptyset$1 = "";
var EmptySmallSquare$1 = "";
var emptyv$1 = "";
var EmptyVerySmallSquare$1 = "";
var emsp13$1 = "";
var emsp14$1 = "";
var emsp$1 = "";
var ENG$1 = "";
var eng$1 = "";
var ensp$1 = "";
var Eogon$1 = "";
var eogon$1 = "";
var Eopf$1 = "";
var eopf$1 = "";
var epar$1 = "";
var eparsl$1 = "";
var eplus$1 = "";
var epsi$1 = "";
var Epsilon$1 = "";
var epsilon$1 = "";
var epsiv$1 = "";
var eqcirc$1 = "";
var eqcolon$1 = "";
var eqsim$1 = "";
var eqslantgtr$1 = "";
var eqslantless$1 = "";
var Equal$1 = "";
var equals$1 = "=";
var EqualTilde$1 = "";
var equest$1 = "";
var Equilibrium$1 = "";
var equiv$1 = "";
var equivDD$1 = "";
var eqvparsl$1 = "";
var erarr$1 = "";
var erDot$1 = "";
var escr$1 = "";
var Escr$1 = "";
var esdot$1 = "";
var Esim$1 = "";
var esim$1 = "";
var Eta$1 = "";
var eta$1 = "";
var ETH$1$1 = "";
var eth$1$1 = "";
var Euml$1$1 = "";
var euml$1$1 = "";
var euro$1 = "";
var excl$1 = "!";
var exist$1 = "";
var Exists$1 = "";
var expectation$1 = "";
var exponentiale$1 = "";
var ExponentialE$1 = "";
var fallingdotseq$1 = "";
var Fcy$1 = "";
var fcy$1 = "";
var female$1 = "";
var ffilig$1 = "";
var fflig$1 = "";
var ffllig$1 = "";
var Ffr$1 = "";
var ffr$1 = "";
var filig$1 = "";
var FilledSmallSquare$1 = "";
var FilledVerySmallSquare$1 = "";
var fjlig$1 = "fj";
var flat$1 = "";
var fllig$1 = "";
var fltns$1 = "";
var fnof$1 = "";
var Fopf$1 = "";
var fopf$1 = "";
var forall$1 = "";
var ForAll$1 = "";
var fork$1 = "";
var forkv$1 = "";
var Fouriertrf$1 = "";
var fpartint$1 = "";
var frac12$1$1 = "";
var frac13$1 = "";
var frac14$1$1 = "";
var frac15$1 = "";
var frac16$1 = "";
var frac18$1 = "";
var frac23$1 = "";
var frac25$1 = "";
var frac34$1$1 = "";
var frac35$1 = "";
var frac38$1 = "";
var frac45$1 = "";
var frac56$1 = "";
var frac58$1 = "";
var frac78$1 = "";
var frasl$1 = "";
var frown$1 = "";
var fscr$1 = "";
var Fscr$1 = "";
var gacute$1 = "";
var Gamma$1 = "";
var gamma$1 = "";
var Gammad$1 = "";
var gammad$1 = "";
var gap$1 = "";
var Gbreve$1 = "";
var gbreve$1 = "";
var Gcedil$1 = "";
var Gcirc$1 = "";
var gcirc$1 = "";
var Gcy$1 = "";
var gcy$1 = "";
var Gdot$1 = "";
var gdot$1 = "";
var ge$1 = "";
var gE$1 = "";
var gEl$1 = "";
var gel$1 = "";
var geq$1 = "";
var geqq$1 = "";
var geqslant$1 = "";
var gescc$1 = "";
var ges$1 = "";
var gesdot$1 = "";
var gesdoto$1 = "";
var gesdotol$1 = "";
var gesl$1 = "";
var gesles$1 = "";
var Gfr$1 = "";
var gfr$1 = "";
var gg$1 = "";
var Gg$1 = "";
var ggg$1 = "";
var gimel$1 = "";
var GJcy$1 = "";
var gjcy$1 = "";
var gla$1 = "";
var gl$1 = "";
var glE$1 = "";
var glj$1 = "";
var gnap$1 = "";
var gnapprox$1 = "";
var gne$1 = "";
var gnE$1 = "";
var gneq$1 = "";
var gneqq$1 = "";
var gnsim$1 = "";
var Gopf$1 = "";
var gopf$1 = "";
var grave$1 = "`";
var GreaterEqual$1 = "";
var GreaterEqualLess$1 = "";
var GreaterFullEqual$1 = "";
var GreaterGreater$1 = "";
var GreaterLess$1 = "";
var GreaterSlantEqual$1 = "";
var GreaterTilde$1 = "";
var Gscr$1 = "";
var gscr$1 = "";
var gsim$1 = "";
var gsime$1 = "";
var gsiml$1 = "";
var gtcc$1 = "";
var gtcir$1 = "";
var gt$1$2 = ">";
var GT$1$1 = ">";
var Gt$1 = "";
var gtdot$1 = "";
var gtlPar$1 = "";
var gtquest$1 = "";
var gtrapprox$1 = "";
var gtrarr$1 = "";
var gtrdot$1 = "";
var gtreqless$1 = "";
var gtreqqless$1 = "";
var gtrless$1 = "";
var gtrsim$1 = "";
var gvertneqq$1 = "";
var gvnE$1 = "";
var Hacek$1 = "";
var hairsp$1 = "";
var half$1 = "";
var hamilt$1 = "";
var HARDcy$1 = "";
var hardcy$1 = "";
var harrcir$1 = "";
var harr$1 = "";
var hArr$1 = "";
var harrw$1 = "";
var Hat$1 = "^";
var hbar$1 = "";
var Hcirc$1 = "";
var hcirc$1 = "";
var hearts$1 = "";
var heartsuit$1 = "";
var hellip$1 = "";
var hercon$1 = "";
var hfr$1 = "";
var Hfr$1 = "";
var HilbertSpace$1 = "";
var hksearow$1 = "";
var hkswarow$1 = "";
var hoarr$1 = "";
var homtht$1 = "";
var hookleftarrow$1 = "";
var hookrightarrow$1 = "";
var hopf$1 = "";
var Hopf$1 = "";
var horbar$1 = "";
var HorizontalLine$1 = "";
var hscr$1 = "";
var Hscr$1 = "";
var hslash$1 = "";
var Hstrok$1 = "";
var hstrok$1 = "";
var HumpDownHump$1 = "";
var HumpEqual$1 = "";
var hybull$1 = "";
var hyphen$1 = "";
var Iacute$1$1 = "";
var iacute$1$1 = "";
var ic$1 = "";
var Icirc$1$1 = "";
var icirc$1$1 = "";
var Icy$1 = "";
var icy$1 = "";
var Idot$1 = "";
var IEcy$1 = "";
var iecy$1 = "";
var iexcl$1$1 = "";
var iff$1 = "";
var ifr$1 = "";
var Ifr$1 = "";
var Igrave$1$1 = "";
var igrave$1$1 = "";
var ii$1 = "";
var iiiint$1 = "";
var iiint$1 = "";
var iinfin$1 = "";
var iiota$1 = "";
var IJlig$1 = "";
var ijlig$1 = "";
var Imacr$1 = "";
var imacr$1 = "";
var image$1 = "";
var ImaginaryI$1 = "";
var imagline$1 = "";
var imagpart$1 = "";
var imath$1 = "";
var Im$1 = "";
var imof$1 = "";
var imped$1 = "";
var Implies$1 = "";
var incare$1 = "";
var infin$1 = "";
var infintie$1 = "";
var inodot$1 = "";
var intcal$1 = "";
var int$1 = "";
var Int$1 = "";
var integers$1 = "";
var Integral$1 = "";
var intercal$1 = "";
var Intersection$1 = "";
var intlarhk$1 = "";
var intprod$1 = "";
var InvisibleComma$1 = "";
var InvisibleTimes$1 = "";
var IOcy$1 = "";
var iocy$1 = "";
var Iogon$1 = "";
var iogon$1 = "";
var Iopf$1 = "";
var iopf$1 = "";
var Iota$1 = "";
var iota$1 = "";
var iprod$1 = "";
var iquest$1$1 = "";
var iscr$1 = "";
var Iscr$1 = "";
var isin$1 = "";
var isindot$1 = "";
var isinE$1 = "";
var isins$1 = "";
var isinsv$1 = "";
var isinv$1 = "";
var it$1 = "";
var Itilde$1 = "";
var itilde$1 = "";
var Iukcy$1 = "";
var iukcy$1 = "";
var Iuml$1$1 = "";
var iuml$1$1 = "";
var Jcirc$1 = "";
var jcirc$1 = "";
var Jcy$1 = "";
var jcy$1 = "";
var Jfr$1 = "";
var jfr$1 = "";
var jmath$1 = "";
var Jopf$1 = "";
var jopf$1 = "";
var Jscr$1 = "";
var jscr$1 = "";
var Jsercy$1 = "";
var jsercy$1 = "";
var Jukcy$1 = "";
var jukcy$1 = "";
var Kappa$1 = "";
var kappa$1 = "";
var kappav$1 = "";
var Kcedil$1 = "";
var kcedil$1 = "";
var Kcy$1 = "";
var kcy$1 = "";
var Kfr$1 = "";
var kfr$1 = "";
var kgreen$1 = "";
var KHcy$1 = "";
var khcy$1 = "";
var KJcy$1 = "";
var kjcy$1 = "";
var Kopf$1 = "";
var kopf$1 = "";
var Kscr$1 = "";
var kscr$1 = "";
var lAarr$1 = "";
var Lacute$1 = "";
var lacute$1 = "";
var laemptyv$1 = "";
var lagran$1 = "";
var Lambda$1 = "";
var lambda$1 = "";
var lang$1 = "";
var Lang$1 = "";
var langd$1 = "";
var langle$1 = "";
var lap$1 = "";
var Laplacetrf$1 = "";
var laquo$1$1 = "";
var larrb$1 = "";
var larrbfs$1 = "";
var larr$1 = "";
var Larr$1 = "";
var lArr$1 = "";
var larrfs$1 = "";
var larrhk$1 = "";
var larrlp$1 = "";
var larrpl$1 = "";
var larrsim$1 = "";
var larrtl$1 = "";
var latail$1 = "";
var lAtail$1 = "";
var lat$1 = "";
var late$1 = "";
var lates$1 = "";
var lbarr$1 = "";
var lBarr$1 = "";
var lbbrk$1 = "";
var lbrace$1 = "{";
var lbrack$1 = "[";
var lbrke$1 = "";
var lbrksld$1 = "";
var lbrkslu$1 = "";
var Lcaron$1 = "";
var lcaron$1 = "";
var Lcedil$1 = "";
var lcedil$1 = "";
var lceil$1 = "";
var lcub$1 = "{";
var Lcy$1 = "";
var lcy$1 = "";
var ldca$1 = "";
var ldquo$1 = "";
var ldquor$1 = "";
var ldrdhar$1 = "";
var ldrushar$1 = "";
var ldsh$1 = "";
var le$1 = "";
var lE$1 = "";
var LeftAngleBracket$1 = "";
var LeftArrowBar$1 = "";
var leftarrow$1 = "";
var LeftArrow$1 = "";
var Leftarrow$1 = "";
var LeftArrowRightArrow$1 = "";
var leftarrowtail$1 = "";
var LeftCeiling$1 = "";
var LeftDoubleBracket$1 = "";
var LeftDownTeeVector$1 = "";
var LeftDownVectorBar$1 = "";
var LeftDownVector$1 = "";
var LeftFloor$1 = "";
var leftharpoondown$1 = "";
var leftharpoonup$1 = "";
var leftleftarrows$1 = "";
var leftrightarrow$1 = "";
var LeftRightArrow$1 = "";
var Leftrightarrow$1 = "";
var leftrightarrows$1 = "";
var leftrightharpoons$1 = "";
var leftrightsquigarrow$1 = "";
var LeftRightVector$1 = "";
var LeftTeeArrow$1 = "";
var LeftTee$1 = "";
var LeftTeeVector$1 = "";
var leftthreetimes$1 = "";
var LeftTriangleBar$1 = "";
var LeftTriangle$1 = "";
var LeftTriangleEqual$1 = "";
var LeftUpDownVector$1 = "";
var LeftUpTeeVector$1 = "";
var LeftUpVectorBar$1 = "";
var LeftUpVector$1 = "";
var LeftVectorBar$1 = "";
var LeftVector$1 = "";
var lEg$1 = "";
var leg$1 = "";
var leq$1 = "";
var leqq$1 = "";
var leqslant$1 = "";
var lescc$1 = "";
var les$1 = "";
var lesdot$1 = "";
var lesdoto$1 = "";
var lesdotor$1 = "";
var lesg$1 = "";
var lesges$1 = "";
var lessapprox$1 = "";
var lessdot$1 = "";
var lesseqgtr$1 = "";
var lesseqqgtr$1 = "";
var LessEqualGreater$1 = "";
var LessFullEqual$1 = "";
var LessGreater$1 = "";
var lessgtr$1 = "";
var LessLess$1 = "";
var lesssim$1 = "";
var LessSlantEqual$1 = "";
var LessTilde$1 = "";
var lfisht$1 = "";
var lfloor$1 = "";
var Lfr$1 = "";
var lfr$1 = "";
var lg$1 = "";
var lgE$1 = "";
var lHar$1 = "";
var lhard$1 = "";
var lharu$1 = "";
var lharul$1 = "";
var lhblk$1 = "";
var LJcy$1 = "";
var ljcy$1 = "";
var llarr$1 = "";
var ll$1 = "";
var Ll$1 = "";
var llcorner$1 = "";
var Lleftarrow$1 = "";
var llhard$1 = "";
var lltri$1 = "";
var Lmidot$1 = "";
var lmidot$1 = "";
var lmoustache$1 = "";
var lmoust$1 = "";
var lnap$1 = "";
var lnapprox$1 = "";
var lne$1 = "";
var lnE$1 = "";
var lneq$1 = "";
var lneqq$1 = "";
var lnsim$1 = "";
var loang$1 = "";
var loarr$1 = "";
var lobrk$1 = "";
var longleftarrow$1 = "";
var LongLeftArrow$1 = "";
var Longleftarrow$1 = "";
var longleftrightarrow$1 = "";
var LongLeftRightArrow$1 = "";
var Longleftrightarrow$1 = "";
var longmapsto$1 = "";
var longrightarrow$1 = "";
var LongRightArrow$1 = "";
var Longrightarrow$1 = "";
var looparrowleft$1 = "";
var looparrowright$1 = "";
var lopar$1 = "";
var Lopf$1 = "";
var lopf$1 = "";
var loplus$1 = "";
var lotimes$1 = "";
var lowast$1 = "";
var lowbar$1 = "_";
var LowerLeftArrow$1 = "";
var LowerRightArrow$1 = "";
var loz$1 = "";
var lozenge$1 = "";
var lozf$1 = "";
var lpar$1 = "(";
var lparlt$1 = "";
var lrarr$1 = "";
var lrcorner$1 = "";
var lrhar$1 = "";
var lrhard$1 = "";
var lrm$1 = "";
var lrtri$1 = "";
var lsaquo$1 = "";
var lscr$1 = "";
var Lscr$1 = "";
var lsh$1 = "";
var Lsh$1 = "";
var lsim$1 = "";
var lsime$1 = "";
var lsimg$1 = "";
var lsqb$1 = "[";
var lsquo$1 = "";
var lsquor$1 = "";
var Lstrok$1 = "";
var lstrok$1 = "";
var ltcc$1 = "";
var ltcir$1 = "";
var lt$1$2 = "<";
var LT$1$1 = "<";
var Lt$1 = "";
var ltdot$1 = "";
var lthree$1 = "";
var ltimes$1 = "";
var ltlarr$1 = "";
var ltquest$1 = "";
var ltri$1 = "";
var ltrie$1 = "";
var ltrif$1 = "";
var ltrPar$1 = "";
var lurdshar$1 = "";
var luruhar$1 = "";
var lvertneqq$1 = "";
var lvnE$1 = "";
var macr$1$1 = "";
var male$1 = "";
var malt$1 = "";
var maltese$1 = "";
var map$2 = "";
var mapsto$1 = "";
var mapstodown$1 = "";
var mapstoleft$1 = "";
var mapstoup$1 = "";
var marker$1 = "";
var mcomma$1 = "";
var Mcy$1 = "";
var mcy$1 = "";
var mdash$1 = "";
var mDDot$1 = "";
var measuredangle$1 = "";
var MediumSpace$1 = "";
var Mellintrf$1 = "";
var Mfr$1 = "";
var mfr$1 = "";
var mho$1 = "";
var micro$1$1 = "";
var midast$1 = "*";
var midcir$1 = "";
var mid$1 = "";
var middot$1$1 = "";
var minusb$1 = "";
var minus$1 = "";
var minusd$1 = "";
var minusdu$1 = "";
var MinusPlus$1 = "";
var mlcp$1 = "";
var mldr$1 = "";
var mnplus$1 = "";
var models$1 = "";
var Mopf$1 = "";
var mopf$1 = "";
var mp$1 = "";
var mscr$1 = "";
var Mscr$1 = "";
var mstpos$1 = "";
var Mu$1 = "";
var mu$1 = "";
var multimap$1 = "";
var mumap$1 = "";
var nabla$1 = "";
var Nacute$1 = "";
var nacute$1 = "";
var nang$1 = "";
var nap$1 = "";
var napE$1 = "";
var napid$1 = "";
var napos$1 = "";
var napprox$1 = "";
var natural$1 = "";
var naturals$1 = "";
var natur$1 = "";
var nbsp$1$1 = "";
var nbump$1 = "";
var nbumpe$1 = "";
var ncap$1 = "";
var Ncaron$1 = "";
var ncaron$1 = "";
var Ncedil$1 = "";
var ncedil$1 = "";
var ncong$1 = "";
var ncongdot$1 = "";
var ncup$1 = "";
var Ncy$1 = "";
var ncy$1 = "";
var ndash$1 = "";
var nearhk$1 = "";
var nearr$1 = "";
var neArr$1 = "";
var nearrow$1 = "";
var ne$1 = "";
var nedot$1 = "";
var NegativeMediumSpace$1 = "";
var NegativeThickSpace$1 = "";
var NegativeThinSpace$1 = "";
var NegativeVeryThinSpace$1 = "";
var nequiv$1 = "";
var nesear$1 = "";
var nesim$1 = "";
var NestedGreaterGreater$1 = "";
var NestedLessLess$1 = "";
var NewLine$1 = "\n";
var nexist$1 = "";
var nexists$1 = "";
var Nfr$1 = "";
var nfr$1 = "";
var ngE$1 = "";
var nge$1 = "";
var ngeq$1 = "";
var ngeqq$1 = "";
var ngeqslant$1 = "";
var nges$1 = "";
var nGg$1 = "";
var ngsim$1 = "";
var nGt$1 = "";
var ngt$1 = "";
var ngtr$1 = "";
var nGtv$1 = "";
var nharr$1 = "";
var nhArr$1 = "";
var nhpar$1 = "";
var ni$1 = "";
var nis$1 = "";
var nisd$1 = "";
var niv$1 = "";
var NJcy$1 = "";
var njcy$1 = "";
var nlarr$1 = "";
var nlArr$1 = "";
var nldr$1 = "";
var nlE$1 = "";
var nle$1 = "";
var nleftarrow$1 = "";
var nLeftarrow$1 = "";
var nleftrightarrow$1 = "";
var nLeftrightarrow$1 = "";
var nleq$1 = "";
var nleqq$1 = "";
var nleqslant$1 = "";
var nles$1 = "";
var nless$1 = "";
var nLl$1 = "";
var nlsim$1 = "";
var nLt$1 = "";
var nlt$1 = "";
var nltri$1 = "";
var nltrie$1 = "";
var nLtv$1 = "";
var nmid$1 = "";
var NoBreak$1 = "";
var NonBreakingSpace$1 = "";
var nopf$1 = "";
var Nopf$1 = "";
var Not$1 = "";
var not$1$1 = "";
var NotCongruent$1 = "";
var NotCupCap$1 = "";
var NotDoubleVerticalBar$1 = "";
var NotElement$1 = "";
var NotEqual$1 = "";
var NotEqualTilde$1 = "";
var NotExists$1 = "";
var NotGreater$1 = "";
var NotGreaterEqual$1 = "";
var NotGreaterFullEqual$1 = "";
var NotGreaterGreater$1 = "";
var NotGreaterLess$1 = "";
var NotGreaterSlantEqual$1 = "";
var NotGreaterTilde$1 = "";
var NotHumpDownHump$1 = "";
var NotHumpEqual$1 = "";
var notin$1 = "";
var notindot$1 = "";
var notinE$1 = "";
var notinva$1 = "";
var notinvb$1 = "";
var notinvc$1 = "";
var NotLeftTriangleBar$1 = "";
var NotLeftTriangle$1 = "";
var NotLeftTriangleEqual$1 = "";
var NotLess$1 = "";
var NotLessEqual$1 = "";
var NotLessGreater$1 = "";
var NotLessLess$1 = "";
var NotLessSlantEqual$1 = "";
var NotLessTilde$1 = "";
var NotNestedGreaterGreater$1 = "";
var NotNestedLessLess$1 = "";
var notni$1 = "";
var notniva$1 = "";
var notnivb$1 = "";
var notnivc$1 = "";
var NotPrecedes$1 = "";
var NotPrecedesEqual$1 = "";
var NotPrecedesSlantEqual$1 = "";
var NotReverseElement$1 = "";
var NotRightTriangleBar$1 = "";
var NotRightTriangle$1 = "";
var NotRightTriangleEqual$1 = "";
var NotSquareSubset$1 = "";
var NotSquareSubsetEqual$1 = "";
var NotSquareSuperset$1 = "";
var NotSquareSupersetEqual$1 = "";
var NotSubset$1 = "";
var NotSubsetEqual$1 = "";
var NotSucceeds$1 = "";
var NotSucceedsEqual$1 = "";
var NotSucceedsSlantEqual$1 = "";
var NotSucceedsTilde$1 = "";
var NotSuperset$1 = "";
var NotSupersetEqual$1 = "";
var NotTilde$1 = "";
var NotTildeEqual$1 = "";
var NotTildeFullEqual$1 = "";
var NotTildeTilde$1 = "";
var NotVerticalBar$1 = "";
var nparallel$1 = "";
var npar$1 = "";
var nparsl$1 = "";
var npart$1 = "";
var npolint$1 = "";
var npr$1 = "";
var nprcue$1 = "";
var nprec$1 = "";
var npreceq$1 = "";
var npre$1 = "";
var nrarrc$1 = "";
var nrarr$1 = "";
var nrArr$1 = "";
var nrarrw$1 = "";
var nrightarrow$1 = "";
var nRightarrow$1 = "";
var nrtri$1 = "";
var nrtrie$1 = "";
var nsc$1 = "";
var nsccue$1 = "";
var nsce$1 = "";
var Nscr$1 = "";
var nscr$1 = "";
var nshortmid$1 = "";
var nshortparallel$1 = "";
var nsim$1 = "";
var nsime$1 = "";
var nsimeq$1 = "";
var nsmid$1 = "";
var nspar$1 = "";
var nsqsube$1 = "";
var nsqsupe$1 = "";
var nsub$1 = "";
var nsubE$1 = "";
var nsube$1 = "";
var nsubset$1 = "";
var nsubseteq$1 = "";
var nsubseteqq$1 = "";
var nsucc$1 = "";
var nsucceq$1 = "";
var nsup$1 = "";
var nsupE$1 = "";
var nsupe$1 = "";
var nsupset$1 = "";
var nsupseteq$1 = "";
var nsupseteqq$1 = "";
var ntgl$1 = "";
var Ntilde$1$1 = "";
var ntilde$1$1 = "";
var ntlg$1 = "";
var ntriangleleft$1 = "";
var ntrianglelefteq$1 = "";
var ntriangleright$1 = "";
var ntrianglerighteq$1 = "";
var Nu$1 = "";
var nu$1 = "";
var num$1 = "#";
var numero$1 = "";
var numsp$1 = "";
var nvap$1 = "";
var nvdash$1 = "";
var nvDash$1 = "";
var nVdash$1 = "";
var nVDash$1 = "";
var nvge$1 = "";
var nvgt$1 = ">";
var nvHarr$1 = "";
var nvinfin$1 = "";
var nvlArr$1 = "";
var nvle$1 = "";
var nvlt$1 = "<";
var nvltrie$1 = "";
var nvrArr$1 = "";
var nvrtrie$1 = "";
var nvsim$1 = "";
var nwarhk$1 = "";
var nwarr$1 = "";
var nwArr$1 = "";
var nwarrow$1 = "";
var nwnear$1 = "";
var Oacute$1$1 = "";
var oacute$1$1 = "";
var oast$1 = "";
var Ocirc$1$1 = "";
var ocirc$1$1 = "";
var ocir$1 = "";
var Ocy$1 = "";
var ocy$1 = "";
var odash$1 = "";
var Odblac$1 = "";
var odblac$1 = "";
var odiv$1 = "";
var odot$1 = "";
var odsold$1 = "";
var OElig$1 = "";
var oelig$1 = "";
var ofcir$1 = "";
var Ofr$1 = "";
var ofr$1 = "";
var ogon$1 = "";
var Ograve$1$1 = "";
var ograve$1$1 = "";
var ogt$1 = "";
var ohbar$1 = "";
var ohm$1 = "";
var oint$1 = "";
var olarr$1 = "";
var olcir$1 = "";
var olcross$1 = "";
var oline$1 = "";
var olt$1 = "";
var Omacr$1 = "";
var omacr$1 = "";
var Omega$1 = "";
var omega$1 = "";
var Omicron$1 = "";
var omicron$1 = "";
var omid$1 = "";
var ominus$1 = "";
var Oopf$1 = "";
var oopf$1 = "";
var opar$1 = "";
var OpenCurlyDoubleQuote$1 = "";
var OpenCurlyQuote$1 = "";
var operp$1 = "";
var oplus$1 = "";
var orarr$1 = "";
var Or$1 = "";
var or$1 = "";
var ord$1 = "";
var order$1 = "";
var orderof$1 = "";
var ordf$1$1 = "";
var ordm$1$1 = "";
var origof$1 = "";
var oror$1 = "";
var orslope$1 = "";
var orv$1 = "";
var oS$1 = "";
var Oscr$1 = "";
var oscr$1 = "";
var Oslash$1$1 = "";
var oslash$1$1 = "";
var osol$1 = "";
var Otilde$1$1 = "";
var otilde$1$1 = "";
var otimesas$1 = "";
var Otimes$1 = "";
var otimes$1 = "";
var Ouml$1$1 = "";
var ouml$1$1 = "";
var ovbar$1 = "";
var OverBar$1 = "";
var OverBrace$1 = "";
var OverBracket$1 = "";
var OverParenthesis$1 = "";
var para$1$1 = "";
var parallel$1 = "";
var par$1 = "";
var parsim$1 = "";
var parsl$1 = "";
var part$1 = "";
var PartialD$1 = "";
var Pcy$1 = "";
var pcy$1 = "";
var percnt$1 = "%";
var period$1 = ".";
var permil$1 = "";
var perp$1 = "";
var pertenk$1 = "";
var Pfr$1 = "";
var pfr$1 = "";
var Phi$1 = "";
var phi$1 = "";
var phiv$1 = "";
var phmmat$1 = "";
var phone$1 = "";
var Pi$1 = "";
var pi$1 = "";
var pitchfork$1 = "";
var piv$1 = "";
var planck$1 = "";
var planckh$1 = "";
var plankv$1 = "";
var plusacir$1 = "";
var plusb$1 = "";
var pluscir$1 = "";
var plus$1 = "+";
var plusdo$1 = "";
var plusdu$1 = "";
var pluse$1 = "";
var PlusMinus$1 = "";
var plusmn$1$1 = "";
var plussim$1 = "";
var plustwo$1 = "";
var pm$1 = "";
var Poincareplane$1 = "";
var pointint$1 = "";
var popf$1 = "";
var Popf$1 = "";
var pound$1$1 = "";
var prap$1 = "";
var Pr$1 = "";
var pr$1 = "";
var prcue$1 = "";
var precapprox$1 = "";
var prec$1 = "";
var preccurlyeq$1 = "";
var Precedes$1 = "";
var PrecedesEqual$1 = "";
var PrecedesSlantEqual$1 = "";
var PrecedesTilde$1 = "";
var preceq$1 = "";
var precnapprox$1 = "";
var precneqq$1 = "";
var precnsim$1 = "";
var pre$1 = "";
var prE$1 = "";
var precsim$1 = "";
var prime$1 = "";
var Prime$1 = "";
var primes$1 = "";
var prnap$1 = "";
var prnE$1 = "";
var prnsim$1 = "";
var prod$1 = "";
var Product$1 = "";
var profalar$1 = "";
var profline$1 = "";
var profsurf$1 = "";
var prop$1 = "";
var Proportional$1 = "";
var Proportion$1 = "";
var propto$1 = "";
var prsim$1 = "";
var prurel$1 = "";
var Pscr$1 = "";
var pscr$1 = "";
var Psi$1 = "";
var psi$1 = "";
var puncsp$1 = "";
var Qfr$1 = "";
var qfr$1 = "";
var qint$1 = "";
var qopf$1 = "";
var Qopf$1 = "";
var qprime$1 = "";
var Qscr$1 = "";
var qscr$1 = "";
var quaternions$1 = "";
var quatint$1 = "";
var quest$1 = "?";
var questeq$1 = "";
var quot$1$2 = "\"";
var QUOT$1$1 = "\"";
var rAarr$1 = "";
var race$1 = "";
var Racute$1 = "";
var racute$1 = "";
var radic$1 = "";
var raemptyv$1 = "";
var rang$1 = "";
var Rang$1 = "";
var rangd$1 = "";
var range$1 = "";
var rangle$1 = "";
var raquo$1$1 = "";
var rarrap$1 = "";
var rarrb$1 = "";
var rarrbfs$1 = "";
var rarrc$1 = "";
var rarr$1 = "";
var Rarr$1 = "";
var rArr$1 = "";
var rarrfs$1 = "";
var rarrhk$1 = "";
var rarrlp$1 = "";
var rarrpl$1 = "";
var rarrsim$1 = "";
var Rarrtl$1 = "";
var rarrtl$1 = "";
var rarrw$1 = "";
var ratail$1 = "";
var rAtail$1 = "";
var ratio$1 = "";
var rationals$1 = "";
var rbarr$1 = "";
var rBarr$1 = "";
var RBarr$1 = "";
var rbbrk$1 = "";
var rbrace$1 = "}";
var rbrack$1 = "]";
var rbrke$1 = "";
var rbrksld$1 = "";
var rbrkslu$1 = "";
var Rcaron$1 = "";
var rcaron$1 = "";
var Rcedil$1 = "";
var rcedil$1 = "";
var rceil$1 = "";
var rcub$1 = "}";
var Rcy$1 = "";
var rcy$1 = "";
var rdca$1 = "";
var rdldhar$1 = "";
var rdquo$1 = "";
var rdquor$1 = "";
var rdsh$1 = "";
var real$1 = "";
var realine$1 = "";
var realpart$1 = "";
var reals$1 = "";
var Re$1 = "";
var rect$1 = "";
var reg$1$1 = "";
var REG$1$1 = "";
var ReverseElement$1 = "";
var ReverseEquilibrium$1 = "";
var ReverseUpEquilibrium$1 = "";
var rfisht$1 = "";
var rfloor$1 = "";
var rfr$1 = "";
var Rfr$1 = "";
var rHar$1 = "";
var rhard$1 = "";
var rharu$1 = "";
var rharul$1 = "";
var Rho$1 = "";
var rho$1 = "";
var rhov$1 = "";
var RightAngleBracket$1 = "";
var RightArrowBar$1 = "";
var rightarrow$1 = "";
var RightArrow$1 = "";
var Rightarrow$1 = "";
var RightArrowLeftArrow$1 = "";
var rightarrowtail$1 = "";
var RightCeiling$1 = "";
var RightDoubleBracket$1 = "";
var RightDownTeeVector$1 = "";
var RightDownVectorBar$1 = "";
var RightDownVector$1 = "";
var RightFloor$1 = "";
var rightharpoondown$1 = "";
var rightharpoonup$1 = "";
var rightleftarrows$1 = "";
var rightleftharpoons$1 = "";
var rightrightarrows$1 = "";
var rightsquigarrow$1 = "";
var RightTeeArrow$1 = "";
var RightTee$1 = "";
var RightTeeVector$1 = "";
var rightthreetimes$1 = "";
var RightTriangleBar$1 = "";
var RightTriangle$1 = "";
var RightTriangleEqual$1 = "";
var RightUpDownVector$1 = "";
var RightUpTeeVector$1 = "";
var RightUpVectorBar$1 = "";
var RightUpVector$1 = "";
var RightVectorBar$1 = "";
var RightVector$1 = "";
var ring$1 = "";
var risingdotseq$1 = "";
var rlarr$1 = "";
var rlhar$1 = "";
var rlm$1 = "";
var rmoustache$1 = "";
var rmoust$1 = "";
var rnmid$1 = "";
var roang$1 = "";
var roarr$1 = "";
var robrk$1 = "";
var ropar$1 = "";
var ropf$1 = "";
var Ropf$1 = "";
var roplus$1 = "";
var rotimes$1 = "";
var RoundImplies$1 = "";
var rpar$1 = ")";
var rpargt$1 = "";
var rppolint$1 = "";
var rrarr$1 = "";
var Rrightarrow$1 = "";
var rsaquo$1 = "";
var rscr$1 = "";
var Rscr$1 = "";
var rsh$1 = "";
var Rsh$1 = "";
var rsqb$1 = "]";
var rsquo$1 = "";
var rsquor$1 = "";
var rthree$1 = "";
var rtimes$1 = "";
var rtri$1 = "";
var rtrie$1 = "";
var rtrif$1 = "";
var rtriltri$1 = "";
var RuleDelayed$1 = "";
var ruluhar$1 = "";
var rx$1 = "";
var Sacute$1 = "";
var sacute$1 = "";
var sbquo$1 = "";
var scap$1 = "";
var Scaron$1 = "";
var scaron$1 = "";
var Sc$1 = "";
var sc$1 = "";
var sccue$1 = "";
var sce$1 = "";
var scE$1 = "";
var Scedil$1 = "";
var scedil$1 = "";
var Scirc$1 = "";
var scirc$1 = "";
var scnap$1 = "";
var scnE$1 = "";
var scnsim$1 = "";
var scpolint$1 = "";
var scsim$1 = "";
var Scy$1 = "";
var scy$1 = "";
var sdotb$1 = "";
var sdot$1 = "";
var sdote$1 = "";
var searhk$1 = "";
var searr$1 = "";
var seArr$1 = "";
var searrow$1 = "";
var sect$1$1 = "";
var semi$1 = ";";
var seswar$1 = "";
var setminus$1 = "";
var setmn$1 = "";
var sext$1 = "";
var Sfr$1 = "";
var sfr$1 = "";
var sfrown$1 = "";
var sharp$1 = "";
var SHCHcy$1 = "";
var shchcy$1 = "";
var SHcy$1 = "";
var shcy$1 = "";
var ShortDownArrow$1 = "";
var ShortLeftArrow$1 = "";
var shortmid$1 = "";
var shortparallel$1 = "";
var ShortRightArrow$1 = "";
var ShortUpArrow$1 = "";
var shy$1$1 = "";
var Sigma$1 = "";
var sigma$1 = "";
var sigmaf$1 = "";
var sigmav$1 = "";
var sim$1 = "";
var simdot$1 = "";
var sime$1 = "";
var simeq$1 = "";
var simg$1 = "";
var simgE$1 = "";
var siml$1 = "";
var simlE$1 = "";
var simne$1 = "";
var simplus$1 = "";
var simrarr$1 = "";
var slarr$1 = "";
var SmallCircle$1 = "";
var smallsetminus$1 = "";
var smashp$1 = "";
var smeparsl$1 = "";
var smid$1 = "";
var smile$1 = "";
var smt$1 = "";
var smte$1 = "";
var smtes$1 = "";
var SOFTcy$1 = "";
var softcy$1 = "";
var solbar$1 = "";
var solb$1 = "";
var sol$1 = "/";
var Sopf$1 = "";
var sopf$1 = "";
var spades$1 = "";
var spadesuit$1 = "";
var spar$1 = "";
var sqcap$1 = "";
var sqcaps$1 = "";
var sqcup$1 = "";
var sqcups$1 = "";
var Sqrt$1 = "";
var sqsub$1 = "";
var sqsube$1 = "";
var sqsubset$1 = "";
var sqsubseteq$1 = "";
var sqsup$1 = "";
var sqsupe$1 = "";
var sqsupset$1 = "";
var sqsupseteq$1 = "";
var square$1 = "";
var Square$1 = "";
var SquareIntersection$1 = "";
var SquareSubset$1 = "";
var SquareSubsetEqual$1 = "";
var SquareSuperset$1 = "";
var SquareSupersetEqual$1 = "";
var SquareUnion$1 = "";
var squarf$1 = "";
var squ$1 = "";
var squf$1 = "";
var srarr$1 = "";
var Sscr$1 = "";
var sscr$1 = "";
var ssetmn$1 = "";
var ssmile$1 = "";
var sstarf$1 = "";
var Star$1 = "";
var star$1 = "";
var starf$1 = "";
var straightepsilon$1 = "";
var straightphi$1 = "";
var strns$1 = "";
var sub$1 = "";
var Sub$1 = "";
var subdot$1 = "";
var subE$1 = "";
var sube$1 = "";
var subedot$1 = "";
var submult$1 = "";
var subnE$1 = "";
var subne$1 = "";
var subplus$1 = "";
var subrarr$1 = "";
var subset$1 = "";
var Subset$1 = "";
var subseteq$1 = "";
var subseteqq$1 = "";
var SubsetEqual$1 = "";
var subsetneq$1 = "";
var subsetneqq$1 = "";
var subsim$1 = "";
var subsub$1 = "";
var subsup$1 = "";
var succapprox$1 = "";
var succ$1 = "";
var succcurlyeq$1 = "";
var Succeeds$1 = "";
var SucceedsEqual$1 = "";
var SucceedsSlantEqual$1 = "";
var SucceedsTilde$1 = "";
var succeq$1 = "";
var succnapprox$1 = "";
var succneqq$1 = "";
var succnsim$1 = "";
var succsim$1 = "";
var SuchThat$1 = "";
var sum$1 = "";
var Sum$1 = "";
var sung$1 = "";
var sup1$1$1 = "";
var sup2$1$1 = "";
var sup3$1$1 = "";
var sup$1 = "";
var Sup$1 = "";
var supdot$1 = "";
var supdsub$1 = "";
var supE$1 = "";
var supe$1 = "";
var supedot$1 = "";
var Superset$1 = "";
var SupersetEqual$1 = "";
var suphsol$1 = "";
var suphsub$1 = "";
var suplarr$1 = "";
var supmult$1 = "";
var supnE$1 = "";
var supne$1 = "";
var supplus$1 = "";
var supset$1 = "";
var Supset$1 = "";
var supseteq$1 = "";
var supseteqq$1 = "";
var supsetneq$1 = "";
var supsetneqq$1 = "";
var supsim$1 = "";
var supsub$1 = "";
var supsup$1 = "";
var swarhk$1 = "";
var swarr$1 = "";
var swArr$1 = "";
var swarrow$1 = "";
var swnwar$1 = "";
var szlig$1$1 = "";
var Tab$1 = "\t";
var target$1 = "";
var Tau$1 = "";
var tau$1 = "";
var tbrk$1 = "";
var Tcaron$1 = "";
var tcaron$1 = "";
var Tcedil$1 = "";
var tcedil$1 = "";
var Tcy$1 = "";
var tcy$1 = "";
var tdot$1 = "";
var telrec$1 = "";
var Tfr$1 = "";
var tfr$1 = "";
var there4$1 = "";
var therefore$1 = "";
var Therefore$1 = "";
var Theta$1 = "";
var theta$1 = "";
var thetasym$1 = "";
var thetav$1 = "";
var thickapprox$1 = "";
var thicksim$1 = "";
var ThickSpace$1 = "";
var ThinSpace$1 = "";
var thinsp$1 = "";
var thkap$1 = "";
var thksim$1 = "";
var THORN$1$1 = "";
var thorn$1$1 = "";
var tilde$1 = "";
var Tilde$1 = "";
var TildeEqual$1 = "";
var TildeFullEqual$1 = "";
var TildeTilde$1 = "";
var timesbar$1 = "";
var timesb$1 = "";
var times$2 = "";
var timesd$1 = "";
var tint$1 = "";
var toea$1 = "";
var topbot$1 = "";
var topcir$1 = "";
var top$1 = "";
var Topf$1 = "";
var topf$1 = "";
var topfork$1 = "";
var tosa$1 = "";
var tprime$1 = "";
var trade$1 = "";
var TRADE$1 = "";
var triangle$1 = "";
var triangledown$1 = "";
var triangleleft$1 = "";
var trianglelefteq$1 = "";
var triangleq$1 = "";
var triangleright$1 = "";
var trianglerighteq$1 = "";
var tridot$1 = "";
var trie$1 = "";
var triminus$1 = "";
var TripleDot$1 = "";
var triplus$1 = "";
var trisb$1 = "";
var tritime$1 = "";
var trpezium$1 = "";
var Tscr$1 = "";
var tscr$1 = "";
var TScy$1 = "";
var tscy$1 = "";
var TSHcy$1 = "";
var tshcy$1 = "";
var Tstrok$1 = "";
var tstrok$1 = "";
var twixt$1 = "";
var twoheadleftarrow$1 = "";
var twoheadrightarrow$1 = "";
var Uacute$1$1 = "";
var uacute$1$1 = "";
var uarr$1 = "";
var Uarr$1 = "";
var uArr$1 = "";
var Uarrocir$1 = "";
var Ubrcy$1 = "";
var ubrcy$1 = "";
var Ubreve$1 = "";
var ubreve$1 = "";
var Ucirc$1$1 = "";
var ucirc$1$1 = "";
var Ucy$1 = "";
var ucy$1 = "";
var udarr$1 = "";
var Udblac$1 = "";
var udblac$1 = "";
var udhar$1 = "";
var ufisht$1 = "";
var Ufr$1 = "";
var ufr$1 = "";
var Ugrave$1$1 = "";
var ugrave$1$1 = "";
var uHar$1 = "";
var uharl$1 = "";
var uharr$1 = "";
var uhblk$1 = "";
var ulcorn$1 = "";
var ulcorner$1 = "";
var ulcrop$1 = "";
var ultri$1 = "";
var Umacr$1 = "";
var umacr$1 = "";
var uml$1$1 = "";
var UnderBar$1 = "_";
var UnderBrace$1 = "";
var UnderBracket$1 = "";
var UnderParenthesis$1 = "";
var Union$1 = "";
var UnionPlus$1 = "";
var Uogon$1 = "";
var uogon$1 = "";
var Uopf$1 = "";
var uopf$1 = "";
var UpArrowBar$1 = "";
var uparrow$1 = "";
var UpArrow$1 = "";
var Uparrow$1 = "";
var UpArrowDownArrow$1 = "";
var updownarrow$1 = "";
var UpDownArrow$1 = "";
var Updownarrow$1 = "";
var UpEquilibrium$1 = "";
var upharpoonleft$1 = "";
var upharpoonright$1 = "";
var uplus$1 = "";
var UpperLeftArrow$1 = "";
var UpperRightArrow$1 = "";
var upsi$1 = "";
var Upsi$1 = "";
var upsih$1 = "";
var Upsilon$1 = "";
var upsilon$1 = "";
var UpTeeArrow$1 = "";
var UpTee$1 = "";
var upuparrows$1 = "";
var urcorn$1 = "";
var urcorner$1 = "";
var urcrop$1 = "";
var Uring$1 = "";
var uring$1 = "";
var urtri$1 = "";
var Uscr$1 = "";
var uscr$1 = "";
var utdot$1 = "";
var Utilde$1 = "";
var utilde$1 = "";
var utri$1 = "";
var utrif$1 = "";
var uuarr$1 = "";
var Uuml$1$1 = "";
var uuml$1$1 = "";
var uwangle$1 = "";
var vangrt$1 = "";
var varepsilon$1 = "";
var varkappa$1 = "";
var varnothing$1 = "";
var varphi$1 = "";
var varpi$1 = "";
var varpropto$1 = "";
var varr$1 = "";
var vArr$1 = "";
var varrho$1 = "";
var varsigma$1 = "";
var varsubsetneq$1 = "";
var varsubsetneqq$1 = "";
var varsupsetneq$1 = "";
var varsupsetneqq$1 = "";
var vartheta$1 = "";
var vartriangleleft$1 = "";
var vartriangleright$1 = "";
var vBar$1 = "";
var Vbar$1 = "";
var vBarv$1 = "";
var Vcy$1 = "";
var vcy$1 = "";
var vdash$1 = "";
var vDash$1 = "";
var Vdash$1 = "";
var VDash$1 = "";
var Vdashl$1 = "";
var veebar$1 = "";
var vee$1 = "";
var Vee$1 = "";
var veeeq$1 = "";
var vellip$1 = "";
var verbar$1 = "|";
var Verbar$1 = "";
var vert$1 = "|";
var Vert$1 = "";
var VerticalBar$1 = "";
var VerticalLine$1 = "|";
var VerticalSeparator$1 = "";
var VerticalTilde$1 = "";
var VeryThinSpace$1 = "";
var Vfr$1 = "";
var vfr$1 = "";
var vltri$1 = "";
var vnsub$1 = "";
var vnsup$1 = "";
var Vopf$1 = "";
var vopf$1 = "";
var vprop$1 = "";
var vrtri$1 = "";
var Vscr$1 = "";
var vscr$1 = "";
var vsubnE$1 = "";
var vsubne$1 = "";
var vsupnE$1 = "";
var vsupne$1 = "";
var Vvdash$1 = "";
var vzigzag$1 = "";
var Wcirc$1 = "";
var wcirc$1 = "";
var wedbar$1 = "";
var wedge$1 = "";
var Wedge$1 = "";
var wedgeq$1 = "";
var weierp$1 = "";
var Wfr$1 = "";
var wfr$1 = "";
var Wopf$1 = "";
var wopf$1 = "";
var wp$1 = "";
var wr$1 = "";
var wreath$1 = "";
var Wscr$1 = "";
var wscr$1 = "";
var xcap$1 = "";
var xcirc$1 = "";
var xcup$1 = "";
var xdtri$1 = "";
var Xfr$1 = "";
var xfr$1 = "";
var xharr$1 = "";
var xhArr$1 = "";
var Xi$1 = "";
var xi$1 = "";
var xlarr$1 = "";
var xlArr$1 = "";
var xmap$1 = "";
var xnis$1 = "";
var xodot$1 = "";
var Xopf$1 = "";
var xopf$1 = "";
var xoplus$1 = "";
var xotime$1 = "";
var xrarr$1 = "";
var xrArr$1 = "";
var Xscr$1 = "";
var xscr$1 = "";
var xsqcup$1 = "";
var xuplus$1 = "";
var xutri$1 = "";
var xvee$1 = "";
var xwedge$1 = "";
var Yacute$1$1 = "";
var yacute$1$1 = "";
var YAcy$1 = "";
var yacy$1 = "";
var Ycirc$1 = "";
var ycirc$1 = "";
var Ycy$1 = "";
var ycy$1 = "";
var yen$1$1 = "";
var Yfr$1 = "";
var yfr$1 = "";
var YIcy$1 = "";
var yicy$1 = "";
var Yopf$1 = "";
var yopf$1 = "";
var Yscr$1 = "";
var yscr$1 = "";
var YUcy$1 = "";
var yucy$1 = "";
var yuml$1$1 = "";
var Yuml$1 = "";
var Zacute$1 = "";
var zacute$1 = "";
var Zcaron$1 = "";
var zcaron$1 = "";
var Zcy$1 = "";
var zcy$1 = "";
var Zdot$1 = "";
var zdot$1 = "";
var zeetrf$1 = "";
var ZeroWidthSpace$1 = "";
var Zeta$1 = "";
var zeta$1 = "";
var zfr$1 = "";
var Zfr$1 = "";
var ZHcy$1 = "";
var zhcy$1 = "";
var zigrarr$1 = "";
var zopf$1 = "";
var Zopf$1 = "";
var Zscr$1 = "";
var zscr$1 = "";
var zwj$1 = "";
var zwnj$1 = "";
var entitiesJSON$1 = {
	Aacute: Aacute$1$1,
	aacute: aacute$1$1,
	Abreve: Abreve$1,
	abreve: abreve$1,
	ac: ac$1,
	acd: acd$1,
	acE: acE$1,
	Acirc: Acirc$1$1,
	acirc: acirc$1$1,
	acute: acute$1$1,
	Acy: Acy$1,
	acy: acy$1,
	AElig: AElig$1$1,
	aelig: aelig$1$1,
	af: af$1,
	Afr: Afr$1,
	afr: afr$1,
	Agrave: Agrave$1$1,
	agrave: agrave$1$1,
	alefsym: alefsym$1,
	aleph: aleph$1,
	Alpha: Alpha$1,
	alpha: alpha$1,
	Amacr: Amacr$1,
	amacr: amacr$1,
	amalg: amalg$1,
	amp: amp$1$2,
	AMP: AMP$1$1,
	andand: andand$1,
	And: And$1,
	and: and$1,
	andd: andd$1,
	andslope: andslope$1,
	andv: andv$1,
	ang: ang$1,
	ange: ange$1,
	angle: angle$1,
	angmsdaa: angmsdaa$1,
	angmsdab: angmsdab$1,
	angmsdac: angmsdac$1,
	angmsdad: angmsdad$1,
	angmsdae: angmsdae$1,
	angmsdaf: angmsdaf$1,
	angmsdag: angmsdag$1,
	angmsdah: angmsdah$1,
	angmsd: angmsd$1,
	angrt: angrt$1,
	angrtvb: angrtvb$1,
	angrtvbd: angrtvbd$1,
	angsph: angsph$1,
	angst: angst$1,
	angzarr: angzarr$1,
	Aogon: Aogon$1,
	aogon: aogon$1,
	Aopf: Aopf$1,
	aopf: aopf$1,
	apacir: apacir$1,
	ap: ap$1,
	apE: apE$1,
	ape: ape$1,
	apid: apid$1,
	apos: apos$1$2,
	ApplyFunction: ApplyFunction$1,
	approx: approx$1,
	approxeq: approxeq$1,
	Aring: Aring$1$1,
	aring: aring$1$1,
	Ascr: Ascr$1,
	ascr: ascr$1,
	Assign: Assign$1,
	ast: ast$1,
	asymp: asymp$1,
	asympeq: asympeq$1,
	Atilde: Atilde$1$1,
	atilde: atilde$1$1,
	Auml: Auml$1$1,
	auml: auml$1$1,
	awconint: awconint$1,
	awint: awint$1,
	backcong: backcong$1,
	backepsilon: backepsilon$1,
	backprime: backprime$1,
	backsim: backsim$1,
	backsimeq: backsimeq$1,
	Backslash: Backslash$1,
	Barv: Barv$1,
	barvee: barvee$1,
	barwed: barwed$1,
	Barwed: Barwed$1,
	barwedge: barwedge$1,
	bbrk: bbrk$1,
	bbrktbrk: bbrktbrk$1,
	bcong: bcong$1,
	Bcy: Bcy$1,
	bcy: bcy$1,
	bdquo: bdquo$1,
	becaus: becaus$1,
	because: because$1,
	Because: Because$1,
	bemptyv: bemptyv$1,
	bepsi: bepsi$1,
	bernou: bernou$1,
	Bernoullis: Bernoullis$1,
	Beta: Beta$1,
	beta: beta$1,
	beth: beth$1,
	between: between$1,
	Bfr: Bfr$1,
	bfr: bfr$1,
	bigcap: bigcap$1,
	bigcirc: bigcirc$1,
	bigcup: bigcup$1,
	bigodot: bigodot$1,
	bigoplus: bigoplus$1,
	bigotimes: bigotimes$1,
	bigsqcup: bigsqcup$1,
	bigstar: bigstar$1,
	bigtriangledown: bigtriangledown$1,
	bigtriangleup: bigtriangleup$1,
	biguplus: biguplus$1,
	bigvee: bigvee$1,
	bigwedge: bigwedge$1,
	bkarow: bkarow$1,
	blacklozenge: blacklozenge$1,
	blacksquare: blacksquare$1,
	blacktriangle: blacktriangle$1,
	blacktriangledown: blacktriangledown$1,
	blacktriangleleft: blacktriangleleft$1,
	blacktriangleright: blacktriangleright$1,
	blank: blank$1,
	blk12: blk12$1,
	blk14: blk14$1,
	blk34: blk34$1,
	block: block$1,
	bne: bne$1,
	bnequiv: bnequiv$1,
	bNot: bNot$1,
	bnot: bnot$1,
	Bopf: Bopf$1,
	bopf: bopf$1,
	bot: bot$1,
	bottom: bottom$1,
	bowtie: bowtie$1,
	boxbox: boxbox$1,
	boxdl: boxdl$1,
	boxdL: boxdL$1,
	boxDl: boxDl$1,
	boxDL: boxDL$1,
	boxdr: boxdr$1,
	boxdR: boxdR$1,
	boxDr: boxDr$1,
	boxDR: boxDR$1,
	boxh: boxh$1,
	boxH: boxH$1,
	boxhd: boxhd$1,
	boxHd: boxHd$1,
	boxhD: boxhD$1,
	boxHD: boxHD$1,
	boxhu: boxhu$1,
	boxHu: boxHu$1,
	boxhU: boxhU$1,
	boxHU: boxHU$1,
	boxminus: boxminus$1,
	boxplus: boxplus$1,
	boxtimes: boxtimes$1,
	boxul: boxul$1,
	boxuL: boxuL$1,
	boxUl: boxUl$1,
	boxUL: boxUL$1,
	boxur: boxur$1,
	boxuR: boxuR$1,
	boxUr: boxUr$1,
	boxUR: boxUR$1,
	boxv: boxv$1,
	boxV: boxV$1,
	boxvh: boxvh$1,
	boxvH: boxvH$1,
	boxVh: boxVh$1,
	boxVH: boxVH$1,
	boxvl: boxvl$1,
	boxvL: boxvL$1,
	boxVl: boxVl$1,
	boxVL: boxVL$1,
	boxvr: boxvr$1,
	boxvR: boxvR$1,
	boxVr: boxVr$1,
	boxVR: boxVR$1,
	bprime: bprime$1,
	breve: breve$1,
	Breve: Breve$1,
	brvbar: brvbar$1$1,
	bscr: bscr$1,
	Bscr: Bscr$1,
	bsemi: bsemi$1,
	bsim: bsim$1,
	bsime: bsime$1,
	bsolb: bsolb$1,
	bsol: bsol$1,
	bsolhsub: bsolhsub$1,
	bull: bull$1,
	bullet: bullet$1,
	bump: bump$1,
	bumpE: bumpE$1,
	bumpe: bumpe$1,
	Bumpeq: Bumpeq$1,
	bumpeq: bumpeq$1,
	Cacute: Cacute$1,
	cacute: cacute$1,
	capand: capand$1,
	capbrcup: capbrcup$1,
	capcap: capcap$1,
	cap: cap$1,
	Cap: Cap$1,
	capcup: capcup$1,
	capdot: capdot$1,
	CapitalDifferentialD: CapitalDifferentialD$1,
	caps: caps$1,
	caret: caret$1,
	caron: caron$1,
	Cayleys: Cayleys$1,
	ccaps: ccaps$1,
	Ccaron: Ccaron$1,
	ccaron: ccaron$1,
	Ccedil: Ccedil$1$1,
	ccedil: ccedil$1$1,
	Ccirc: Ccirc$1,
	ccirc: ccirc$1,
	Cconint: Cconint$1,
	ccups: ccups$1,
	ccupssm: ccupssm$1,
	Cdot: Cdot$1,
	cdot: cdot$1,
	cedil: cedil$1$1,
	Cedilla: Cedilla$1,
	cemptyv: cemptyv$1,
	cent: cent$1$1,
	centerdot: centerdot$1,
	CenterDot: CenterDot$1,
	cfr: cfr$1,
	Cfr: Cfr$1,
	CHcy: CHcy$1,
	chcy: chcy$1,
	check: check$1,
	checkmark: checkmark$1,
	Chi: Chi$1,
	chi: chi$1,
	circ: circ$1,
	circeq: circeq$1,
	circlearrowleft: circlearrowleft$1,
	circlearrowright: circlearrowright$1,
	circledast: circledast$1,
	circledcirc: circledcirc$1,
	circleddash: circleddash$1,
	CircleDot: CircleDot$1,
	circledR: circledR$1,
	circledS: circledS$1,
	CircleMinus: CircleMinus$1,
	CirclePlus: CirclePlus$1,
	CircleTimes: CircleTimes$1,
	cir: cir$1,
	cirE: cirE$1,
	cire: cire$1,
	cirfnint: cirfnint$1,
	cirmid: cirmid$1,
	cirscir: cirscir$1,
	ClockwiseContourIntegral: ClockwiseContourIntegral$1,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote$1,
	CloseCurlyQuote: CloseCurlyQuote$1,
	clubs: clubs$1,
	clubsuit: clubsuit$1,
	colon: colon$1,
	Colon: Colon$1,
	Colone: Colone$1,
	colone: colone$1,
	coloneq: coloneq$1,
	comma: comma$1,
	commat: commat$1,
	comp: comp$1,
	compfn: compfn$1,
	complement: complement$1,
	complexes: complexes$1,
	cong: cong$1,
	congdot: congdot$1,
	Congruent: Congruent$1,
	conint: conint$1,
	Conint: Conint$1,
	ContourIntegral: ContourIntegral$1,
	copf: copf$1,
	Copf: Copf$1,
	coprod: coprod$1,
	Coproduct: Coproduct$1,
	copy: copy$1$1,
	COPY: COPY$1$1,
	copysr: copysr$1,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral$1,
	crarr: crarr$1,
	cross: cross$1,
	Cross: Cross$1,
	Cscr: Cscr$1,
	cscr: cscr$1,
	csub: csub$1,
	csube: csube$1,
	csup: csup$1,
	csupe: csupe$1,
	ctdot: ctdot$1,
	cudarrl: cudarrl$1,
	cudarrr: cudarrr$1,
	cuepr: cuepr$1,
	cuesc: cuesc$1,
	cularr: cularr$1,
	cularrp: cularrp$1,
	cupbrcap: cupbrcap$1,
	cupcap: cupcap$1,
	CupCap: CupCap$1,
	cup: cup$1,
	Cup: Cup$1,
	cupcup: cupcup$1,
	cupdot: cupdot$1,
	cupor: cupor$1,
	cups: cups$1,
	curarr: curarr$1,
	curarrm: curarrm$1,
	curlyeqprec: curlyeqprec$1,
	curlyeqsucc: curlyeqsucc$1,
	curlyvee: curlyvee$1,
	curlywedge: curlywedge$1,
	curren: curren$1$1,
	curvearrowleft: curvearrowleft$1,
	curvearrowright: curvearrowright$1,
	cuvee: cuvee$1,
	cuwed: cuwed$1,
	cwconint: cwconint$1,
	cwint: cwint$1,
	cylcty: cylcty$1,
	dagger: dagger$1,
	Dagger: Dagger$1,
	daleth: daleth$1,
	darr: darr$1,
	Darr: Darr$1,
	dArr: dArr$1,
	dash: dash$1,
	Dashv: Dashv$1,
	dashv: dashv$1,
	dbkarow: dbkarow$1,
	dblac: dblac$1,
	Dcaron: Dcaron$1,
	dcaron: dcaron$1,
	Dcy: Dcy$1,
	dcy: dcy$1,
	ddagger: ddagger$1,
	ddarr: ddarr$1,
	DD: DD$1,
	dd: dd$1,
	DDotrahd: DDotrahd$1,
	ddotseq: ddotseq$1,
	deg: deg$1$1,
	Del: Del$1,
	Delta: Delta$1,
	delta: delta$1,
	demptyv: demptyv$1,
	dfisht: dfisht$1,
	Dfr: Dfr$1,
	dfr: dfr$1,
	dHar: dHar$1,
	dharl: dharl$1,
	dharr: dharr$1,
	DiacriticalAcute: DiacriticalAcute$1,
	DiacriticalDot: DiacriticalDot$1,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute$1,
	DiacriticalGrave: DiacriticalGrave$1,
	DiacriticalTilde: DiacriticalTilde$1,
	diam: diam$1,
	diamond: diamond$1,
	Diamond: Diamond$1,
	diamondsuit: diamondsuit$1,
	diams: diams$1,
	die: die$1,
	DifferentialD: DifferentialD$1,
	digamma: digamma$1,
	disin: disin$1,
	div: div$1,
	divide: divide$1$1,
	divideontimes: divideontimes$1,
	divonx: divonx$1,
	DJcy: DJcy$1,
	djcy: djcy$1,
	dlcorn: dlcorn$1,
	dlcrop: dlcrop$1,
	dollar: dollar$1,
	Dopf: Dopf$1,
	dopf: dopf$1,
	Dot: Dot$1,
	dot: dot$1,
	DotDot: DotDot$1,
	doteq: doteq$1,
	doteqdot: doteqdot$1,
	DotEqual: DotEqual$1,
	dotminus: dotminus$1,
	dotplus: dotplus$1,
	dotsquare: dotsquare$1,
	doublebarwedge: doublebarwedge$1,
	DoubleContourIntegral: DoubleContourIntegral$1,
	DoubleDot: DoubleDot$1,
	DoubleDownArrow: DoubleDownArrow$1,
	DoubleLeftArrow: DoubleLeftArrow$1,
	DoubleLeftRightArrow: DoubleLeftRightArrow$1,
	DoubleLeftTee: DoubleLeftTee$1,
	DoubleLongLeftArrow: DoubleLongLeftArrow$1,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow$1,
	DoubleLongRightArrow: DoubleLongRightArrow$1,
	DoubleRightArrow: DoubleRightArrow$1,
	DoubleRightTee: DoubleRightTee$1,
	DoubleUpArrow: DoubleUpArrow$1,
	DoubleUpDownArrow: DoubleUpDownArrow$1,
	DoubleVerticalBar: DoubleVerticalBar$1,
	DownArrowBar: DownArrowBar$1,
	downarrow: downarrow$1,
	DownArrow: DownArrow$1,
	Downarrow: Downarrow$1,
	DownArrowUpArrow: DownArrowUpArrow$1,
	DownBreve: DownBreve$1,
	downdownarrows: downdownarrows$1,
	downharpoonleft: downharpoonleft$1,
	downharpoonright: downharpoonright$1,
	DownLeftRightVector: DownLeftRightVector$1,
	DownLeftTeeVector: DownLeftTeeVector$1,
	DownLeftVectorBar: DownLeftVectorBar$1,
	DownLeftVector: DownLeftVector$1,
	DownRightTeeVector: DownRightTeeVector$1,
	DownRightVectorBar: DownRightVectorBar$1,
	DownRightVector: DownRightVector$1,
	DownTeeArrow: DownTeeArrow$1,
	DownTee: DownTee$1,
	drbkarow: drbkarow$1,
	drcorn: drcorn$1,
	drcrop: drcrop$1,
	Dscr: Dscr$1,
	dscr: dscr$1,
	DScy: DScy$1,
	dscy: dscy$1,
	dsol: dsol$1,
	Dstrok: Dstrok$1,
	dstrok: dstrok$1,
	dtdot: dtdot$1,
	dtri: dtri$1,
	dtrif: dtrif$1,
	duarr: duarr$1,
	duhar: duhar$1,
	dwangle: dwangle$1,
	DZcy: DZcy$1,
	dzcy: dzcy$1,
	dzigrarr: dzigrarr$1,
	Eacute: Eacute$1$1,
	eacute: eacute$1$1,
	easter: easter$1,
	Ecaron: Ecaron$1,
	ecaron: ecaron$1,
	Ecirc: Ecirc$1$1,
	ecirc: ecirc$1$1,
	ecir: ecir$1,
	ecolon: ecolon$1,
	Ecy: Ecy$1,
	ecy: ecy$1,
	eDDot: eDDot$1,
	Edot: Edot$1,
	edot: edot$1,
	eDot: eDot$1,
	ee: ee$1,
	efDot: efDot$1,
	Efr: Efr$1,
	efr: efr$1,
	eg: eg$1,
	Egrave: Egrave$1$1,
	egrave: egrave$1$1,
	egs: egs$1,
	egsdot: egsdot$1,
	el: el$1,
	Element: Element$1,
	elinters: elinters$1,
	ell: ell$1,
	els: els$1,
	elsdot: elsdot$1,
	Emacr: Emacr$1,
	emacr: emacr$1,
	empty: empty$1,
	emptyset: emptyset$1,
	EmptySmallSquare: EmptySmallSquare$1,
	emptyv: emptyv$1,
	EmptyVerySmallSquare: EmptyVerySmallSquare$1,
	emsp13: emsp13$1,
	emsp14: emsp14$1,
	emsp: emsp$1,
	ENG: ENG$1,
	eng: eng$1,
	ensp: ensp$1,
	Eogon: Eogon$1,
	eogon: eogon$1,
	Eopf: Eopf$1,
	eopf: eopf$1,
	epar: epar$1,
	eparsl: eparsl$1,
	eplus: eplus$1,
	epsi: epsi$1,
	Epsilon: Epsilon$1,
	epsilon: epsilon$1,
	epsiv: epsiv$1,
	eqcirc: eqcirc$1,
	eqcolon: eqcolon$1,
	eqsim: eqsim$1,
	eqslantgtr: eqslantgtr$1,
	eqslantless: eqslantless$1,
	Equal: Equal$1,
	equals: equals$1,
	EqualTilde: EqualTilde$1,
	equest: equest$1,
	Equilibrium: Equilibrium$1,
	equiv: equiv$1,
	equivDD: equivDD$1,
	eqvparsl: eqvparsl$1,
	erarr: erarr$1,
	erDot: erDot$1,
	escr: escr$1,
	Escr: Escr$1,
	esdot: esdot$1,
	Esim: Esim$1,
	esim: esim$1,
	Eta: Eta$1,
	eta: eta$1,
	ETH: ETH$1$1,
	eth: eth$1$1,
	Euml: Euml$1$1,
	euml: euml$1$1,
	euro: euro$1,
	excl: excl$1,
	exist: exist$1,
	Exists: Exists$1,
	expectation: expectation$1,
	exponentiale: exponentiale$1,
	ExponentialE: ExponentialE$1,
	fallingdotseq: fallingdotseq$1,
	Fcy: Fcy$1,
	fcy: fcy$1,
	female: female$1,
	ffilig: ffilig$1,
	fflig: fflig$1,
	ffllig: ffllig$1,
	Ffr: Ffr$1,
	ffr: ffr$1,
	filig: filig$1,
	FilledSmallSquare: FilledSmallSquare$1,
	FilledVerySmallSquare: FilledVerySmallSquare$1,
	fjlig: fjlig$1,
	flat: flat$1,
	fllig: fllig$1,
	fltns: fltns$1,
	fnof: fnof$1,
	Fopf: Fopf$1,
	fopf: fopf$1,
	forall: forall$1,
	ForAll: ForAll$1,
	fork: fork$1,
	forkv: forkv$1,
	Fouriertrf: Fouriertrf$1,
	fpartint: fpartint$1,
	frac12: frac12$1$1,
	frac13: frac13$1,
	frac14: frac14$1$1,
	frac15: frac15$1,
	frac16: frac16$1,
	frac18: frac18$1,
	frac23: frac23$1,
	frac25: frac25$1,
	frac34: frac34$1$1,
	frac35: frac35$1,
	frac38: frac38$1,
	frac45: frac45$1,
	frac56: frac56$1,
	frac58: frac58$1,
	frac78: frac78$1,
	frasl: frasl$1,
	frown: frown$1,
	fscr: fscr$1,
	Fscr: Fscr$1,
	gacute: gacute$1,
	Gamma: Gamma$1,
	gamma: gamma$1,
	Gammad: Gammad$1,
	gammad: gammad$1,
	gap: gap$1,
	Gbreve: Gbreve$1,
	gbreve: gbreve$1,
	Gcedil: Gcedil$1,
	Gcirc: Gcirc$1,
	gcirc: gcirc$1,
	Gcy: Gcy$1,
	gcy: gcy$1,
	Gdot: Gdot$1,
	gdot: gdot$1,
	ge: ge$1,
	gE: gE$1,
	gEl: gEl$1,
	gel: gel$1,
	geq: geq$1,
	geqq: geqq$1,
	geqslant: geqslant$1,
	gescc: gescc$1,
	ges: ges$1,
	gesdot: gesdot$1,
	gesdoto: gesdoto$1,
	gesdotol: gesdotol$1,
	gesl: gesl$1,
	gesles: gesles$1,
	Gfr: Gfr$1,
	gfr: gfr$1,
	gg: gg$1,
	Gg: Gg$1,
	ggg: ggg$1,
	gimel: gimel$1,
	GJcy: GJcy$1,
	gjcy: gjcy$1,
	gla: gla$1,
	gl: gl$1,
	glE: glE$1,
	glj: glj$1,
	gnap: gnap$1,
	gnapprox: gnapprox$1,
	gne: gne$1,
	gnE: gnE$1,
	gneq: gneq$1,
	gneqq: gneqq$1,
	gnsim: gnsim$1,
	Gopf: Gopf$1,
	gopf: gopf$1,
	grave: grave$1,
	GreaterEqual: GreaterEqual$1,
	GreaterEqualLess: GreaterEqualLess$1,
	GreaterFullEqual: GreaterFullEqual$1,
	GreaterGreater: GreaterGreater$1,
	GreaterLess: GreaterLess$1,
	GreaterSlantEqual: GreaterSlantEqual$1,
	GreaterTilde: GreaterTilde$1,
	Gscr: Gscr$1,
	gscr: gscr$1,
	gsim: gsim$1,
	gsime: gsime$1,
	gsiml: gsiml$1,
	gtcc: gtcc$1,
	gtcir: gtcir$1,
	gt: gt$1$2,
	GT: GT$1$1,
	Gt: Gt$1,
	gtdot: gtdot$1,
	gtlPar: gtlPar$1,
	gtquest: gtquest$1,
	gtrapprox: gtrapprox$1,
	gtrarr: gtrarr$1,
	gtrdot: gtrdot$1,
	gtreqless: gtreqless$1,
	gtreqqless: gtreqqless$1,
	gtrless: gtrless$1,
	gtrsim: gtrsim$1,
	gvertneqq: gvertneqq$1,
	gvnE: gvnE$1,
	Hacek: Hacek$1,
	hairsp: hairsp$1,
	half: half$1,
	hamilt: hamilt$1,
	HARDcy: HARDcy$1,
	hardcy: hardcy$1,
	harrcir: harrcir$1,
	harr: harr$1,
	hArr: hArr$1,
	harrw: harrw$1,
	Hat: Hat$1,
	hbar: hbar$1,
	Hcirc: Hcirc$1,
	hcirc: hcirc$1,
	hearts: hearts$1,
	heartsuit: heartsuit$1,
	hellip: hellip$1,
	hercon: hercon$1,
	hfr: hfr$1,
	Hfr: Hfr$1,
	HilbertSpace: HilbertSpace$1,
	hksearow: hksearow$1,
	hkswarow: hkswarow$1,
	hoarr: hoarr$1,
	homtht: homtht$1,
	hookleftarrow: hookleftarrow$1,
	hookrightarrow: hookrightarrow$1,
	hopf: hopf$1,
	Hopf: Hopf$1,
	horbar: horbar$1,
	HorizontalLine: HorizontalLine$1,
	hscr: hscr$1,
	Hscr: Hscr$1,
	hslash: hslash$1,
	Hstrok: Hstrok$1,
	hstrok: hstrok$1,
	HumpDownHump: HumpDownHump$1,
	HumpEqual: HumpEqual$1,
	hybull: hybull$1,
	hyphen: hyphen$1,
	Iacute: Iacute$1$1,
	iacute: iacute$1$1,
	ic: ic$1,
	Icirc: Icirc$1$1,
	icirc: icirc$1$1,
	Icy: Icy$1,
	icy: icy$1,
	Idot: Idot$1,
	IEcy: IEcy$1,
	iecy: iecy$1,
	iexcl: iexcl$1$1,
	iff: iff$1,
	ifr: ifr$1,
	Ifr: Ifr$1,
	Igrave: Igrave$1$1,
	igrave: igrave$1$1,
	ii: ii$1,
	iiiint: iiiint$1,
	iiint: iiint$1,
	iinfin: iinfin$1,
	iiota: iiota$1,
	IJlig: IJlig$1,
	ijlig: ijlig$1,
	Imacr: Imacr$1,
	imacr: imacr$1,
	image: image$1,
	ImaginaryI: ImaginaryI$1,
	imagline: imagline$1,
	imagpart: imagpart$1,
	imath: imath$1,
	Im: Im$1,
	imof: imof$1,
	imped: imped$1,
	Implies: Implies$1,
	incare: incare$1,
	infin: infin$1,
	infintie: infintie$1,
	inodot: inodot$1,
	intcal: intcal$1,
	int: int$1,
	Int: Int$1,
	integers: integers$1,
	Integral: Integral$1,
	intercal: intercal$1,
	Intersection: Intersection$1,
	intlarhk: intlarhk$1,
	intprod: intprod$1,
	InvisibleComma: InvisibleComma$1,
	InvisibleTimes: InvisibleTimes$1,
	IOcy: IOcy$1,
	iocy: iocy$1,
	Iogon: Iogon$1,
	iogon: iogon$1,
	Iopf: Iopf$1,
	iopf: iopf$1,
	Iota: Iota$1,
	iota: iota$1,
	iprod: iprod$1,
	iquest: iquest$1$1,
	iscr: iscr$1,
	Iscr: Iscr$1,
	isin: isin$1,
	isindot: isindot$1,
	isinE: isinE$1,
	isins: isins$1,
	isinsv: isinsv$1,
	isinv: isinv$1,
	it: it$1,
	Itilde: Itilde$1,
	itilde: itilde$1,
	Iukcy: Iukcy$1,
	iukcy: iukcy$1,
	Iuml: Iuml$1$1,
	iuml: iuml$1$1,
	Jcirc: Jcirc$1,
	jcirc: jcirc$1,
	Jcy: Jcy$1,
	jcy: jcy$1,
	Jfr: Jfr$1,
	jfr: jfr$1,
	jmath: jmath$1,
	Jopf: Jopf$1,
	jopf: jopf$1,
	Jscr: Jscr$1,
	jscr: jscr$1,
	Jsercy: Jsercy$1,
	jsercy: jsercy$1,
	Jukcy: Jukcy$1,
	jukcy: jukcy$1,
	Kappa: Kappa$1,
	kappa: kappa$1,
	kappav: kappav$1,
	Kcedil: Kcedil$1,
	kcedil: kcedil$1,
	Kcy: Kcy$1,
	kcy: kcy$1,
	Kfr: Kfr$1,
	kfr: kfr$1,
	kgreen: kgreen$1,
	KHcy: KHcy$1,
	khcy: khcy$1,
	KJcy: KJcy$1,
	kjcy: kjcy$1,
	Kopf: Kopf$1,
	kopf: kopf$1,
	Kscr: Kscr$1,
	kscr: kscr$1,
	lAarr: lAarr$1,
	Lacute: Lacute$1,
	lacute: lacute$1,
	laemptyv: laemptyv$1,
	lagran: lagran$1,
	Lambda: Lambda$1,
	lambda: lambda$1,
	lang: lang$1,
	Lang: Lang$1,
	langd: langd$1,
	langle: langle$1,
	lap: lap$1,
	Laplacetrf: Laplacetrf$1,
	laquo: laquo$1$1,
	larrb: larrb$1,
	larrbfs: larrbfs$1,
	larr: larr$1,
	Larr: Larr$1,
	lArr: lArr$1,
	larrfs: larrfs$1,
	larrhk: larrhk$1,
	larrlp: larrlp$1,
	larrpl: larrpl$1,
	larrsim: larrsim$1,
	larrtl: larrtl$1,
	latail: latail$1,
	lAtail: lAtail$1,
	lat: lat$1,
	late: late$1,
	lates: lates$1,
	lbarr: lbarr$1,
	lBarr: lBarr$1,
	lbbrk: lbbrk$1,
	lbrace: lbrace$1,
	lbrack: lbrack$1,
	lbrke: lbrke$1,
	lbrksld: lbrksld$1,
	lbrkslu: lbrkslu$1,
	Lcaron: Lcaron$1,
	lcaron: lcaron$1,
	Lcedil: Lcedil$1,
	lcedil: lcedil$1,
	lceil: lceil$1,
	lcub: lcub$1,
	Lcy: Lcy$1,
	lcy: lcy$1,
	ldca: ldca$1,
	ldquo: ldquo$1,
	ldquor: ldquor$1,
	ldrdhar: ldrdhar$1,
	ldrushar: ldrushar$1,
	ldsh: ldsh$1,
	le: le$1,
	lE: lE$1,
	LeftAngleBracket: LeftAngleBracket$1,
	LeftArrowBar: LeftArrowBar$1,
	leftarrow: leftarrow$1,
	LeftArrow: LeftArrow$1,
	Leftarrow: Leftarrow$1,
	LeftArrowRightArrow: LeftArrowRightArrow$1,
	leftarrowtail: leftarrowtail$1,
	LeftCeiling: LeftCeiling$1,
	LeftDoubleBracket: LeftDoubleBracket$1,
	LeftDownTeeVector: LeftDownTeeVector$1,
	LeftDownVectorBar: LeftDownVectorBar$1,
	LeftDownVector: LeftDownVector$1,
	LeftFloor: LeftFloor$1,
	leftharpoondown: leftharpoondown$1,
	leftharpoonup: leftharpoonup$1,
	leftleftarrows: leftleftarrows$1,
	leftrightarrow: leftrightarrow$1,
	LeftRightArrow: LeftRightArrow$1,
	Leftrightarrow: Leftrightarrow$1,
	leftrightarrows: leftrightarrows$1,
	leftrightharpoons: leftrightharpoons$1,
	leftrightsquigarrow: leftrightsquigarrow$1,
	LeftRightVector: LeftRightVector$1,
	LeftTeeArrow: LeftTeeArrow$1,
	LeftTee: LeftTee$1,
	LeftTeeVector: LeftTeeVector$1,
	leftthreetimes: leftthreetimes$1,
	LeftTriangleBar: LeftTriangleBar$1,
	LeftTriangle: LeftTriangle$1,
	LeftTriangleEqual: LeftTriangleEqual$1,
	LeftUpDownVector: LeftUpDownVector$1,
	LeftUpTeeVector: LeftUpTeeVector$1,
	LeftUpVectorBar: LeftUpVectorBar$1,
	LeftUpVector: LeftUpVector$1,
	LeftVectorBar: LeftVectorBar$1,
	LeftVector: LeftVector$1,
	lEg: lEg$1,
	leg: leg$1,
	leq: leq$1,
	leqq: leqq$1,
	leqslant: leqslant$1,
	lescc: lescc$1,
	les: les$1,
	lesdot: lesdot$1,
	lesdoto: lesdoto$1,
	lesdotor: lesdotor$1,
	lesg: lesg$1,
	lesges: lesges$1,
	lessapprox: lessapprox$1,
	lessdot: lessdot$1,
	lesseqgtr: lesseqgtr$1,
	lesseqqgtr: lesseqqgtr$1,
	LessEqualGreater: LessEqualGreater$1,
	LessFullEqual: LessFullEqual$1,
	LessGreater: LessGreater$1,
	lessgtr: lessgtr$1,
	LessLess: LessLess$1,
	lesssim: lesssim$1,
	LessSlantEqual: LessSlantEqual$1,
	LessTilde: LessTilde$1,
	lfisht: lfisht$1,
	lfloor: lfloor$1,
	Lfr: Lfr$1,
	lfr: lfr$1,
	lg: lg$1,
	lgE: lgE$1,
	lHar: lHar$1,
	lhard: lhard$1,
	lharu: lharu$1,
	lharul: lharul$1,
	lhblk: lhblk$1,
	LJcy: LJcy$1,
	ljcy: ljcy$1,
	llarr: llarr$1,
	ll: ll$1,
	Ll: Ll$1,
	llcorner: llcorner$1,
	Lleftarrow: Lleftarrow$1,
	llhard: llhard$1,
	lltri: lltri$1,
	Lmidot: Lmidot$1,
	lmidot: lmidot$1,
	lmoustache: lmoustache$1,
	lmoust: lmoust$1,
	lnap: lnap$1,
	lnapprox: lnapprox$1,
	lne: lne$1,
	lnE: lnE$1,
	lneq: lneq$1,
	lneqq: lneqq$1,
	lnsim: lnsim$1,
	loang: loang$1,
	loarr: loarr$1,
	lobrk: lobrk$1,
	longleftarrow: longleftarrow$1,
	LongLeftArrow: LongLeftArrow$1,
	Longleftarrow: Longleftarrow$1,
	longleftrightarrow: longleftrightarrow$1,
	LongLeftRightArrow: LongLeftRightArrow$1,
	Longleftrightarrow: Longleftrightarrow$1,
	longmapsto: longmapsto$1,
	longrightarrow: longrightarrow$1,
	LongRightArrow: LongRightArrow$1,
	Longrightarrow: Longrightarrow$1,
	looparrowleft: looparrowleft$1,
	looparrowright: looparrowright$1,
	lopar: lopar$1,
	Lopf: Lopf$1,
	lopf: lopf$1,
	loplus: loplus$1,
	lotimes: lotimes$1,
	lowast: lowast$1,
	lowbar: lowbar$1,
	LowerLeftArrow: LowerLeftArrow$1,
	LowerRightArrow: LowerRightArrow$1,
	loz: loz$1,
	lozenge: lozenge$1,
	lozf: lozf$1,
	lpar: lpar$1,
	lparlt: lparlt$1,
	lrarr: lrarr$1,
	lrcorner: lrcorner$1,
	lrhar: lrhar$1,
	lrhard: lrhard$1,
	lrm: lrm$1,
	lrtri: lrtri$1,
	lsaquo: lsaquo$1,
	lscr: lscr$1,
	Lscr: Lscr$1,
	lsh: lsh$1,
	Lsh: Lsh$1,
	lsim: lsim$1,
	lsime: lsime$1,
	lsimg: lsimg$1,
	lsqb: lsqb$1,
	lsquo: lsquo$1,
	lsquor: lsquor$1,
	Lstrok: Lstrok$1,
	lstrok: lstrok$1,
	ltcc: ltcc$1,
	ltcir: ltcir$1,
	lt: lt$1$2,
	LT: LT$1$1,
	Lt: Lt$1,
	ltdot: ltdot$1,
	lthree: lthree$1,
	ltimes: ltimes$1,
	ltlarr: ltlarr$1,
	ltquest: ltquest$1,
	ltri: ltri$1,
	ltrie: ltrie$1,
	ltrif: ltrif$1,
	ltrPar: ltrPar$1,
	lurdshar: lurdshar$1,
	luruhar: luruhar$1,
	lvertneqq: lvertneqq$1,
	lvnE: lvnE$1,
	macr: macr$1$1,
	male: male$1,
	malt: malt$1,
	maltese: maltese$1,
	map: map$2,
	mapsto: mapsto$1,
	mapstodown: mapstodown$1,
	mapstoleft: mapstoleft$1,
	mapstoup: mapstoup$1,
	marker: marker$1,
	mcomma: mcomma$1,
	Mcy: Mcy$1,
	mcy: mcy$1,
	mdash: mdash$1,
	mDDot: mDDot$1,
	measuredangle: measuredangle$1,
	MediumSpace: MediumSpace$1,
	Mellintrf: Mellintrf$1,
	Mfr: Mfr$1,
	mfr: mfr$1,
	mho: mho$1,
	micro: micro$1$1,
	midast: midast$1,
	midcir: midcir$1,
	mid: mid$1,
	middot: middot$1$1,
	minusb: minusb$1,
	minus: minus$1,
	minusd: minusd$1,
	minusdu: minusdu$1,
	MinusPlus: MinusPlus$1,
	mlcp: mlcp$1,
	mldr: mldr$1,
	mnplus: mnplus$1,
	models: models$1,
	Mopf: Mopf$1,
	mopf: mopf$1,
	mp: mp$1,
	mscr: mscr$1,
	Mscr: Mscr$1,
	mstpos: mstpos$1,
	Mu: Mu$1,
	mu: mu$1,
	multimap: multimap$1,
	mumap: mumap$1,
	nabla: nabla$1,
	Nacute: Nacute$1,
	nacute: nacute$1,
	nang: nang$1,
	nap: nap$1,
	napE: napE$1,
	napid: napid$1,
	napos: napos$1,
	napprox: napprox$1,
	natural: natural$1,
	naturals: naturals$1,
	natur: natur$1,
	nbsp: nbsp$1$1,
	nbump: nbump$1,
	nbumpe: nbumpe$1,
	ncap: ncap$1,
	Ncaron: Ncaron$1,
	ncaron: ncaron$1,
	Ncedil: Ncedil$1,
	ncedil: ncedil$1,
	ncong: ncong$1,
	ncongdot: ncongdot$1,
	ncup: ncup$1,
	Ncy: Ncy$1,
	ncy: ncy$1,
	ndash: ndash$1,
	nearhk: nearhk$1,
	nearr: nearr$1,
	neArr: neArr$1,
	nearrow: nearrow$1,
	ne: ne$1,
	nedot: nedot$1,
	NegativeMediumSpace: NegativeMediumSpace$1,
	NegativeThickSpace: NegativeThickSpace$1,
	NegativeThinSpace: NegativeThinSpace$1,
	NegativeVeryThinSpace: NegativeVeryThinSpace$1,
	nequiv: nequiv$1,
	nesear: nesear$1,
	nesim: nesim$1,
	NestedGreaterGreater: NestedGreaterGreater$1,
	NestedLessLess: NestedLessLess$1,
	NewLine: NewLine$1,
	nexist: nexist$1,
	nexists: nexists$1,
	Nfr: Nfr$1,
	nfr: nfr$1,
	ngE: ngE$1,
	nge: nge$1,
	ngeq: ngeq$1,
	ngeqq: ngeqq$1,
	ngeqslant: ngeqslant$1,
	nges: nges$1,
	nGg: nGg$1,
	ngsim: ngsim$1,
	nGt: nGt$1,
	ngt: ngt$1,
	ngtr: ngtr$1,
	nGtv: nGtv$1,
	nharr: nharr$1,
	nhArr: nhArr$1,
	nhpar: nhpar$1,
	ni: ni$1,
	nis: nis$1,
	nisd: nisd$1,
	niv: niv$1,
	NJcy: NJcy$1,
	njcy: njcy$1,
	nlarr: nlarr$1,
	nlArr: nlArr$1,
	nldr: nldr$1,
	nlE: nlE$1,
	nle: nle$1,
	nleftarrow: nleftarrow$1,
	nLeftarrow: nLeftarrow$1,
	nleftrightarrow: nleftrightarrow$1,
	nLeftrightarrow: nLeftrightarrow$1,
	nleq: nleq$1,
	nleqq: nleqq$1,
	nleqslant: nleqslant$1,
	nles: nles$1,
	nless: nless$1,
	nLl: nLl$1,
	nlsim: nlsim$1,
	nLt: nLt$1,
	nlt: nlt$1,
	nltri: nltri$1,
	nltrie: nltrie$1,
	nLtv: nLtv$1,
	nmid: nmid$1,
	NoBreak: NoBreak$1,
	NonBreakingSpace: NonBreakingSpace$1,
	nopf: nopf$1,
	Nopf: Nopf$1,
	Not: Not$1,
	not: not$1$1,
	NotCongruent: NotCongruent$1,
	NotCupCap: NotCupCap$1,
	NotDoubleVerticalBar: NotDoubleVerticalBar$1,
	NotElement: NotElement$1,
	NotEqual: NotEqual$1,
	NotEqualTilde: NotEqualTilde$1,
	NotExists: NotExists$1,
	NotGreater: NotGreater$1,
	NotGreaterEqual: NotGreaterEqual$1,
	NotGreaterFullEqual: NotGreaterFullEqual$1,
	NotGreaterGreater: NotGreaterGreater$1,
	NotGreaterLess: NotGreaterLess$1,
	NotGreaterSlantEqual: NotGreaterSlantEqual$1,
	NotGreaterTilde: NotGreaterTilde$1,
	NotHumpDownHump: NotHumpDownHump$1,
	NotHumpEqual: NotHumpEqual$1,
	notin: notin$1,
	notindot: notindot$1,
	notinE: notinE$1,
	notinva: notinva$1,
	notinvb: notinvb$1,
	notinvc: notinvc$1,
	NotLeftTriangleBar: NotLeftTriangleBar$1,
	NotLeftTriangle: NotLeftTriangle$1,
	NotLeftTriangleEqual: NotLeftTriangleEqual$1,
	NotLess: NotLess$1,
	NotLessEqual: NotLessEqual$1,
	NotLessGreater: NotLessGreater$1,
	NotLessLess: NotLessLess$1,
	NotLessSlantEqual: NotLessSlantEqual$1,
	NotLessTilde: NotLessTilde$1,
	NotNestedGreaterGreater: NotNestedGreaterGreater$1,
	NotNestedLessLess: NotNestedLessLess$1,
	notni: notni$1,
	notniva: notniva$1,
	notnivb: notnivb$1,
	notnivc: notnivc$1,
	NotPrecedes: NotPrecedes$1,
	NotPrecedesEqual: NotPrecedesEqual$1,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual$1,
	NotReverseElement: NotReverseElement$1,
	NotRightTriangleBar: NotRightTriangleBar$1,
	NotRightTriangle: NotRightTriangle$1,
	NotRightTriangleEqual: NotRightTriangleEqual$1,
	NotSquareSubset: NotSquareSubset$1,
	NotSquareSubsetEqual: NotSquareSubsetEqual$1,
	NotSquareSuperset: NotSquareSuperset$1,
	NotSquareSupersetEqual: NotSquareSupersetEqual$1,
	NotSubset: NotSubset$1,
	NotSubsetEqual: NotSubsetEqual$1,
	NotSucceeds: NotSucceeds$1,
	NotSucceedsEqual: NotSucceedsEqual$1,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual$1,
	NotSucceedsTilde: NotSucceedsTilde$1,
	NotSuperset: NotSuperset$1,
	NotSupersetEqual: NotSupersetEqual$1,
	NotTilde: NotTilde$1,
	NotTildeEqual: NotTildeEqual$1,
	NotTildeFullEqual: NotTildeFullEqual$1,
	NotTildeTilde: NotTildeTilde$1,
	NotVerticalBar: NotVerticalBar$1,
	nparallel: nparallel$1,
	npar: npar$1,
	nparsl: nparsl$1,
	npart: npart$1,
	npolint: npolint$1,
	npr: npr$1,
	nprcue: nprcue$1,
	nprec: nprec$1,
	npreceq: npreceq$1,
	npre: npre$1,
	nrarrc: nrarrc$1,
	nrarr: nrarr$1,
	nrArr: nrArr$1,
	nrarrw: nrarrw$1,
	nrightarrow: nrightarrow$1,
	nRightarrow: nRightarrow$1,
	nrtri: nrtri$1,
	nrtrie: nrtrie$1,
	nsc: nsc$1,
	nsccue: nsccue$1,
	nsce: nsce$1,
	Nscr: Nscr$1,
	nscr: nscr$1,
	nshortmid: nshortmid$1,
	nshortparallel: nshortparallel$1,
	nsim: nsim$1,
	nsime: nsime$1,
	nsimeq: nsimeq$1,
	nsmid: nsmid$1,
	nspar: nspar$1,
	nsqsube: nsqsube$1,
	nsqsupe: nsqsupe$1,
	nsub: nsub$1,
	nsubE: nsubE$1,
	nsube: nsube$1,
	nsubset: nsubset$1,
	nsubseteq: nsubseteq$1,
	nsubseteqq: nsubseteqq$1,
	nsucc: nsucc$1,
	nsucceq: nsucceq$1,
	nsup: nsup$1,
	nsupE: nsupE$1,
	nsupe: nsupe$1,
	nsupset: nsupset$1,
	nsupseteq: nsupseteq$1,
	nsupseteqq: nsupseteqq$1,
	ntgl: ntgl$1,
	Ntilde: Ntilde$1$1,
	ntilde: ntilde$1$1,
	ntlg: ntlg$1,
	ntriangleleft: ntriangleleft$1,
	ntrianglelefteq: ntrianglelefteq$1,
	ntriangleright: ntriangleright$1,
	ntrianglerighteq: ntrianglerighteq$1,
	Nu: Nu$1,
	nu: nu$1,
	num: num$1,
	numero: numero$1,
	numsp: numsp$1,
	nvap: nvap$1,
	nvdash: nvdash$1,
	nvDash: nvDash$1,
	nVdash: nVdash$1,
	nVDash: nVDash$1,
	nvge: nvge$1,
	nvgt: nvgt$1,
	nvHarr: nvHarr$1,
	nvinfin: nvinfin$1,
	nvlArr: nvlArr$1,
	nvle: nvle$1,
	nvlt: nvlt$1,
	nvltrie: nvltrie$1,
	nvrArr: nvrArr$1,
	nvrtrie: nvrtrie$1,
	nvsim: nvsim$1,
	nwarhk: nwarhk$1,
	nwarr: nwarr$1,
	nwArr: nwArr$1,
	nwarrow: nwarrow$1,
	nwnear: nwnear$1,
	Oacute: Oacute$1$1,
	oacute: oacute$1$1,
	oast: oast$1,
	Ocirc: Ocirc$1$1,
	ocirc: ocirc$1$1,
	ocir: ocir$1,
	Ocy: Ocy$1,
	ocy: ocy$1,
	odash: odash$1,
	Odblac: Odblac$1,
	odblac: odblac$1,
	odiv: odiv$1,
	odot: odot$1,
	odsold: odsold$1,
	OElig: OElig$1,
	oelig: oelig$1,
	ofcir: ofcir$1,
	Ofr: Ofr$1,
	ofr: ofr$1,
	ogon: ogon$1,
	Ograve: Ograve$1$1,
	ograve: ograve$1$1,
	ogt: ogt$1,
	ohbar: ohbar$1,
	ohm: ohm$1,
	oint: oint$1,
	olarr: olarr$1,
	olcir: olcir$1,
	olcross: olcross$1,
	oline: oline$1,
	olt: olt$1,
	Omacr: Omacr$1,
	omacr: omacr$1,
	Omega: Omega$1,
	omega: omega$1,
	Omicron: Omicron$1,
	omicron: omicron$1,
	omid: omid$1,
	ominus: ominus$1,
	Oopf: Oopf$1,
	oopf: oopf$1,
	opar: opar$1,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote$1,
	OpenCurlyQuote: OpenCurlyQuote$1,
	operp: operp$1,
	oplus: oplus$1,
	orarr: orarr$1,
	Or: Or$1,
	or: or$1,
	ord: ord$1,
	order: order$1,
	orderof: orderof$1,
	ordf: ordf$1$1,
	ordm: ordm$1$1,
	origof: origof$1,
	oror: oror$1,
	orslope: orslope$1,
	orv: orv$1,
	oS: oS$1,
	Oscr: Oscr$1,
	oscr: oscr$1,
	Oslash: Oslash$1$1,
	oslash: oslash$1$1,
	osol: osol$1,
	Otilde: Otilde$1$1,
	otilde: otilde$1$1,
	otimesas: otimesas$1,
	Otimes: Otimes$1,
	otimes: otimes$1,
	Ouml: Ouml$1$1,
	ouml: ouml$1$1,
	ovbar: ovbar$1,
	OverBar: OverBar$1,
	OverBrace: OverBrace$1,
	OverBracket: OverBracket$1,
	OverParenthesis: OverParenthesis$1,
	para: para$1$1,
	parallel: parallel$1,
	par: par$1,
	parsim: parsim$1,
	parsl: parsl$1,
	part: part$1,
	PartialD: PartialD$1,
	Pcy: Pcy$1,
	pcy: pcy$1,
	percnt: percnt$1,
	period: period$1,
	permil: permil$1,
	perp: perp$1,
	pertenk: pertenk$1,
	Pfr: Pfr$1,
	pfr: pfr$1,
	Phi: Phi$1,
	phi: phi$1,
	phiv: phiv$1,
	phmmat: phmmat$1,
	phone: phone$1,
	Pi: Pi$1,
	pi: pi$1,
	pitchfork: pitchfork$1,
	piv: piv$1,
	planck: planck$1,
	planckh: planckh$1,
	plankv: plankv$1,
	plusacir: plusacir$1,
	plusb: plusb$1,
	pluscir: pluscir$1,
	plus: plus$1,
	plusdo: plusdo$1,
	plusdu: plusdu$1,
	pluse: pluse$1,
	PlusMinus: PlusMinus$1,
	plusmn: plusmn$1$1,
	plussim: plussim$1,
	plustwo: plustwo$1,
	pm: pm$1,
	Poincareplane: Poincareplane$1,
	pointint: pointint$1,
	popf: popf$1,
	Popf: Popf$1,
	pound: pound$1$1,
	prap: prap$1,
	Pr: Pr$1,
	pr: pr$1,
	prcue: prcue$1,
	precapprox: precapprox$1,
	prec: prec$1,
	preccurlyeq: preccurlyeq$1,
	Precedes: Precedes$1,
	PrecedesEqual: PrecedesEqual$1,
	PrecedesSlantEqual: PrecedesSlantEqual$1,
	PrecedesTilde: PrecedesTilde$1,
	preceq: preceq$1,
	precnapprox: precnapprox$1,
	precneqq: precneqq$1,
	precnsim: precnsim$1,
	pre: pre$1,
	prE: prE$1,
	precsim: precsim$1,
	prime: prime$1,
	Prime: Prime$1,
	primes: primes$1,
	prnap: prnap$1,
	prnE: prnE$1,
	prnsim: prnsim$1,
	prod: prod$1,
	Product: Product$1,
	profalar: profalar$1,
	profline: profline$1,
	profsurf: profsurf$1,
	prop: prop$1,
	Proportional: Proportional$1,
	Proportion: Proportion$1,
	propto: propto$1,
	prsim: prsim$1,
	prurel: prurel$1,
	Pscr: Pscr$1,
	pscr: pscr$1,
	Psi: Psi$1,
	psi: psi$1,
	puncsp: puncsp$1,
	Qfr: Qfr$1,
	qfr: qfr$1,
	qint: qint$1,
	qopf: qopf$1,
	Qopf: Qopf$1,
	qprime: qprime$1,
	Qscr: Qscr$1,
	qscr: qscr$1,
	quaternions: quaternions$1,
	quatint: quatint$1,
	quest: quest$1,
	questeq: questeq$1,
	quot: quot$1$2,
	QUOT: QUOT$1$1,
	rAarr: rAarr$1,
	race: race$1,
	Racute: Racute$1,
	racute: racute$1,
	radic: radic$1,
	raemptyv: raemptyv$1,
	rang: rang$1,
	Rang: Rang$1,
	rangd: rangd$1,
	range: range$1,
	rangle: rangle$1,
	raquo: raquo$1$1,
	rarrap: rarrap$1,
	rarrb: rarrb$1,
	rarrbfs: rarrbfs$1,
	rarrc: rarrc$1,
	rarr: rarr$1,
	Rarr: Rarr$1,
	rArr: rArr$1,
	rarrfs: rarrfs$1,
	rarrhk: rarrhk$1,
	rarrlp: rarrlp$1,
	rarrpl: rarrpl$1,
	rarrsim: rarrsim$1,
	Rarrtl: Rarrtl$1,
	rarrtl: rarrtl$1,
	rarrw: rarrw$1,
	ratail: ratail$1,
	rAtail: rAtail$1,
	ratio: ratio$1,
	rationals: rationals$1,
	rbarr: rbarr$1,
	rBarr: rBarr$1,
	RBarr: RBarr$1,
	rbbrk: rbbrk$1,
	rbrace: rbrace$1,
	rbrack: rbrack$1,
	rbrke: rbrke$1,
	rbrksld: rbrksld$1,
	rbrkslu: rbrkslu$1,
	Rcaron: Rcaron$1,
	rcaron: rcaron$1,
	Rcedil: Rcedil$1,
	rcedil: rcedil$1,
	rceil: rceil$1,
	rcub: rcub$1,
	Rcy: Rcy$1,
	rcy: rcy$1,
	rdca: rdca$1,
	rdldhar: rdldhar$1,
	rdquo: rdquo$1,
	rdquor: rdquor$1,
	rdsh: rdsh$1,
	real: real$1,
	realine: realine$1,
	realpart: realpart$1,
	reals: reals$1,
	Re: Re$1,
	rect: rect$1,
	reg: reg$1$1,
	REG: REG$1$1,
	ReverseElement: ReverseElement$1,
	ReverseEquilibrium: ReverseEquilibrium$1,
	ReverseUpEquilibrium: ReverseUpEquilibrium$1,
	rfisht: rfisht$1,
	rfloor: rfloor$1,
	rfr: rfr$1,
	Rfr: Rfr$1,
	rHar: rHar$1,
	rhard: rhard$1,
	rharu: rharu$1,
	rharul: rharul$1,
	Rho: Rho$1,
	rho: rho$1,
	rhov: rhov$1,
	RightAngleBracket: RightAngleBracket$1,
	RightArrowBar: RightArrowBar$1,
	rightarrow: rightarrow$1,
	RightArrow: RightArrow$1,
	Rightarrow: Rightarrow$1,
	RightArrowLeftArrow: RightArrowLeftArrow$1,
	rightarrowtail: rightarrowtail$1,
	RightCeiling: RightCeiling$1,
	RightDoubleBracket: RightDoubleBracket$1,
	RightDownTeeVector: RightDownTeeVector$1,
	RightDownVectorBar: RightDownVectorBar$1,
	RightDownVector: RightDownVector$1,
	RightFloor: RightFloor$1,
	rightharpoondown: rightharpoondown$1,
	rightharpoonup: rightharpoonup$1,
	rightleftarrows: rightleftarrows$1,
	rightleftharpoons: rightleftharpoons$1,
	rightrightarrows: rightrightarrows$1,
	rightsquigarrow: rightsquigarrow$1,
	RightTeeArrow: RightTeeArrow$1,
	RightTee: RightTee$1,
	RightTeeVector: RightTeeVector$1,
	rightthreetimes: rightthreetimes$1,
	RightTriangleBar: RightTriangleBar$1,
	RightTriangle: RightTriangle$1,
	RightTriangleEqual: RightTriangleEqual$1,
	RightUpDownVector: RightUpDownVector$1,
	RightUpTeeVector: RightUpTeeVector$1,
	RightUpVectorBar: RightUpVectorBar$1,
	RightUpVector: RightUpVector$1,
	RightVectorBar: RightVectorBar$1,
	RightVector: RightVector$1,
	ring: ring$1,
	risingdotseq: risingdotseq$1,
	rlarr: rlarr$1,
	rlhar: rlhar$1,
	rlm: rlm$1,
	rmoustache: rmoustache$1,
	rmoust: rmoust$1,
	rnmid: rnmid$1,
	roang: roang$1,
	roarr: roarr$1,
	robrk: robrk$1,
	ropar: ropar$1,
	ropf: ropf$1,
	Ropf: Ropf$1,
	roplus: roplus$1,
	rotimes: rotimes$1,
	RoundImplies: RoundImplies$1,
	rpar: rpar$1,
	rpargt: rpargt$1,
	rppolint: rppolint$1,
	rrarr: rrarr$1,
	Rrightarrow: Rrightarrow$1,
	rsaquo: rsaquo$1,
	rscr: rscr$1,
	Rscr: Rscr$1,
	rsh: rsh$1,
	Rsh: Rsh$1,
	rsqb: rsqb$1,
	rsquo: rsquo$1,
	rsquor: rsquor$1,
	rthree: rthree$1,
	rtimes: rtimes$1,
	rtri: rtri$1,
	rtrie: rtrie$1,
	rtrif: rtrif$1,
	rtriltri: rtriltri$1,
	RuleDelayed: RuleDelayed$1,
	ruluhar: ruluhar$1,
	rx: rx$1,
	Sacute: Sacute$1,
	sacute: sacute$1,
	sbquo: sbquo$1,
	scap: scap$1,
	Scaron: Scaron$1,
	scaron: scaron$1,
	Sc: Sc$1,
	sc: sc$1,
	sccue: sccue$1,
	sce: sce$1,
	scE: scE$1,
	Scedil: Scedil$1,
	scedil: scedil$1,
	Scirc: Scirc$1,
	scirc: scirc$1,
	scnap: scnap$1,
	scnE: scnE$1,
	scnsim: scnsim$1,
	scpolint: scpolint$1,
	scsim: scsim$1,
	Scy: Scy$1,
	scy: scy$1,
	sdotb: sdotb$1,
	sdot: sdot$1,
	sdote: sdote$1,
	searhk: searhk$1,
	searr: searr$1,
	seArr: seArr$1,
	searrow: searrow$1,
	sect: sect$1$1,
	semi: semi$1,
	seswar: seswar$1,
	setminus: setminus$1,
	setmn: setmn$1,
	sext: sext$1,
	Sfr: Sfr$1,
	sfr: sfr$1,
	sfrown: sfrown$1,
	sharp: sharp$1,
	SHCHcy: SHCHcy$1,
	shchcy: shchcy$1,
	SHcy: SHcy$1,
	shcy: shcy$1,
	ShortDownArrow: ShortDownArrow$1,
	ShortLeftArrow: ShortLeftArrow$1,
	shortmid: shortmid$1,
	shortparallel: shortparallel$1,
	ShortRightArrow: ShortRightArrow$1,
	ShortUpArrow: ShortUpArrow$1,
	shy: shy$1$1,
	Sigma: Sigma$1,
	sigma: sigma$1,
	sigmaf: sigmaf$1,
	sigmav: sigmav$1,
	sim: sim$1,
	simdot: simdot$1,
	sime: sime$1,
	simeq: simeq$1,
	simg: simg$1,
	simgE: simgE$1,
	siml: siml$1,
	simlE: simlE$1,
	simne: simne$1,
	simplus: simplus$1,
	simrarr: simrarr$1,
	slarr: slarr$1,
	SmallCircle: SmallCircle$1,
	smallsetminus: smallsetminus$1,
	smashp: smashp$1,
	smeparsl: smeparsl$1,
	smid: smid$1,
	smile: smile$1,
	smt: smt$1,
	smte: smte$1,
	smtes: smtes$1,
	SOFTcy: SOFTcy$1,
	softcy: softcy$1,
	solbar: solbar$1,
	solb: solb$1,
	sol: sol$1,
	Sopf: Sopf$1,
	sopf: sopf$1,
	spades: spades$1,
	spadesuit: spadesuit$1,
	spar: spar$1,
	sqcap: sqcap$1,
	sqcaps: sqcaps$1,
	sqcup: sqcup$1,
	sqcups: sqcups$1,
	Sqrt: Sqrt$1,
	sqsub: sqsub$1,
	sqsube: sqsube$1,
	sqsubset: sqsubset$1,
	sqsubseteq: sqsubseteq$1,
	sqsup: sqsup$1,
	sqsupe: sqsupe$1,
	sqsupset: sqsupset$1,
	sqsupseteq: sqsupseteq$1,
	square: square$1,
	Square: Square$1,
	SquareIntersection: SquareIntersection$1,
	SquareSubset: SquareSubset$1,
	SquareSubsetEqual: SquareSubsetEqual$1,
	SquareSuperset: SquareSuperset$1,
	SquareSupersetEqual: SquareSupersetEqual$1,
	SquareUnion: SquareUnion$1,
	squarf: squarf$1,
	squ: squ$1,
	squf: squf$1,
	srarr: srarr$1,
	Sscr: Sscr$1,
	sscr: sscr$1,
	ssetmn: ssetmn$1,
	ssmile: ssmile$1,
	sstarf: sstarf$1,
	Star: Star$1,
	star: star$1,
	starf: starf$1,
	straightepsilon: straightepsilon$1,
	straightphi: straightphi$1,
	strns: strns$1,
	sub: sub$1,
	Sub: Sub$1,
	subdot: subdot$1,
	subE: subE$1,
	sube: sube$1,
	subedot: subedot$1,
	submult: submult$1,
	subnE: subnE$1,
	subne: subne$1,
	subplus: subplus$1,
	subrarr: subrarr$1,
	subset: subset$1,
	Subset: Subset$1,
	subseteq: subseteq$1,
	subseteqq: subseteqq$1,
	SubsetEqual: SubsetEqual$1,
	subsetneq: subsetneq$1,
	subsetneqq: subsetneqq$1,
	subsim: subsim$1,
	subsub: subsub$1,
	subsup: subsup$1,
	succapprox: succapprox$1,
	succ: succ$1,
	succcurlyeq: succcurlyeq$1,
	Succeeds: Succeeds$1,
	SucceedsEqual: SucceedsEqual$1,
	SucceedsSlantEqual: SucceedsSlantEqual$1,
	SucceedsTilde: SucceedsTilde$1,
	succeq: succeq$1,
	succnapprox: succnapprox$1,
	succneqq: succneqq$1,
	succnsim: succnsim$1,
	succsim: succsim$1,
	SuchThat: SuchThat$1,
	sum: sum$1,
	Sum: Sum$1,
	sung: sung$1,
	sup1: sup1$1$1,
	sup2: sup2$1$1,
	sup3: sup3$1$1,
	sup: sup$1,
	Sup: Sup$1,
	supdot: supdot$1,
	supdsub: supdsub$1,
	supE: supE$1,
	supe: supe$1,
	supedot: supedot$1,
	Superset: Superset$1,
	SupersetEqual: SupersetEqual$1,
	suphsol: suphsol$1,
	suphsub: suphsub$1,
	suplarr: suplarr$1,
	supmult: supmult$1,
	supnE: supnE$1,
	supne: supne$1,
	supplus: supplus$1,
	supset: supset$1,
	Supset: Supset$1,
	supseteq: supseteq$1,
	supseteqq: supseteqq$1,
	supsetneq: supsetneq$1,
	supsetneqq: supsetneqq$1,
	supsim: supsim$1,
	supsub: supsub$1,
	supsup: supsup$1,
	swarhk: swarhk$1,
	swarr: swarr$1,
	swArr: swArr$1,
	swarrow: swarrow$1,
	swnwar: swnwar$1,
	szlig: szlig$1$1,
	Tab: Tab$1,
	target: target$1,
	Tau: Tau$1,
	tau: tau$1,
	tbrk: tbrk$1,
	Tcaron: Tcaron$1,
	tcaron: tcaron$1,
	Tcedil: Tcedil$1,
	tcedil: tcedil$1,
	Tcy: Tcy$1,
	tcy: tcy$1,
	tdot: tdot$1,
	telrec: telrec$1,
	Tfr: Tfr$1,
	tfr: tfr$1,
	there4: there4$1,
	therefore: therefore$1,
	Therefore: Therefore$1,
	Theta: Theta$1,
	theta: theta$1,
	thetasym: thetasym$1,
	thetav: thetav$1,
	thickapprox: thickapprox$1,
	thicksim: thicksim$1,
	ThickSpace: ThickSpace$1,
	ThinSpace: ThinSpace$1,
	thinsp: thinsp$1,
	thkap: thkap$1,
	thksim: thksim$1,
	THORN: THORN$1$1,
	thorn: thorn$1$1,
	tilde: tilde$1,
	Tilde: Tilde$1,
	TildeEqual: TildeEqual$1,
	TildeFullEqual: TildeFullEqual$1,
	TildeTilde: TildeTilde$1,
	timesbar: timesbar$1,
	timesb: timesb$1,
	times: times$2,
	timesd: timesd$1,
	tint: tint$1,
	toea: toea$1,
	topbot: topbot$1,
	topcir: topcir$1,
	top: top$1,
	Topf: Topf$1,
	topf: topf$1,
	topfork: topfork$1,
	tosa: tosa$1,
	tprime: tprime$1,
	trade: trade$1,
	TRADE: TRADE$1,
	triangle: triangle$1,
	triangledown: triangledown$1,
	triangleleft: triangleleft$1,
	trianglelefteq: trianglelefteq$1,
	triangleq: triangleq$1,
	triangleright: triangleright$1,
	trianglerighteq: trianglerighteq$1,
	tridot: tridot$1,
	trie: trie$1,
	triminus: triminus$1,
	TripleDot: TripleDot$1,
	triplus: triplus$1,
	trisb: trisb$1,
	tritime: tritime$1,
	trpezium: trpezium$1,
	Tscr: Tscr$1,
	tscr: tscr$1,
	TScy: TScy$1,
	tscy: tscy$1,
	TSHcy: TSHcy$1,
	tshcy: tshcy$1,
	Tstrok: Tstrok$1,
	tstrok: tstrok$1,
	twixt: twixt$1,
	twoheadleftarrow: twoheadleftarrow$1,
	twoheadrightarrow: twoheadrightarrow$1,
	Uacute: Uacute$1$1,
	uacute: uacute$1$1,
	uarr: uarr$1,
	Uarr: Uarr$1,
	uArr: uArr$1,
	Uarrocir: Uarrocir$1,
	Ubrcy: Ubrcy$1,
	ubrcy: ubrcy$1,
	Ubreve: Ubreve$1,
	ubreve: ubreve$1,
	Ucirc: Ucirc$1$1,
	ucirc: ucirc$1$1,
	Ucy: Ucy$1,
	ucy: ucy$1,
	udarr: udarr$1,
	Udblac: Udblac$1,
	udblac: udblac$1,
	udhar: udhar$1,
	ufisht: ufisht$1,
	Ufr: Ufr$1,
	ufr: ufr$1,
	Ugrave: Ugrave$1$1,
	ugrave: ugrave$1$1,
	uHar: uHar$1,
	uharl: uharl$1,
	uharr: uharr$1,
	uhblk: uhblk$1,
	ulcorn: ulcorn$1,
	ulcorner: ulcorner$1,
	ulcrop: ulcrop$1,
	ultri: ultri$1,
	Umacr: Umacr$1,
	umacr: umacr$1,
	uml: uml$1$1,
	UnderBar: UnderBar$1,
	UnderBrace: UnderBrace$1,
	UnderBracket: UnderBracket$1,
	UnderParenthesis: UnderParenthesis$1,
	Union: Union$1,
	UnionPlus: UnionPlus$1,
	Uogon: Uogon$1,
	uogon: uogon$1,
	Uopf: Uopf$1,
	uopf: uopf$1,
	UpArrowBar: UpArrowBar$1,
	uparrow: uparrow$1,
	UpArrow: UpArrow$1,
	Uparrow: Uparrow$1,
	UpArrowDownArrow: UpArrowDownArrow$1,
	updownarrow: updownarrow$1,
	UpDownArrow: UpDownArrow$1,
	Updownarrow: Updownarrow$1,
	UpEquilibrium: UpEquilibrium$1,
	upharpoonleft: upharpoonleft$1,
	upharpoonright: upharpoonright$1,
	uplus: uplus$1,
	UpperLeftArrow: UpperLeftArrow$1,
	UpperRightArrow: UpperRightArrow$1,
	upsi: upsi$1,
	Upsi: Upsi$1,
	upsih: upsih$1,
	Upsilon: Upsilon$1,
	upsilon: upsilon$1,
	UpTeeArrow: UpTeeArrow$1,
	UpTee: UpTee$1,
	upuparrows: upuparrows$1,
	urcorn: urcorn$1,
	urcorner: urcorner$1,
	urcrop: urcrop$1,
	Uring: Uring$1,
	uring: uring$1,
	urtri: urtri$1,
	Uscr: Uscr$1,
	uscr: uscr$1,
	utdot: utdot$1,
	Utilde: Utilde$1,
	utilde: utilde$1,
	utri: utri$1,
	utrif: utrif$1,
	uuarr: uuarr$1,
	Uuml: Uuml$1$1,
	uuml: uuml$1$1,
	uwangle: uwangle$1,
	vangrt: vangrt$1,
	varepsilon: varepsilon$1,
	varkappa: varkappa$1,
	varnothing: varnothing$1,
	varphi: varphi$1,
	varpi: varpi$1,
	varpropto: varpropto$1,
	varr: varr$1,
	vArr: vArr$1,
	varrho: varrho$1,
	varsigma: varsigma$1,
	varsubsetneq: varsubsetneq$1,
	varsubsetneqq: varsubsetneqq$1,
	varsupsetneq: varsupsetneq$1,
	varsupsetneqq: varsupsetneqq$1,
	vartheta: vartheta$1,
	vartriangleleft: vartriangleleft$1,
	vartriangleright: vartriangleright$1,
	vBar: vBar$1,
	Vbar: Vbar$1,
	vBarv: vBarv$1,
	Vcy: Vcy$1,
	vcy: vcy$1,
	vdash: vdash$1,
	vDash: vDash$1,
	Vdash: Vdash$1,
	VDash: VDash$1,
	Vdashl: Vdashl$1,
	veebar: veebar$1,
	vee: vee$1,
	Vee: Vee$1,
	veeeq: veeeq$1,
	vellip: vellip$1,
	verbar: verbar$1,
	Verbar: Verbar$1,
	vert: vert$1,
	Vert: Vert$1,
	VerticalBar: VerticalBar$1,
	VerticalLine: VerticalLine$1,
	VerticalSeparator: VerticalSeparator$1,
	VerticalTilde: VerticalTilde$1,
	VeryThinSpace: VeryThinSpace$1,
	Vfr: Vfr$1,
	vfr: vfr$1,
	vltri: vltri$1,
	vnsub: vnsub$1,
	vnsup: vnsup$1,
	Vopf: Vopf$1,
	vopf: vopf$1,
	vprop: vprop$1,
	vrtri: vrtri$1,
	Vscr: Vscr$1,
	vscr: vscr$1,
	vsubnE: vsubnE$1,
	vsubne: vsubne$1,
	vsupnE: vsupnE$1,
	vsupne: vsupne$1,
	Vvdash: Vvdash$1,
	vzigzag: vzigzag$1,
	Wcirc: Wcirc$1,
	wcirc: wcirc$1,
	wedbar: wedbar$1,
	wedge: wedge$1,
	Wedge: Wedge$1,
	wedgeq: wedgeq$1,
	weierp: weierp$1,
	Wfr: Wfr$1,
	wfr: wfr$1,
	Wopf: Wopf$1,
	wopf: wopf$1,
	wp: wp$1,
	wr: wr$1,
	wreath: wreath$1,
	Wscr: Wscr$1,
	wscr: wscr$1,
	xcap: xcap$1,
	xcirc: xcirc$1,
	xcup: xcup$1,
	xdtri: xdtri$1,
	Xfr: Xfr$1,
	xfr: xfr$1,
	xharr: xharr$1,
	xhArr: xhArr$1,
	Xi: Xi$1,
	xi: xi$1,
	xlarr: xlarr$1,
	xlArr: xlArr$1,
	xmap: xmap$1,
	xnis: xnis$1,
	xodot: xodot$1,
	Xopf: Xopf$1,
	xopf: xopf$1,
	xoplus: xoplus$1,
	xotime: xotime$1,
	xrarr: xrarr$1,
	xrArr: xrArr$1,
	Xscr: Xscr$1,
	xscr: xscr$1,
	xsqcup: xsqcup$1,
	xuplus: xuplus$1,
	xutri: xutri$1,
	xvee: xvee$1,
	xwedge: xwedge$1,
	Yacute: Yacute$1$1,
	yacute: yacute$1$1,
	YAcy: YAcy$1,
	yacy: yacy$1,
	Ycirc: Ycirc$1,
	ycirc: ycirc$1,
	Ycy: Ycy$1,
	ycy: ycy$1,
	yen: yen$1$1,
	Yfr: Yfr$1,
	yfr: yfr$1,
	YIcy: YIcy$1,
	yicy: yicy$1,
	Yopf: Yopf$1,
	yopf: yopf$1,
	Yscr: Yscr$1,
	yscr: yscr$1,
	YUcy: YUcy$1,
	yucy: yucy$1,
	yuml: yuml$1$1,
	Yuml: Yuml$1,
	Zacute: Zacute$1,
	zacute: zacute$1,
	Zcaron: Zcaron$1,
	zcaron: zcaron$1,
	Zcy: Zcy$1,
	zcy: zcy$1,
	Zdot: Zdot$1,
	zdot: zdot$1,
	zeetrf: zeetrf$1,
	ZeroWidthSpace: ZeroWidthSpace$1,
	Zeta: Zeta$1,
	zeta: zeta$1,
	zfr: zfr$1,
	Zfr: Zfr$1,
	ZHcy: ZHcy$1,
	zhcy: zhcy$1,
	zigrarr: zigrarr$1,
	zopf: zopf$1,
	Zopf: Zopf$1,
	Zscr: Zscr$1,
	zscr: zscr$1,
	zwj: zwj$1,
	zwnj: zwnj$1,
	"in": "",
	"Map": ""
};

var entities$2 = Object.freeze({
	Aacute: Aacute$1$1,
	aacute: aacute$1$1,
	Abreve: Abreve$1,
	abreve: abreve$1,
	ac: ac$1,
	acd: acd$1,
	acE: acE$1,
	Acirc: Acirc$1$1,
	acirc: acirc$1$1,
	acute: acute$1$1,
	Acy: Acy$1,
	acy: acy$1,
	AElig: AElig$1$1,
	aelig: aelig$1$1,
	af: af$1,
	Afr: Afr$1,
	afr: afr$1,
	Agrave: Agrave$1$1,
	agrave: agrave$1$1,
	alefsym: alefsym$1,
	aleph: aleph$1,
	Alpha: Alpha$1,
	alpha: alpha$1,
	Amacr: Amacr$1,
	amacr: amacr$1,
	amalg: amalg$1,
	amp: amp$1$2,
	AMP: AMP$1$1,
	andand: andand$1,
	And: And$1,
	and: and$1,
	andd: andd$1,
	andslope: andslope$1,
	andv: andv$1,
	ang: ang$1,
	ange: ange$1,
	angle: angle$1,
	angmsdaa: angmsdaa$1,
	angmsdab: angmsdab$1,
	angmsdac: angmsdac$1,
	angmsdad: angmsdad$1,
	angmsdae: angmsdae$1,
	angmsdaf: angmsdaf$1,
	angmsdag: angmsdag$1,
	angmsdah: angmsdah$1,
	angmsd: angmsd$1,
	angrt: angrt$1,
	angrtvb: angrtvb$1,
	angrtvbd: angrtvbd$1,
	angsph: angsph$1,
	angst: angst$1,
	angzarr: angzarr$1,
	Aogon: Aogon$1,
	aogon: aogon$1,
	Aopf: Aopf$1,
	aopf: aopf$1,
	apacir: apacir$1,
	ap: ap$1,
	apE: apE$1,
	ape: ape$1,
	apid: apid$1,
	apos: apos$1$2,
	ApplyFunction: ApplyFunction$1,
	approx: approx$1,
	approxeq: approxeq$1,
	Aring: Aring$1$1,
	aring: aring$1$1,
	Ascr: Ascr$1,
	ascr: ascr$1,
	Assign: Assign$1,
	ast: ast$1,
	asymp: asymp$1,
	asympeq: asympeq$1,
	Atilde: Atilde$1$1,
	atilde: atilde$1$1,
	Auml: Auml$1$1,
	auml: auml$1$1,
	awconint: awconint$1,
	awint: awint$1,
	backcong: backcong$1,
	backepsilon: backepsilon$1,
	backprime: backprime$1,
	backsim: backsim$1,
	backsimeq: backsimeq$1,
	Backslash: Backslash$1,
	Barv: Barv$1,
	barvee: barvee$1,
	barwed: barwed$1,
	Barwed: Barwed$1,
	barwedge: barwedge$1,
	bbrk: bbrk$1,
	bbrktbrk: bbrktbrk$1,
	bcong: bcong$1,
	Bcy: Bcy$1,
	bcy: bcy$1,
	bdquo: bdquo$1,
	becaus: becaus$1,
	because: because$1,
	Because: Because$1,
	bemptyv: bemptyv$1,
	bepsi: bepsi$1,
	bernou: bernou$1,
	Bernoullis: Bernoullis$1,
	Beta: Beta$1,
	beta: beta$1,
	beth: beth$1,
	between: between$1,
	Bfr: Bfr$1,
	bfr: bfr$1,
	bigcap: bigcap$1,
	bigcirc: bigcirc$1,
	bigcup: bigcup$1,
	bigodot: bigodot$1,
	bigoplus: bigoplus$1,
	bigotimes: bigotimes$1,
	bigsqcup: bigsqcup$1,
	bigstar: bigstar$1,
	bigtriangledown: bigtriangledown$1,
	bigtriangleup: bigtriangleup$1,
	biguplus: biguplus$1,
	bigvee: bigvee$1,
	bigwedge: bigwedge$1,
	bkarow: bkarow$1,
	blacklozenge: blacklozenge$1,
	blacksquare: blacksquare$1,
	blacktriangle: blacktriangle$1,
	blacktriangledown: blacktriangledown$1,
	blacktriangleleft: blacktriangleleft$1,
	blacktriangleright: blacktriangleright$1,
	blank: blank$1,
	blk12: blk12$1,
	blk14: blk14$1,
	blk34: blk34$1,
	block: block$1,
	bne: bne$1,
	bnequiv: bnequiv$1,
	bNot: bNot$1,
	bnot: bnot$1,
	Bopf: Bopf$1,
	bopf: bopf$1,
	bot: bot$1,
	bottom: bottom$1,
	bowtie: bowtie$1,
	boxbox: boxbox$1,
	boxdl: boxdl$1,
	boxdL: boxdL$1,
	boxDl: boxDl$1,
	boxDL: boxDL$1,
	boxdr: boxdr$1,
	boxdR: boxdR$1,
	boxDr: boxDr$1,
	boxDR: boxDR$1,
	boxh: boxh$1,
	boxH: boxH$1,
	boxhd: boxhd$1,
	boxHd: boxHd$1,
	boxhD: boxhD$1,
	boxHD: boxHD$1,
	boxhu: boxhu$1,
	boxHu: boxHu$1,
	boxhU: boxhU$1,
	boxHU: boxHU$1,
	boxminus: boxminus$1,
	boxplus: boxplus$1,
	boxtimes: boxtimes$1,
	boxul: boxul$1,
	boxuL: boxuL$1,
	boxUl: boxUl$1,
	boxUL: boxUL$1,
	boxur: boxur$1,
	boxuR: boxuR$1,
	boxUr: boxUr$1,
	boxUR: boxUR$1,
	boxv: boxv$1,
	boxV: boxV$1,
	boxvh: boxvh$1,
	boxvH: boxvH$1,
	boxVh: boxVh$1,
	boxVH: boxVH$1,
	boxvl: boxvl$1,
	boxvL: boxvL$1,
	boxVl: boxVl$1,
	boxVL: boxVL$1,
	boxvr: boxvr$1,
	boxvR: boxvR$1,
	boxVr: boxVr$1,
	boxVR: boxVR$1,
	bprime: bprime$1,
	breve: breve$1,
	Breve: Breve$1,
	brvbar: brvbar$1$1,
	bscr: bscr$1,
	Bscr: Bscr$1,
	bsemi: bsemi$1,
	bsim: bsim$1,
	bsime: bsime$1,
	bsolb: bsolb$1,
	bsol: bsol$1,
	bsolhsub: bsolhsub$1,
	bull: bull$1,
	bullet: bullet$1,
	bump: bump$1,
	bumpE: bumpE$1,
	bumpe: bumpe$1,
	Bumpeq: Bumpeq$1,
	bumpeq: bumpeq$1,
	Cacute: Cacute$1,
	cacute: cacute$1,
	capand: capand$1,
	capbrcup: capbrcup$1,
	capcap: capcap$1,
	cap: cap$1,
	Cap: Cap$1,
	capcup: capcup$1,
	capdot: capdot$1,
	CapitalDifferentialD: CapitalDifferentialD$1,
	caps: caps$1,
	caret: caret$1,
	caron: caron$1,
	Cayleys: Cayleys$1,
	ccaps: ccaps$1,
	Ccaron: Ccaron$1,
	ccaron: ccaron$1,
	Ccedil: Ccedil$1$1,
	ccedil: ccedil$1$1,
	Ccirc: Ccirc$1,
	ccirc: ccirc$1,
	Cconint: Cconint$1,
	ccups: ccups$1,
	ccupssm: ccupssm$1,
	Cdot: Cdot$1,
	cdot: cdot$1,
	cedil: cedil$1$1,
	Cedilla: Cedilla$1,
	cemptyv: cemptyv$1,
	cent: cent$1$1,
	centerdot: centerdot$1,
	CenterDot: CenterDot$1,
	cfr: cfr$1,
	Cfr: Cfr$1,
	CHcy: CHcy$1,
	chcy: chcy$1,
	check: check$1,
	checkmark: checkmark$1,
	Chi: Chi$1,
	chi: chi$1,
	circ: circ$1,
	circeq: circeq$1,
	circlearrowleft: circlearrowleft$1,
	circlearrowright: circlearrowright$1,
	circledast: circledast$1,
	circledcirc: circledcirc$1,
	circleddash: circleddash$1,
	CircleDot: CircleDot$1,
	circledR: circledR$1,
	circledS: circledS$1,
	CircleMinus: CircleMinus$1,
	CirclePlus: CirclePlus$1,
	CircleTimes: CircleTimes$1,
	cir: cir$1,
	cirE: cirE$1,
	cire: cire$1,
	cirfnint: cirfnint$1,
	cirmid: cirmid$1,
	cirscir: cirscir$1,
	ClockwiseContourIntegral: ClockwiseContourIntegral$1,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote$1,
	CloseCurlyQuote: CloseCurlyQuote$1,
	clubs: clubs$1,
	clubsuit: clubsuit$1,
	colon: colon$1,
	Colon: Colon$1,
	Colone: Colone$1,
	colone: colone$1,
	coloneq: coloneq$1,
	comma: comma$1,
	commat: commat$1,
	comp: comp$1,
	compfn: compfn$1,
	complement: complement$1,
	complexes: complexes$1,
	cong: cong$1,
	congdot: congdot$1,
	Congruent: Congruent$1,
	conint: conint$1,
	Conint: Conint$1,
	ContourIntegral: ContourIntegral$1,
	copf: copf$1,
	Copf: Copf$1,
	coprod: coprod$1,
	Coproduct: Coproduct$1,
	copy: copy$1$1,
	COPY: COPY$1$1,
	copysr: copysr$1,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral$1,
	crarr: crarr$1,
	cross: cross$1,
	Cross: Cross$1,
	Cscr: Cscr$1,
	cscr: cscr$1,
	csub: csub$1,
	csube: csube$1,
	csup: csup$1,
	csupe: csupe$1,
	ctdot: ctdot$1,
	cudarrl: cudarrl$1,
	cudarrr: cudarrr$1,
	cuepr: cuepr$1,
	cuesc: cuesc$1,
	cularr: cularr$1,
	cularrp: cularrp$1,
	cupbrcap: cupbrcap$1,
	cupcap: cupcap$1,
	CupCap: CupCap$1,
	cup: cup$1,
	Cup: Cup$1,
	cupcup: cupcup$1,
	cupdot: cupdot$1,
	cupor: cupor$1,
	cups: cups$1,
	curarr: curarr$1,
	curarrm: curarrm$1,
	curlyeqprec: curlyeqprec$1,
	curlyeqsucc: curlyeqsucc$1,
	curlyvee: curlyvee$1,
	curlywedge: curlywedge$1,
	curren: curren$1$1,
	curvearrowleft: curvearrowleft$1,
	curvearrowright: curvearrowright$1,
	cuvee: cuvee$1,
	cuwed: cuwed$1,
	cwconint: cwconint$1,
	cwint: cwint$1,
	cylcty: cylcty$1,
	dagger: dagger$1,
	Dagger: Dagger$1,
	daleth: daleth$1,
	darr: darr$1,
	Darr: Darr$1,
	dArr: dArr$1,
	dash: dash$1,
	Dashv: Dashv$1,
	dashv: dashv$1,
	dbkarow: dbkarow$1,
	dblac: dblac$1,
	Dcaron: Dcaron$1,
	dcaron: dcaron$1,
	Dcy: Dcy$1,
	dcy: dcy$1,
	ddagger: ddagger$1,
	ddarr: ddarr$1,
	DD: DD$1,
	dd: dd$1,
	DDotrahd: DDotrahd$1,
	ddotseq: ddotseq$1,
	deg: deg$1$1,
	Del: Del$1,
	Delta: Delta$1,
	delta: delta$1,
	demptyv: demptyv$1,
	dfisht: dfisht$1,
	Dfr: Dfr$1,
	dfr: dfr$1,
	dHar: dHar$1,
	dharl: dharl$1,
	dharr: dharr$1,
	DiacriticalAcute: DiacriticalAcute$1,
	DiacriticalDot: DiacriticalDot$1,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute$1,
	DiacriticalGrave: DiacriticalGrave$1,
	DiacriticalTilde: DiacriticalTilde$1,
	diam: diam$1,
	diamond: diamond$1,
	Diamond: Diamond$1,
	diamondsuit: diamondsuit$1,
	diams: diams$1,
	die: die$1,
	DifferentialD: DifferentialD$1,
	digamma: digamma$1,
	disin: disin$1,
	div: div$1,
	divide: divide$1$1,
	divideontimes: divideontimes$1,
	divonx: divonx$1,
	DJcy: DJcy$1,
	djcy: djcy$1,
	dlcorn: dlcorn$1,
	dlcrop: dlcrop$1,
	dollar: dollar$1,
	Dopf: Dopf$1,
	dopf: dopf$1,
	Dot: Dot$1,
	dot: dot$1,
	DotDot: DotDot$1,
	doteq: doteq$1,
	doteqdot: doteqdot$1,
	DotEqual: DotEqual$1,
	dotminus: dotminus$1,
	dotplus: dotplus$1,
	dotsquare: dotsquare$1,
	doublebarwedge: doublebarwedge$1,
	DoubleContourIntegral: DoubleContourIntegral$1,
	DoubleDot: DoubleDot$1,
	DoubleDownArrow: DoubleDownArrow$1,
	DoubleLeftArrow: DoubleLeftArrow$1,
	DoubleLeftRightArrow: DoubleLeftRightArrow$1,
	DoubleLeftTee: DoubleLeftTee$1,
	DoubleLongLeftArrow: DoubleLongLeftArrow$1,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow$1,
	DoubleLongRightArrow: DoubleLongRightArrow$1,
	DoubleRightArrow: DoubleRightArrow$1,
	DoubleRightTee: DoubleRightTee$1,
	DoubleUpArrow: DoubleUpArrow$1,
	DoubleUpDownArrow: DoubleUpDownArrow$1,
	DoubleVerticalBar: DoubleVerticalBar$1,
	DownArrowBar: DownArrowBar$1,
	downarrow: downarrow$1,
	DownArrow: DownArrow$1,
	Downarrow: Downarrow$1,
	DownArrowUpArrow: DownArrowUpArrow$1,
	DownBreve: DownBreve$1,
	downdownarrows: downdownarrows$1,
	downharpoonleft: downharpoonleft$1,
	downharpoonright: downharpoonright$1,
	DownLeftRightVector: DownLeftRightVector$1,
	DownLeftTeeVector: DownLeftTeeVector$1,
	DownLeftVectorBar: DownLeftVectorBar$1,
	DownLeftVector: DownLeftVector$1,
	DownRightTeeVector: DownRightTeeVector$1,
	DownRightVectorBar: DownRightVectorBar$1,
	DownRightVector: DownRightVector$1,
	DownTeeArrow: DownTeeArrow$1,
	DownTee: DownTee$1,
	drbkarow: drbkarow$1,
	drcorn: drcorn$1,
	drcrop: drcrop$1,
	Dscr: Dscr$1,
	dscr: dscr$1,
	DScy: DScy$1,
	dscy: dscy$1,
	dsol: dsol$1,
	Dstrok: Dstrok$1,
	dstrok: dstrok$1,
	dtdot: dtdot$1,
	dtri: dtri$1,
	dtrif: dtrif$1,
	duarr: duarr$1,
	duhar: duhar$1,
	dwangle: dwangle$1,
	DZcy: DZcy$1,
	dzcy: dzcy$1,
	dzigrarr: dzigrarr$1,
	Eacute: Eacute$1$1,
	eacute: eacute$1$1,
	easter: easter$1,
	Ecaron: Ecaron$1,
	ecaron: ecaron$1,
	Ecirc: Ecirc$1$1,
	ecirc: ecirc$1$1,
	ecir: ecir$1,
	ecolon: ecolon$1,
	Ecy: Ecy$1,
	ecy: ecy$1,
	eDDot: eDDot$1,
	Edot: Edot$1,
	edot: edot$1,
	eDot: eDot$1,
	ee: ee$1,
	efDot: efDot$1,
	Efr: Efr$1,
	efr: efr$1,
	eg: eg$1,
	Egrave: Egrave$1$1,
	egrave: egrave$1$1,
	egs: egs$1,
	egsdot: egsdot$1,
	el: el$1,
	Element: Element$1,
	elinters: elinters$1,
	ell: ell$1,
	els: els$1,
	elsdot: elsdot$1,
	Emacr: Emacr$1,
	emacr: emacr$1,
	empty: empty$1,
	emptyset: emptyset$1,
	EmptySmallSquare: EmptySmallSquare$1,
	emptyv: emptyv$1,
	EmptyVerySmallSquare: EmptyVerySmallSquare$1,
	emsp13: emsp13$1,
	emsp14: emsp14$1,
	emsp: emsp$1,
	ENG: ENG$1,
	eng: eng$1,
	ensp: ensp$1,
	Eogon: Eogon$1,
	eogon: eogon$1,
	Eopf: Eopf$1,
	eopf: eopf$1,
	epar: epar$1,
	eparsl: eparsl$1,
	eplus: eplus$1,
	epsi: epsi$1,
	Epsilon: Epsilon$1,
	epsilon: epsilon$1,
	epsiv: epsiv$1,
	eqcirc: eqcirc$1,
	eqcolon: eqcolon$1,
	eqsim: eqsim$1,
	eqslantgtr: eqslantgtr$1,
	eqslantless: eqslantless$1,
	Equal: Equal$1,
	equals: equals$1,
	EqualTilde: EqualTilde$1,
	equest: equest$1,
	Equilibrium: Equilibrium$1,
	equiv: equiv$1,
	equivDD: equivDD$1,
	eqvparsl: eqvparsl$1,
	erarr: erarr$1,
	erDot: erDot$1,
	escr: escr$1,
	Escr: Escr$1,
	esdot: esdot$1,
	Esim: Esim$1,
	esim: esim$1,
	Eta: Eta$1,
	eta: eta$1,
	ETH: ETH$1$1,
	eth: eth$1$1,
	Euml: Euml$1$1,
	euml: euml$1$1,
	euro: euro$1,
	excl: excl$1,
	exist: exist$1,
	Exists: Exists$1,
	expectation: expectation$1,
	exponentiale: exponentiale$1,
	ExponentialE: ExponentialE$1,
	fallingdotseq: fallingdotseq$1,
	Fcy: Fcy$1,
	fcy: fcy$1,
	female: female$1,
	ffilig: ffilig$1,
	fflig: fflig$1,
	ffllig: ffllig$1,
	Ffr: Ffr$1,
	ffr: ffr$1,
	filig: filig$1,
	FilledSmallSquare: FilledSmallSquare$1,
	FilledVerySmallSquare: FilledVerySmallSquare$1,
	fjlig: fjlig$1,
	flat: flat$1,
	fllig: fllig$1,
	fltns: fltns$1,
	fnof: fnof$1,
	Fopf: Fopf$1,
	fopf: fopf$1,
	forall: forall$1,
	ForAll: ForAll$1,
	fork: fork$1,
	forkv: forkv$1,
	Fouriertrf: Fouriertrf$1,
	fpartint: fpartint$1,
	frac12: frac12$1$1,
	frac13: frac13$1,
	frac14: frac14$1$1,
	frac15: frac15$1,
	frac16: frac16$1,
	frac18: frac18$1,
	frac23: frac23$1,
	frac25: frac25$1,
	frac34: frac34$1$1,
	frac35: frac35$1,
	frac38: frac38$1,
	frac45: frac45$1,
	frac56: frac56$1,
	frac58: frac58$1,
	frac78: frac78$1,
	frasl: frasl$1,
	frown: frown$1,
	fscr: fscr$1,
	Fscr: Fscr$1,
	gacute: gacute$1,
	Gamma: Gamma$1,
	gamma: gamma$1,
	Gammad: Gammad$1,
	gammad: gammad$1,
	gap: gap$1,
	Gbreve: Gbreve$1,
	gbreve: gbreve$1,
	Gcedil: Gcedil$1,
	Gcirc: Gcirc$1,
	gcirc: gcirc$1,
	Gcy: Gcy$1,
	gcy: gcy$1,
	Gdot: Gdot$1,
	gdot: gdot$1,
	ge: ge$1,
	gE: gE$1,
	gEl: gEl$1,
	gel: gel$1,
	geq: geq$1,
	geqq: geqq$1,
	geqslant: geqslant$1,
	gescc: gescc$1,
	ges: ges$1,
	gesdot: gesdot$1,
	gesdoto: gesdoto$1,
	gesdotol: gesdotol$1,
	gesl: gesl$1,
	gesles: gesles$1,
	Gfr: Gfr$1,
	gfr: gfr$1,
	gg: gg$1,
	Gg: Gg$1,
	ggg: ggg$1,
	gimel: gimel$1,
	GJcy: GJcy$1,
	gjcy: gjcy$1,
	gla: gla$1,
	gl: gl$1,
	glE: glE$1,
	glj: glj$1,
	gnap: gnap$1,
	gnapprox: gnapprox$1,
	gne: gne$1,
	gnE: gnE$1,
	gneq: gneq$1,
	gneqq: gneqq$1,
	gnsim: gnsim$1,
	Gopf: Gopf$1,
	gopf: gopf$1,
	grave: grave$1,
	GreaterEqual: GreaterEqual$1,
	GreaterEqualLess: GreaterEqualLess$1,
	GreaterFullEqual: GreaterFullEqual$1,
	GreaterGreater: GreaterGreater$1,
	GreaterLess: GreaterLess$1,
	GreaterSlantEqual: GreaterSlantEqual$1,
	GreaterTilde: GreaterTilde$1,
	Gscr: Gscr$1,
	gscr: gscr$1,
	gsim: gsim$1,
	gsime: gsime$1,
	gsiml: gsiml$1,
	gtcc: gtcc$1,
	gtcir: gtcir$1,
	gt: gt$1$2,
	GT: GT$1$1,
	Gt: Gt$1,
	gtdot: gtdot$1,
	gtlPar: gtlPar$1,
	gtquest: gtquest$1,
	gtrapprox: gtrapprox$1,
	gtrarr: gtrarr$1,
	gtrdot: gtrdot$1,
	gtreqless: gtreqless$1,
	gtreqqless: gtreqqless$1,
	gtrless: gtrless$1,
	gtrsim: gtrsim$1,
	gvertneqq: gvertneqq$1,
	gvnE: gvnE$1,
	Hacek: Hacek$1,
	hairsp: hairsp$1,
	half: half$1,
	hamilt: hamilt$1,
	HARDcy: HARDcy$1,
	hardcy: hardcy$1,
	harrcir: harrcir$1,
	harr: harr$1,
	hArr: hArr$1,
	harrw: harrw$1,
	Hat: Hat$1,
	hbar: hbar$1,
	Hcirc: Hcirc$1,
	hcirc: hcirc$1,
	hearts: hearts$1,
	heartsuit: heartsuit$1,
	hellip: hellip$1,
	hercon: hercon$1,
	hfr: hfr$1,
	Hfr: Hfr$1,
	HilbertSpace: HilbertSpace$1,
	hksearow: hksearow$1,
	hkswarow: hkswarow$1,
	hoarr: hoarr$1,
	homtht: homtht$1,
	hookleftarrow: hookleftarrow$1,
	hookrightarrow: hookrightarrow$1,
	hopf: hopf$1,
	Hopf: Hopf$1,
	horbar: horbar$1,
	HorizontalLine: HorizontalLine$1,
	hscr: hscr$1,
	Hscr: Hscr$1,
	hslash: hslash$1,
	Hstrok: Hstrok$1,
	hstrok: hstrok$1,
	HumpDownHump: HumpDownHump$1,
	HumpEqual: HumpEqual$1,
	hybull: hybull$1,
	hyphen: hyphen$1,
	Iacute: Iacute$1$1,
	iacute: iacute$1$1,
	ic: ic$1,
	Icirc: Icirc$1$1,
	icirc: icirc$1$1,
	Icy: Icy$1,
	icy: icy$1,
	Idot: Idot$1,
	IEcy: IEcy$1,
	iecy: iecy$1,
	iexcl: iexcl$1$1,
	iff: iff$1,
	ifr: ifr$1,
	Ifr: Ifr$1,
	Igrave: Igrave$1$1,
	igrave: igrave$1$1,
	ii: ii$1,
	iiiint: iiiint$1,
	iiint: iiint$1,
	iinfin: iinfin$1,
	iiota: iiota$1,
	IJlig: IJlig$1,
	ijlig: ijlig$1,
	Imacr: Imacr$1,
	imacr: imacr$1,
	image: image$1,
	ImaginaryI: ImaginaryI$1,
	imagline: imagline$1,
	imagpart: imagpart$1,
	imath: imath$1,
	Im: Im$1,
	imof: imof$1,
	imped: imped$1,
	Implies: Implies$1,
	incare: incare$1,
	infin: infin$1,
	infintie: infintie$1,
	inodot: inodot$1,
	intcal: intcal$1,
	int: int$1,
	Int: Int$1,
	integers: integers$1,
	Integral: Integral$1,
	intercal: intercal$1,
	Intersection: Intersection$1,
	intlarhk: intlarhk$1,
	intprod: intprod$1,
	InvisibleComma: InvisibleComma$1,
	InvisibleTimes: InvisibleTimes$1,
	IOcy: IOcy$1,
	iocy: iocy$1,
	Iogon: Iogon$1,
	iogon: iogon$1,
	Iopf: Iopf$1,
	iopf: iopf$1,
	Iota: Iota$1,
	iota: iota$1,
	iprod: iprod$1,
	iquest: iquest$1$1,
	iscr: iscr$1,
	Iscr: Iscr$1,
	isin: isin$1,
	isindot: isindot$1,
	isinE: isinE$1,
	isins: isins$1,
	isinsv: isinsv$1,
	isinv: isinv$1,
	it: it$1,
	Itilde: Itilde$1,
	itilde: itilde$1,
	Iukcy: Iukcy$1,
	iukcy: iukcy$1,
	Iuml: Iuml$1$1,
	iuml: iuml$1$1,
	Jcirc: Jcirc$1,
	jcirc: jcirc$1,
	Jcy: Jcy$1,
	jcy: jcy$1,
	Jfr: Jfr$1,
	jfr: jfr$1,
	jmath: jmath$1,
	Jopf: Jopf$1,
	jopf: jopf$1,
	Jscr: Jscr$1,
	jscr: jscr$1,
	Jsercy: Jsercy$1,
	jsercy: jsercy$1,
	Jukcy: Jukcy$1,
	jukcy: jukcy$1,
	Kappa: Kappa$1,
	kappa: kappa$1,
	kappav: kappav$1,
	Kcedil: Kcedil$1,
	kcedil: kcedil$1,
	Kcy: Kcy$1,
	kcy: kcy$1,
	Kfr: Kfr$1,
	kfr: kfr$1,
	kgreen: kgreen$1,
	KHcy: KHcy$1,
	khcy: khcy$1,
	KJcy: KJcy$1,
	kjcy: kjcy$1,
	Kopf: Kopf$1,
	kopf: kopf$1,
	Kscr: Kscr$1,
	kscr: kscr$1,
	lAarr: lAarr$1,
	Lacute: Lacute$1,
	lacute: lacute$1,
	laemptyv: laemptyv$1,
	lagran: lagran$1,
	Lambda: Lambda$1,
	lambda: lambda$1,
	lang: lang$1,
	Lang: Lang$1,
	langd: langd$1,
	langle: langle$1,
	lap: lap$1,
	Laplacetrf: Laplacetrf$1,
	laquo: laquo$1$1,
	larrb: larrb$1,
	larrbfs: larrbfs$1,
	larr: larr$1,
	Larr: Larr$1,
	lArr: lArr$1,
	larrfs: larrfs$1,
	larrhk: larrhk$1,
	larrlp: larrlp$1,
	larrpl: larrpl$1,
	larrsim: larrsim$1,
	larrtl: larrtl$1,
	latail: latail$1,
	lAtail: lAtail$1,
	lat: lat$1,
	late: late$1,
	lates: lates$1,
	lbarr: lbarr$1,
	lBarr: lBarr$1,
	lbbrk: lbbrk$1,
	lbrace: lbrace$1,
	lbrack: lbrack$1,
	lbrke: lbrke$1,
	lbrksld: lbrksld$1,
	lbrkslu: lbrkslu$1,
	Lcaron: Lcaron$1,
	lcaron: lcaron$1,
	Lcedil: Lcedil$1,
	lcedil: lcedil$1,
	lceil: lceil$1,
	lcub: lcub$1,
	Lcy: Lcy$1,
	lcy: lcy$1,
	ldca: ldca$1,
	ldquo: ldquo$1,
	ldquor: ldquor$1,
	ldrdhar: ldrdhar$1,
	ldrushar: ldrushar$1,
	ldsh: ldsh$1,
	le: le$1,
	lE: lE$1,
	LeftAngleBracket: LeftAngleBracket$1,
	LeftArrowBar: LeftArrowBar$1,
	leftarrow: leftarrow$1,
	LeftArrow: LeftArrow$1,
	Leftarrow: Leftarrow$1,
	LeftArrowRightArrow: LeftArrowRightArrow$1,
	leftarrowtail: leftarrowtail$1,
	LeftCeiling: LeftCeiling$1,
	LeftDoubleBracket: LeftDoubleBracket$1,
	LeftDownTeeVector: LeftDownTeeVector$1,
	LeftDownVectorBar: LeftDownVectorBar$1,
	LeftDownVector: LeftDownVector$1,
	LeftFloor: LeftFloor$1,
	leftharpoondown: leftharpoondown$1,
	leftharpoonup: leftharpoonup$1,
	leftleftarrows: leftleftarrows$1,
	leftrightarrow: leftrightarrow$1,
	LeftRightArrow: LeftRightArrow$1,
	Leftrightarrow: Leftrightarrow$1,
	leftrightarrows: leftrightarrows$1,
	leftrightharpoons: leftrightharpoons$1,
	leftrightsquigarrow: leftrightsquigarrow$1,
	LeftRightVector: LeftRightVector$1,
	LeftTeeArrow: LeftTeeArrow$1,
	LeftTee: LeftTee$1,
	LeftTeeVector: LeftTeeVector$1,
	leftthreetimes: leftthreetimes$1,
	LeftTriangleBar: LeftTriangleBar$1,
	LeftTriangle: LeftTriangle$1,
	LeftTriangleEqual: LeftTriangleEqual$1,
	LeftUpDownVector: LeftUpDownVector$1,
	LeftUpTeeVector: LeftUpTeeVector$1,
	LeftUpVectorBar: LeftUpVectorBar$1,
	LeftUpVector: LeftUpVector$1,
	LeftVectorBar: LeftVectorBar$1,
	LeftVector: LeftVector$1,
	lEg: lEg$1,
	leg: leg$1,
	leq: leq$1,
	leqq: leqq$1,
	leqslant: leqslant$1,
	lescc: lescc$1,
	les: les$1,
	lesdot: lesdot$1,
	lesdoto: lesdoto$1,
	lesdotor: lesdotor$1,
	lesg: lesg$1,
	lesges: lesges$1,
	lessapprox: lessapprox$1,
	lessdot: lessdot$1,
	lesseqgtr: lesseqgtr$1,
	lesseqqgtr: lesseqqgtr$1,
	LessEqualGreater: LessEqualGreater$1,
	LessFullEqual: LessFullEqual$1,
	LessGreater: LessGreater$1,
	lessgtr: lessgtr$1,
	LessLess: LessLess$1,
	lesssim: lesssim$1,
	LessSlantEqual: LessSlantEqual$1,
	LessTilde: LessTilde$1,
	lfisht: lfisht$1,
	lfloor: lfloor$1,
	Lfr: Lfr$1,
	lfr: lfr$1,
	lg: lg$1,
	lgE: lgE$1,
	lHar: lHar$1,
	lhard: lhard$1,
	lharu: lharu$1,
	lharul: lharul$1,
	lhblk: lhblk$1,
	LJcy: LJcy$1,
	ljcy: ljcy$1,
	llarr: llarr$1,
	ll: ll$1,
	Ll: Ll$1,
	llcorner: llcorner$1,
	Lleftarrow: Lleftarrow$1,
	llhard: llhard$1,
	lltri: lltri$1,
	Lmidot: Lmidot$1,
	lmidot: lmidot$1,
	lmoustache: lmoustache$1,
	lmoust: lmoust$1,
	lnap: lnap$1,
	lnapprox: lnapprox$1,
	lne: lne$1,
	lnE: lnE$1,
	lneq: lneq$1,
	lneqq: lneqq$1,
	lnsim: lnsim$1,
	loang: loang$1,
	loarr: loarr$1,
	lobrk: lobrk$1,
	longleftarrow: longleftarrow$1,
	LongLeftArrow: LongLeftArrow$1,
	Longleftarrow: Longleftarrow$1,
	longleftrightarrow: longleftrightarrow$1,
	LongLeftRightArrow: LongLeftRightArrow$1,
	Longleftrightarrow: Longleftrightarrow$1,
	longmapsto: longmapsto$1,
	longrightarrow: longrightarrow$1,
	LongRightArrow: LongRightArrow$1,
	Longrightarrow: Longrightarrow$1,
	looparrowleft: looparrowleft$1,
	looparrowright: looparrowright$1,
	lopar: lopar$1,
	Lopf: Lopf$1,
	lopf: lopf$1,
	loplus: loplus$1,
	lotimes: lotimes$1,
	lowast: lowast$1,
	lowbar: lowbar$1,
	LowerLeftArrow: LowerLeftArrow$1,
	LowerRightArrow: LowerRightArrow$1,
	loz: loz$1,
	lozenge: lozenge$1,
	lozf: lozf$1,
	lpar: lpar$1,
	lparlt: lparlt$1,
	lrarr: lrarr$1,
	lrcorner: lrcorner$1,
	lrhar: lrhar$1,
	lrhard: lrhard$1,
	lrm: lrm$1,
	lrtri: lrtri$1,
	lsaquo: lsaquo$1,
	lscr: lscr$1,
	Lscr: Lscr$1,
	lsh: lsh$1,
	Lsh: Lsh$1,
	lsim: lsim$1,
	lsime: lsime$1,
	lsimg: lsimg$1,
	lsqb: lsqb$1,
	lsquo: lsquo$1,
	lsquor: lsquor$1,
	Lstrok: Lstrok$1,
	lstrok: lstrok$1,
	ltcc: ltcc$1,
	ltcir: ltcir$1,
	lt: lt$1$2,
	LT: LT$1$1,
	Lt: Lt$1,
	ltdot: ltdot$1,
	lthree: lthree$1,
	ltimes: ltimes$1,
	ltlarr: ltlarr$1,
	ltquest: ltquest$1,
	ltri: ltri$1,
	ltrie: ltrie$1,
	ltrif: ltrif$1,
	ltrPar: ltrPar$1,
	lurdshar: lurdshar$1,
	luruhar: luruhar$1,
	lvertneqq: lvertneqq$1,
	lvnE: lvnE$1,
	macr: macr$1$1,
	male: male$1,
	malt: malt$1,
	maltese: maltese$1,
	map: map$2,
	mapsto: mapsto$1,
	mapstodown: mapstodown$1,
	mapstoleft: mapstoleft$1,
	mapstoup: mapstoup$1,
	marker: marker$1,
	mcomma: mcomma$1,
	Mcy: Mcy$1,
	mcy: mcy$1,
	mdash: mdash$1,
	mDDot: mDDot$1,
	measuredangle: measuredangle$1,
	MediumSpace: MediumSpace$1,
	Mellintrf: Mellintrf$1,
	Mfr: Mfr$1,
	mfr: mfr$1,
	mho: mho$1,
	micro: micro$1$1,
	midast: midast$1,
	midcir: midcir$1,
	mid: mid$1,
	middot: middot$1$1,
	minusb: minusb$1,
	minus: minus$1,
	minusd: minusd$1,
	minusdu: minusdu$1,
	MinusPlus: MinusPlus$1,
	mlcp: mlcp$1,
	mldr: mldr$1,
	mnplus: mnplus$1,
	models: models$1,
	Mopf: Mopf$1,
	mopf: mopf$1,
	mp: mp$1,
	mscr: mscr$1,
	Mscr: Mscr$1,
	mstpos: mstpos$1,
	Mu: Mu$1,
	mu: mu$1,
	multimap: multimap$1,
	mumap: mumap$1,
	nabla: nabla$1,
	Nacute: Nacute$1,
	nacute: nacute$1,
	nang: nang$1,
	nap: nap$1,
	napE: napE$1,
	napid: napid$1,
	napos: napos$1,
	napprox: napprox$1,
	natural: natural$1,
	naturals: naturals$1,
	natur: natur$1,
	nbsp: nbsp$1$1,
	nbump: nbump$1,
	nbumpe: nbumpe$1,
	ncap: ncap$1,
	Ncaron: Ncaron$1,
	ncaron: ncaron$1,
	Ncedil: Ncedil$1,
	ncedil: ncedil$1,
	ncong: ncong$1,
	ncongdot: ncongdot$1,
	ncup: ncup$1,
	Ncy: Ncy$1,
	ncy: ncy$1,
	ndash: ndash$1,
	nearhk: nearhk$1,
	nearr: nearr$1,
	neArr: neArr$1,
	nearrow: nearrow$1,
	ne: ne$1,
	nedot: nedot$1,
	NegativeMediumSpace: NegativeMediumSpace$1,
	NegativeThickSpace: NegativeThickSpace$1,
	NegativeThinSpace: NegativeThinSpace$1,
	NegativeVeryThinSpace: NegativeVeryThinSpace$1,
	nequiv: nequiv$1,
	nesear: nesear$1,
	nesim: nesim$1,
	NestedGreaterGreater: NestedGreaterGreater$1,
	NestedLessLess: NestedLessLess$1,
	NewLine: NewLine$1,
	nexist: nexist$1,
	nexists: nexists$1,
	Nfr: Nfr$1,
	nfr: nfr$1,
	ngE: ngE$1,
	nge: nge$1,
	ngeq: ngeq$1,
	ngeqq: ngeqq$1,
	ngeqslant: ngeqslant$1,
	nges: nges$1,
	nGg: nGg$1,
	ngsim: ngsim$1,
	nGt: nGt$1,
	ngt: ngt$1,
	ngtr: ngtr$1,
	nGtv: nGtv$1,
	nharr: nharr$1,
	nhArr: nhArr$1,
	nhpar: nhpar$1,
	ni: ni$1,
	nis: nis$1,
	nisd: nisd$1,
	niv: niv$1,
	NJcy: NJcy$1,
	njcy: njcy$1,
	nlarr: nlarr$1,
	nlArr: nlArr$1,
	nldr: nldr$1,
	nlE: nlE$1,
	nle: nle$1,
	nleftarrow: nleftarrow$1,
	nLeftarrow: nLeftarrow$1,
	nleftrightarrow: nleftrightarrow$1,
	nLeftrightarrow: nLeftrightarrow$1,
	nleq: nleq$1,
	nleqq: nleqq$1,
	nleqslant: nleqslant$1,
	nles: nles$1,
	nless: nless$1,
	nLl: nLl$1,
	nlsim: nlsim$1,
	nLt: nLt$1,
	nlt: nlt$1,
	nltri: nltri$1,
	nltrie: nltrie$1,
	nLtv: nLtv$1,
	nmid: nmid$1,
	NoBreak: NoBreak$1,
	NonBreakingSpace: NonBreakingSpace$1,
	nopf: nopf$1,
	Nopf: Nopf$1,
	Not: Not$1,
	not: not$1$1,
	NotCongruent: NotCongruent$1,
	NotCupCap: NotCupCap$1,
	NotDoubleVerticalBar: NotDoubleVerticalBar$1,
	NotElement: NotElement$1,
	NotEqual: NotEqual$1,
	NotEqualTilde: NotEqualTilde$1,
	NotExists: NotExists$1,
	NotGreater: NotGreater$1,
	NotGreaterEqual: NotGreaterEqual$1,
	NotGreaterFullEqual: NotGreaterFullEqual$1,
	NotGreaterGreater: NotGreaterGreater$1,
	NotGreaterLess: NotGreaterLess$1,
	NotGreaterSlantEqual: NotGreaterSlantEqual$1,
	NotGreaterTilde: NotGreaterTilde$1,
	NotHumpDownHump: NotHumpDownHump$1,
	NotHumpEqual: NotHumpEqual$1,
	notin: notin$1,
	notindot: notindot$1,
	notinE: notinE$1,
	notinva: notinva$1,
	notinvb: notinvb$1,
	notinvc: notinvc$1,
	NotLeftTriangleBar: NotLeftTriangleBar$1,
	NotLeftTriangle: NotLeftTriangle$1,
	NotLeftTriangleEqual: NotLeftTriangleEqual$1,
	NotLess: NotLess$1,
	NotLessEqual: NotLessEqual$1,
	NotLessGreater: NotLessGreater$1,
	NotLessLess: NotLessLess$1,
	NotLessSlantEqual: NotLessSlantEqual$1,
	NotLessTilde: NotLessTilde$1,
	NotNestedGreaterGreater: NotNestedGreaterGreater$1,
	NotNestedLessLess: NotNestedLessLess$1,
	notni: notni$1,
	notniva: notniva$1,
	notnivb: notnivb$1,
	notnivc: notnivc$1,
	NotPrecedes: NotPrecedes$1,
	NotPrecedesEqual: NotPrecedesEqual$1,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual$1,
	NotReverseElement: NotReverseElement$1,
	NotRightTriangleBar: NotRightTriangleBar$1,
	NotRightTriangle: NotRightTriangle$1,
	NotRightTriangleEqual: NotRightTriangleEqual$1,
	NotSquareSubset: NotSquareSubset$1,
	NotSquareSubsetEqual: NotSquareSubsetEqual$1,
	NotSquareSuperset: NotSquareSuperset$1,
	NotSquareSupersetEqual: NotSquareSupersetEqual$1,
	NotSubset: NotSubset$1,
	NotSubsetEqual: NotSubsetEqual$1,
	NotSucceeds: NotSucceeds$1,
	NotSucceedsEqual: NotSucceedsEqual$1,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual$1,
	NotSucceedsTilde: NotSucceedsTilde$1,
	NotSuperset: NotSuperset$1,
	NotSupersetEqual: NotSupersetEqual$1,
	NotTilde: NotTilde$1,
	NotTildeEqual: NotTildeEqual$1,
	NotTildeFullEqual: NotTildeFullEqual$1,
	NotTildeTilde: NotTildeTilde$1,
	NotVerticalBar: NotVerticalBar$1,
	nparallel: nparallel$1,
	npar: npar$1,
	nparsl: nparsl$1,
	npart: npart$1,
	npolint: npolint$1,
	npr: npr$1,
	nprcue: nprcue$1,
	nprec: nprec$1,
	npreceq: npreceq$1,
	npre: npre$1,
	nrarrc: nrarrc$1,
	nrarr: nrarr$1,
	nrArr: nrArr$1,
	nrarrw: nrarrw$1,
	nrightarrow: nrightarrow$1,
	nRightarrow: nRightarrow$1,
	nrtri: nrtri$1,
	nrtrie: nrtrie$1,
	nsc: nsc$1,
	nsccue: nsccue$1,
	nsce: nsce$1,
	Nscr: Nscr$1,
	nscr: nscr$1,
	nshortmid: nshortmid$1,
	nshortparallel: nshortparallel$1,
	nsim: nsim$1,
	nsime: nsime$1,
	nsimeq: nsimeq$1,
	nsmid: nsmid$1,
	nspar: nspar$1,
	nsqsube: nsqsube$1,
	nsqsupe: nsqsupe$1,
	nsub: nsub$1,
	nsubE: nsubE$1,
	nsube: nsube$1,
	nsubset: nsubset$1,
	nsubseteq: nsubseteq$1,
	nsubseteqq: nsubseteqq$1,
	nsucc: nsucc$1,
	nsucceq: nsucceq$1,
	nsup: nsup$1,
	nsupE: nsupE$1,
	nsupe: nsupe$1,
	nsupset: nsupset$1,
	nsupseteq: nsupseteq$1,
	nsupseteqq: nsupseteqq$1,
	ntgl: ntgl$1,
	Ntilde: Ntilde$1$1,
	ntilde: ntilde$1$1,
	ntlg: ntlg$1,
	ntriangleleft: ntriangleleft$1,
	ntrianglelefteq: ntrianglelefteq$1,
	ntriangleright: ntriangleright$1,
	ntrianglerighteq: ntrianglerighteq$1,
	Nu: Nu$1,
	nu: nu$1,
	num: num$1,
	numero: numero$1,
	numsp: numsp$1,
	nvap: nvap$1,
	nvdash: nvdash$1,
	nvDash: nvDash$1,
	nVdash: nVdash$1,
	nVDash: nVDash$1,
	nvge: nvge$1,
	nvgt: nvgt$1,
	nvHarr: nvHarr$1,
	nvinfin: nvinfin$1,
	nvlArr: nvlArr$1,
	nvle: nvle$1,
	nvlt: nvlt$1,
	nvltrie: nvltrie$1,
	nvrArr: nvrArr$1,
	nvrtrie: nvrtrie$1,
	nvsim: nvsim$1,
	nwarhk: nwarhk$1,
	nwarr: nwarr$1,
	nwArr: nwArr$1,
	nwarrow: nwarrow$1,
	nwnear: nwnear$1,
	Oacute: Oacute$1$1,
	oacute: oacute$1$1,
	oast: oast$1,
	Ocirc: Ocirc$1$1,
	ocirc: ocirc$1$1,
	ocir: ocir$1,
	Ocy: Ocy$1,
	ocy: ocy$1,
	odash: odash$1,
	Odblac: Odblac$1,
	odblac: odblac$1,
	odiv: odiv$1,
	odot: odot$1,
	odsold: odsold$1,
	OElig: OElig$1,
	oelig: oelig$1,
	ofcir: ofcir$1,
	Ofr: Ofr$1,
	ofr: ofr$1,
	ogon: ogon$1,
	Ograve: Ograve$1$1,
	ograve: ograve$1$1,
	ogt: ogt$1,
	ohbar: ohbar$1,
	ohm: ohm$1,
	oint: oint$1,
	olarr: olarr$1,
	olcir: olcir$1,
	olcross: olcross$1,
	oline: oline$1,
	olt: olt$1,
	Omacr: Omacr$1,
	omacr: omacr$1,
	Omega: Omega$1,
	omega: omega$1,
	Omicron: Omicron$1,
	omicron: omicron$1,
	omid: omid$1,
	ominus: ominus$1,
	Oopf: Oopf$1,
	oopf: oopf$1,
	opar: opar$1,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote$1,
	OpenCurlyQuote: OpenCurlyQuote$1,
	operp: operp$1,
	oplus: oplus$1,
	orarr: orarr$1,
	Or: Or$1,
	or: or$1,
	ord: ord$1,
	order: order$1,
	orderof: orderof$1,
	ordf: ordf$1$1,
	ordm: ordm$1$1,
	origof: origof$1,
	oror: oror$1,
	orslope: orslope$1,
	orv: orv$1,
	oS: oS$1,
	Oscr: Oscr$1,
	oscr: oscr$1,
	Oslash: Oslash$1$1,
	oslash: oslash$1$1,
	osol: osol$1,
	Otilde: Otilde$1$1,
	otilde: otilde$1$1,
	otimesas: otimesas$1,
	Otimes: Otimes$1,
	otimes: otimes$1,
	Ouml: Ouml$1$1,
	ouml: ouml$1$1,
	ovbar: ovbar$1,
	OverBar: OverBar$1,
	OverBrace: OverBrace$1,
	OverBracket: OverBracket$1,
	OverParenthesis: OverParenthesis$1,
	para: para$1$1,
	parallel: parallel$1,
	par: par$1,
	parsim: parsim$1,
	parsl: parsl$1,
	part: part$1,
	PartialD: PartialD$1,
	Pcy: Pcy$1,
	pcy: pcy$1,
	percnt: percnt$1,
	period: period$1,
	permil: permil$1,
	perp: perp$1,
	pertenk: pertenk$1,
	Pfr: Pfr$1,
	pfr: pfr$1,
	Phi: Phi$1,
	phi: phi$1,
	phiv: phiv$1,
	phmmat: phmmat$1,
	phone: phone$1,
	Pi: Pi$1,
	pi: pi$1,
	pitchfork: pitchfork$1,
	piv: piv$1,
	planck: planck$1,
	planckh: planckh$1,
	plankv: plankv$1,
	plusacir: plusacir$1,
	plusb: plusb$1,
	pluscir: pluscir$1,
	plus: plus$1,
	plusdo: plusdo$1,
	plusdu: plusdu$1,
	pluse: pluse$1,
	PlusMinus: PlusMinus$1,
	plusmn: plusmn$1$1,
	plussim: plussim$1,
	plustwo: plustwo$1,
	pm: pm$1,
	Poincareplane: Poincareplane$1,
	pointint: pointint$1,
	popf: popf$1,
	Popf: Popf$1,
	pound: pound$1$1,
	prap: prap$1,
	Pr: Pr$1,
	pr: pr$1,
	prcue: prcue$1,
	precapprox: precapprox$1,
	prec: prec$1,
	preccurlyeq: preccurlyeq$1,
	Precedes: Precedes$1,
	PrecedesEqual: PrecedesEqual$1,
	PrecedesSlantEqual: PrecedesSlantEqual$1,
	PrecedesTilde: PrecedesTilde$1,
	preceq: preceq$1,
	precnapprox: precnapprox$1,
	precneqq: precneqq$1,
	precnsim: precnsim$1,
	pre: pre$1,
	prE: prE$1,
	precsim: precsim$1,
	prime: prime$1,
	Prime: Prime$1,
	primes: primes$1,
	prnap: prnap$1,
	prnE: prnE$1,
	prnsim: prnsim$1,
	prod: prod$1,
	Product: Product$1,
	profalar: profalar$1,
	profline: profline$1,
	profsurf: profsurf$1,
	prop: prop$1,
	Proportional: Proportional$1,
	Proportion: Proportion$1,
	propto: propto$1,
	prsim: prsim$1,
	prurel: prurel$1,
	Pscr: Pscr$1,
	pscr: pscr$1,
	Psi: Psi$1,
	psi: psi$1,
	puncsp: puncsp$1,
	Qfr: Qfr$1,
	qfr: qfr$1,
	qint: qint$1,
	qopf: qopf$1,
	Qopf: Qopf$1,
	qprime: qprime$1,
	Qscr: Qscr$1,
	qscr: qscr$1,
	quaternions: quaternions$1,
	quatint: quatint$1,
	quest: quest$1,
	questeq: questeq$1,
	quot: quot$1$2,
	QUOT: QUOT$1$1,
	rAarr: rAarr$1,
	race: race$1,
	Racute: Racute$1,
	racute: racute$1,
	radic: radic$1,
	raemptyv: raemptyv$1,
	rang: rang$1,
	Rang: Rang$1,
	rangd: rangd$1,
	range: range$1,
	rangle: rangle$1,
	raquo: raquo$1$1,
	rarrap: rarrap$1,
	rarrb: rarrb$1,
	rarrbfs: rarrbfs$1,
	rarrc: rarrc$1,
	rarr: rarr$1,
	Rarr: Rarr$1,
	rArr: rArr$1,
	rarrfs: rarrfs$1,
	rarrhk: rarrhk$1,
	rarrlp: rarrlp$1,
	rarrpl: rarrpl$1,
	rarrsim: rarrsim$1,
	Rarrtl: Rarrtl$1,
	rarrtl: rarrtl$1,
	rarrw: rarrw$1,
	ratail: ratail$1,
	rAtail: rAtail$1,
	ratio: ratio$1,
	rationals: rationals$1,
	rbarr: rbarr$1,
	rBarr: rBarr$1,
	RBarr: RBarr$1,
	rbbrk: rbbrk$1,
	rbrace: rbrace$1,
	rbrack: rbrack$1,
	rbrke: rbrke$1,
	rbrksld: rbrksld$1,
	rbrkslu: rbrkslu$1,
	Rcaron: Rcaron$1,
	rcaron: rcaron$1,
	Rcedil: Rcedil$1,
	rcedil: rcedil$1,
	rceil: rceil$1,
	rcub: rcub$1,
	Rcy: Rcy$1,
	rcy: rcy$1,
	rdca: rdca$1,
	rdldhar: rdldhar$1,
	rdquo: rdquo$1,
	rdquor: rdquor$1,
	rdsh: rdsh$1,
	real: real$1,
	realine: realine$1,
	realpart: realpart$1,
	reals: reals$1,
	Re: Re$1,
	rect: rect$1,
	reg: reg$1$1,
	REG: REG$1$1,
	ReverseElement: ReverseElement$1,
	ReverseEquilibrium: ReverseEquilibrium$1,
	ReverseUpEquilibrium: ReverseUpEquilibrium$1,
	rfisht: rfisht$1,
	rfloor: rfloor$1,
	rfr: rfr$1,
	Rfr: Rfr$1,
	rHar: rHar$1,
	rhard: rhard$1,
	rharu: rharu$1,
	rharul: rharul$1,
	Rho: Rho$1,
	rho: rho$1,
	rhov: rhov$1,
	RightAngleBracket: RightAngleBracket$1,
	RightArrowBar: RightArrowBar$1,
	rightarrow: rightarrow$1,
	RightArrow: RightArrow$1,
	Rightarrow: Rightarrow$1,
	RightArrowLeftArrow: RightArrowLeftArrow$1,
	rightarrowtail: rightarrowtail$1,
	RightCeiling: RightCeiling$1,
	RightDoubleBracket: RightDoubleBracket$1,
	RightDownTeeVector: RightDownTeeVector$1,
	RightDownVectorBar: RightDownVectorBar$1,
	RightDownVector: RightDownVector$1,
	RightFloor: RightFloor$1,
	rightharpoondown: rightharpoondown$1,
	rightharpoonup: rightharpoonup$1,
	rightleftarrows: rightleftarrows$1,
	rightleftharpoons: rightleftharpoons$1,
	rightrightarrows: rightrightarrows$1,
	rightsquigarrow: rightsquigarrow$1,
	RightTeeArrow: RightTeeArrow$1,
	RightTee: RightTee$1,
	RightTeeVector: RightTeeVector$1,
	rightthreetimes: rightthreetimes$1,
	RightTriangleBar: RightTriangleBar$1,
	RightTriangle: RightTriangle$1,
	RightTriangleEqual: RightTriangleEqual$1,
	RightUpDownVector: RightUpDownVector$1,
	RightUpTeeVector: RightUpTeeVector$1,
	RightUpVectorBar: RightUpVectorBar$1,
	RightUpVector: RightUpVector$1,
	RightVectorBar: RightVectorBar$1,
	RightVector: RightVector$1,
	ring: ring$1,
	risingdotseq: risingdotseq$1,
	rlarr: rlarr$1,
	rlhar: rlhar$1,
	rlm: rlm$1,
	rmoustache: rmoustache$1,
	rmoust: rmoust$1,
	rnmid: rnmid$1,
	roang: roang$1,
	roarr: roarr$1,
	robrk: robrk$1,
	ropar: ropar$1,
	ropf: ropf$1,
	Ropf: Ropf$1,
	roplus: roplus$1,
	rotimes: rotimes$1,
	RoundImplies: RoundImplies$1,
	rpar: rpar$1,
	rpargt: rpargt$1,
	rppolint: rppolint$1,
	rrarr: rrarr$1,
	Rrightarrow: Rrightarrow$1,
	rsaquo: rsaquo$1,
	rscr: rscr$1,
	Rscr: Rscr$1,
	rsh: rsh$1,
	Rsh: Rsh$1,
	rsqb: rsqb$1,
	rsquo: rsquo$1,
	rsquor: rsquor$1,
	rthree: rthree$1,
	rtimes: rtimes$1,
	rtri: rtri$1,
	rtrie: rtrie$1,
	rtrif: rtrif$1,
	rtriltri: rtriltri$1,
	RuleDelayed: RuleDelayed$1,
	ruluhar: ruluhar$1,
	rx: rx$1,
	Sacute: Sacute$1,
	sacute: sacute$1,
	sbquo: sbquo$1,
	scap: scap$1,
	Scaron: Scaron$1,
	scaron: scaron$1,
	Sc: Sc$1,
	sc: sc$1,
	sccue: sccue$1,
	sce: sce$1,
	scE: scE$1,
	Scedil: Scedil$1,
	scedil: scedil$1,
	Scirc: Scirc$1,
	scirc: scirc$1,
	scnap: scnap$1,
	scnE: scnE$1,
	scnsim: scnsim$1,
	scpolint: scpolint$1,
	scsim: scsim$1,
	Scy: Scy$1,
	scy: scy$1,
	sdotb: sdotb$1,
	sdot: sdot$1,
	sdote: sdote$1,
	searhk: searhk$1,
	searr: searr$1,
	seArr: seArr$1,
	searrow: searrow$1,
	sect: sect$1$1,
	semi: semi$1,
	seswar: seswar$1,
	setminus: setminus$1,
	setmn: setmn$1,
	sext: sext$1,
	Sfr: Sfr$1,
	sfr: sfr$1,
	sfrown: sfrown$1,
	sharp: sharp$1,
	SHCHcy: SHCHcy$1,
	shchcy: shchcy$1,
	SHcy: SHcy$1,
	shcy: shcy$1,
	ShortDownArrow: ShortDownArrow$1,
	ShortLeftArrow: ShortLeftArrow$1,
	shortmid: shortmid$1,
	shortparallel: shortparallel$1,
	ShortRightArrow: ShortRightArrow$1,
	ShortUpArrow: ShortUpArrow$1,
	shy: shy$1$1,
	Sigma: Sigma$1,
	sigma: sigma$1,
	sigmaf: sigmaf$1,
	sigmav: sigmav$1,
	sim: sim$1,
	simdot: simdot$1,
	sime: sime$1,
	simeq: simeq$1,
	simg: simg$1,
	simgE: simgE$1,
	siml: siml$1,
	simlE: simlE$1,
	simne: simne$1,
	simplus: simplus$1,
	simrarr: simrarr$1,
	slarr: slarr$1,
	SmallCircle: SmallCircle$1,
	smallsetminus: smallsetminus$1,
	smashp: smashp$1,
	smeparsl: smeparsl$1,
	smid: smid$1,
	smile: smile$1,
	smt: smt$1,
	smte: smte$1,
	smtes: smtes$1,
	SOFTcy: SOFTcy$1,
	softcy: softcy$1,
	solbar: solbar$1,
	solb: solb$1,
	sol: sol$1,
	Sopf: Sopf$1,
	sopf: sopf$1,
	spades: spades$1,
	spadesuit: spadesuit$1,
	spar: spar$1,
	sqcap: sqcap$1,
	sqcaps: sqcaps$1,
	sqcup: sqcup$1,
	sqcups: sqcups$1,
	Sqrt: Sqrt$1,
	sqsub: sqsub$1,
	sqsube: sqsube$1,
	sqsubset: sqsubset$1,
	sqsubseteq: sqsubseteq$1,
	sqsup: sqsup$1,
	sqsupe: sqsupe$1,
	sqsupset: sqsupset$1,
	sqsupseteq: sqsupseteq$1,
	square: square$1,
	Square: Square$1,
	SquareIntersection: SquareIntersection$1,
	SquareSubset: SquareSubset$1,
	SquareSubsetEqual: SquareSubsetEqual$1,
	SquareSuperset: SquareSuperset$1,
	SquareSupersetEqual: SquareSupersetEqual$1,
	SquareUnion: SquareUnion$1,
	squarf: squarf$1,
	squ: squ$1,
	squf: squf$1,
	srarr: srarr$1,
	Sscr: Sscr$1,
	sscr: sscr$1,
	ssetmn: ssetmn$1,
	ssmile: ssmile$1,
	sstarf: sstarf$1,
	Star: Star$1,
	star: star$1,
	starf: starf$1,
	straightepsilon: straightepsilon$1,
	straightphi: straightphi$1,
	strns: strns$1,
	sub: sub$1,
	Sub: Sub$1,
	subdot: subdot$1,
	subE: subE$1,
	sube: sube$1,
	subedot: subedot$1,
	submult: submult$1,
	subnE: subnE$1,
	subne: subne$1,
	subplus: subplus$1,
	subrarr: subrarr$1,
	subset: subset$1,
	Subset: Subset$1,
	subseteq: subseteq$1,
	subseteqq: subseteqq$1,
	SubsetEqual: SubsetEqual$1,
	subsetneq: subsetneq$1,
	subsetneqq: subsetneqq$1,
	subsim: subsim$1,
	subsub: subsub$1,
	subsup: subsup$1,
	succapprox: succapprox$1,
	succ: succ$1,
	succcurlyeq: succcurlyeq$1,
	Succeeds: Succeeds$1,
	SucceedsEqual: SucceedsEqual$1,
	SucceedsSlantEqual: SucceedsSlantEqual$1,
	SucceedsTilde: SucceedsTilde$1,
	succeq: succeq$1,
	succnapprox: succnapprox$1,
	succneqq: succneqq$1,
	succnsim: succnsim$1,
	succsim: succsim$1,
	SuchThat: SuchThat$1,
	sum: sum$1,
	Sum: Sum$1,
	sung: sung$1,
	sup1: sup1$1$1,
	sup2: sup2$1$1,
	sup3: sup3$1$1,
	sup: sup$1,
	Sup: Sup$1,
	supdot: supdot$1,
	supdsub: supdsub$1,
	supE: supE$1,
	supe: supe$1,
	supedot: supedot$1,
	Superset: Superset$1,
	SupersetEqual: SupersetEqual$1,
	suphsol: suphsol$1,
	suphsub: suphsub$1,
	suplarr: suplarr$1,
	supmult: supmult$1,
	supnE: supnE$1,
	supne: supne$1,
	supplus: supplus$1,
	supset: supset$1,
	Supset: Supset$1,
	supseteq: supseteq$1,
	supseteqq: supseteqq$1,
	supsetneq: supsetneq$1,
	supsetneqq: supsetneqq$1,
	supsim: supsim$1,
	supsub: supsub$1,
	supsup: supsup$1,
	swarhk: swarhk$1,
	swarr: swarr$1,
	swArr: swArr$1,
	swarrow: swarrow$1,
	swnwar: swnwar$1,
	szlig: szlig$1$1,
	Tab: Tab$1,
	target: target$1,
	Tau: Tau$1,
	tau: tau$1,
	tbrk: tbrk$1,
	Tcaron: Tcaron$1,
	tcaron: tcaron$1,
	Tcedil: Tcedil$1,
	tcedil: tcedil$1,
	Tcy: Tcy$1,
	tcy: tcy$1,
	tdot: tdot$1,
	telrec: telrec$1,
	Tfr: Tfr$1,
	tfr: tfr$1,
	there4: there4$1,
	therefore: therefore$1,
	Therefore: Therefore$1,
	Theta: Theta$1,
	theta: theta$1,
	thetasym: thetasym$1,
	thetav: thetav$1,
	thickapprox: thickapprox$1,
	thicksim: thicksim$1,
	ThickSpace: ThickSpace$1,
	ThinSpace: ThinSpace$1,
	thinsp: thinsp$1,
	thkap: thkap$1,
	thksim: thksim$1,
	THORN: THORN$1$1,
	thorn: thorn$1$1,
	tilde: tilde$1,
	Tilde: Tilde$1,
	TildeEqual: TildeEqual$1,
	TildeFullEqual: TildeFullEqual$1,
	TildeTilde: TildeTilde$1,
	timesbar: timesbar$1,
	timesb: timesb$1,
	times: times$2,
	timesd: timesd$1,
	tint: tint$1,
	toea: toea$1,
	topbot: topbot$1,
	topcir: topcir$1,
	top: top$1,
	Topf: Topf$1,
	topf: topf$1,
	topfork: topfork$1,
	tosa: tosa$1,
	tprime: tprime$1,
	trade: trade$1,
	TRADE: TRADE$1,
	triangle: triangle$1,
	triangledown: triangledown$1,
	triangleleft: triangleleft$1,
	trianglelefteq: trianglelefteq$1,
	triangleq: triangleq$1,
	triangleright: triangleright$1,
	trianglerighteq: trianglerighteq$1,
	tridot: tridot$1,
	trie: trie$1,
	triminus: triminus$1,
	TripleDot: TripleDot$1,
	triplus: triplus$1,
	trisb: trisb$1,
	tritime: tritime$1,
	trpezium: trpezium$1,
	Tscr: Tscr$1,
	tscr: tscr$1,
	TScy: TScy$1,
	tscy: tscy$1,
	TSHcy: TSHcy$1,
	tshcy: tshcy$1,
	Tstrok: Tstrok$1,
	tstrok: tstrok$1,
	twixt: twixt$1,
	twoheadleftarrow: twoheadleftarrow$1,
	twoheadrightarrow: twoheadrightarrow$1,
	Uacute: Uacute$1$1,
	uacute: uacute$1$1,
	uarr: uarr$1,
	Uarr: Uarr$1,
	uArr: uArr$1,
	Uarrocir: Uarrocir$1,
	Ubrcy: Ubrcy$1,
	ubrcy: ubrcy$1,
	Ubreve: Ubreve$1,
	ubreve: ubreve$1,
	Ucirc: Ucirc$1$1,
	ucirc: ucirc$1$1,
	Ucy: Ucy$1,
	ucy: ucy$1,
	udarr: udarr$1,
	Udblac: Udblac$1,
	udblac: udblac$1,
	udhar: udhar$1,
	ufisht: ufisht$1,
	Ufr: Ufr$1,
	ufr: ufr$1,
	Ugrave: Ugrave$1$1,
	ugrave: ugrave$1$1,
	uHar: uHar$1,
	uharl: uharl$1,
	uharr: uharr$1,
	uhblk: uhblk$1,
	ulcorn: ulcorn$1,
	ulcorner: ulcorner$1,
	ulcrop: ulcrop$1,
	ultri: ultri$1,
	Umacr: Umacr$1,
	umacr: umacr$1,
	uml: uml$1$1,
	UnderBar: UnderBar$1,
	UnderBrace: UnderBrace$1,
	UnderBracket: UnderBracket$1,
	UnderParenthesis: UnderParenthesis$1,
	Union: Union$1,
	UnionPlus: UnionPlus$1,
	Uogon: Uogon$1,
	uogon: uogon$1,
	Uopf: Uopf$1,
	uopf: uopf$1,
	UpArrowBar: UpArrowBar$1,
	uparrow: uparrow$1,
	UpArrow: UpArrow$1,
	Uparrow: Uparrow$1,
	UpArrowDownArrow: UpArrowDownArrow$1,
	updownarrow: updownarrow$1,
	UpDownArrow: UpDownArrow$1,
	Updownarrow: Updownarrow$1,
	UpEquilibrium: UpEquilibrium$1,
	upharpoonleft: upharpoonleft$1,
	upharpoonright: upharpoonright$1,
	uplus: uplus$1,
	UpperLeftArrow: UpperLeftArrow$1,
	UpperRightArrow: UpperRightArrow$1,
	upsi: upsi$1,
	Upsi: Upsi$1,
	upsih: upsih$1,
	Upsilon: Upsilon$1,
	upsilon: upsilon$1,
	UpTeeArrow: UpTeeArrow$1,
	UpTee: UpTee$1,
	upuparrows: upuparrows$1,
	urcorn: urcorn$1,
	urcorner: urcorner$1,
	urcrop: urcrop$1,
	Uring: Uring$1,
	uring: uring$1,
	urtri: urtri$1,
	Uscr: Uscr$1,
	uscr: uscr$1,
	utdot: utdot$1,
	Utilde: Utilde$1,
	utilde: utilde$1,
	utri: utri$1,
	utrif: utrif$1,
	uuarr: uuarr$1,
	Uuml: Uuml$1$1,
	uuml: uuml$1$1,
	uwangle: uwangle$1,
	vangrt: vangrt$1,
	varepsilon: varepsilon$1,
	varkappa: varkappa$1,
	varnothing: varnothing$1,
	varphi: varphi$1,
	varpi: varpi$1,
	varpropto: varpropto$1,
	varr: varr$1,
	vArr: vArr$1,
	varrho: varrho$1,
	varsigma: varsigma$1,
	varsubsetneq: varsubsetneq$1,
	varsubsetneqq: varsubsetneqq$1,
	varsupsetneq: varsupsetneq$1,
	varsupsetneqq: varsupsetneqq$1,
	vartheta: vartheta$1,
	vartriangleleft: vartriangleleft$1,
	vartriangleright: vartriangleright$1,
	vBar: vBar$1,
	Vbar: Vbar$1,
	vBarv: vBarv$1,
	Vcy: Vcy$1,
	vcy: vcy$1,
	vdash: vdash$1,
	vDash: vDash$1,
	Vdash: Vdash$1,
	VDash: VDash$1,
	Vdashl: Vdashl$1,
	veebar: veebar$1,
	vee: vee$1,
	Vee: Vee$1,
	veeeq: veeeq$1,
	vellip: vellip$1,
	verbar: verbar$1,
	Verbar: Verbar$1,
	vert: vert$1,
	Vert: Vert$1,
	VerticalBar: VerticalBar$1,
	VerticalLine: VerticalLine$1,
	VerticalSeparator: VerticalSeparator$1,
	VerticalTilde: VerticalTilde$1,
	VeryThinSpace: VeryThinSpace$1,
	Vfr: Vfr$1,
	vfr: vfr$1,
	vltri: vltri$1,
	vnsub: vnsub$1,
	vnsup: vnsup$1,
	Vopf: Vopf$1,
	vopf: vopf$1,
	vprop: vprop$1,
	vrtri: vrtri$1,
	Vscr: Vscr$1,
	vscr: vscr$1,
	vsubnE: vsubnE$1,
	vsubne: vsubne$1,
	vsupnE: vsupnE$1,
	vsupne: vsupne$1,
	Vvdash: Vvdash$1,
	vzigzag: vzigzag$1,
	Wcirc: Wcirc$1,
	wcirc: wcirc$1,
	wedbar: wedbar$1,
	wedge: wedge$1,
	Wedge: Wedge$1,
	wedgeq: wedgeq$1,
	weierp: weierp$1,
	Wfr: Wfr$1,
	wfr: wfr$1,
	Wopf: Wopf$1,
	wopf: wopf$1,
	wp: wp$1,
	wr: wr$1,
	wreath: wreath$1,
	Wscr: Wscr$1,
	wscr: wscr$1,
	xcap: xcap$1,
	xcirc: xcirc$1,
	xcup: xcup$1,
	xdtri: xdtri$1,
	Xfr: Xfr$1,
	xfr: xfr$1,
	xharr: xharr$1,
	xhArr: xhArr$1,
	Xi: Xi$1,
	xi: xi$1,
	xlarr: xlarr$1,
	xlArr: xlArr$1,
	xmap: xmap$1,
	xnis: xnis$1,
	xodot: xodot$1,
	Xopf: Xopf$1,
	xopf: xopf$1,
	xoplus: xoplus$1,
	xotime: xotime$1,
	xrarr: xrarr$1,
	xrArr: xrArr$1,
	Xscr: Xscr$1,
	xscr: xscr$1,
	xsqcup: xsqcup$1,
	xuplus: xuplus$1,
	xutri: xutri$1,
	xvee: xvee$1,
	xwedge: xwedge$1,
	Yacute: Yacute$1$1,
	yacute: yacute$1$1,
	YAcy: YAcy$1,
	yacy: yacy$1,
	Ycirc: Ycirc$1,
	ycirc: ycirc$1,
	Ycy: Ycy$1,
	ycy: ycy$1,
	yen: yen$1$1,
	Yfr: Yfr$1,
	yfr: yfr$1,
	YIcy: YIcy$1,
	yicy: yicy$1,
	Yopf: Yopf$1,
	yopf: yopf$1,
	Yscr: Yscr$1,
	yscr: yscr$1,
	YUcy: YUcy$1,
	yucy: yucy$1,
	yuml: yuml$1$1,
	Yuml: Yuml$1,
	Zacute: Zacute$1,
	zacute: zacute$1,
	Zcaron: Zcaron$1,
	zcaron: zcaron$1,
	Zcy: Zcy$1,
	zcy: zcy$1,
	Zdot: Zdot$1,
	zdot: zdot$1,
	zeetrf: zeetrf$1,
	ZeroWidthSpace: ZeroWidthSpace$1,
	Zeta: Zeta$1,
	zeta: zeta$1,
	zfr: zfr$1,
	Zfr: Zfr$1,
	ZHcy: ZHcy$1,
	zhcy: zhcy$1,
	zigrarr: zigrarr$1,
	zopf: zopf$1,
	Zopf: Zopf$1,
	Zscr: Zscr$1,
	zscr: zscr$1,
	zwj: zwj$1,
	zwnj: zwnj$1,
	default: entitiesJSON$1
});

var require$$0$2 = ( xml$1 && xmlJSON$1 ) || xml$1;

var require$$1$1 = ( entities$2 && entitiesJSON$1 ) || entities$2;

var inverseXML$1 = getInverseObj$1(require$$0$2);
var xmlReplacer$1 = getInverseReplacer$1(inverseXML$1);

var XML$1 = getInverse$1(inverseXML$1, xmlReplacer$1);

var inverseHTML$1 = getInverseObj$1(require$$1$1);
var htmlReplacer$1 = getInverseReplacer$1(inverseHTML$1);

var HTML$1 = getInverse$1(inverseHTML$1, htmlReplacer$1);

function getInverseObj$1(obj){
	return Object.keys(obj).sort().reduce(function(inverse, name){
		inverse[obj[name]] = "&" + name + ";";
		return inverse;
	}, {});
}

function getInverseReplacer$1(inverse){
	var single = [],
	    multiple = [];

	Object.keys(inverse).forEach(function(k){
		if(k.length === 1){
			single.push("\\" + k);
		} else {
			multiple.push(k);
		}
	});

	
	multiple.unshift("[" + single.join("") + "]");

	return new RegExp(multiple.join("|"), "g");
}

var re_nonASCII$1 = /[^\0-\x7F]/g;
var re_astralSymbols$1 = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

function singleCharReplacer$1(c){
	return "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";";
}

function astralReplacer$1(c){
	
	var high = c.charCodeAt(0);
	var low  = c.charCodeAt(1);
	var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
	return "&#x" + codePoint.toString(16).toUpperCase() + ";";
}

function getInverse$1(inverse, re){
	function func(name){
		return inverse[name];
	}

	return function(data){
		return data
				.replace(re, func)
				.replace(re_astralSymbols$1, astralReplacer$1)
				.replace(re_nonASCII$1, singleCharReplacer$1);
	};
}

var re_xmlChars$1 = getInverseReplacer$1(inverseXML$1);

function escapeXML$1(data){
	return data
			.replace(re_xmlChars$1, singleCharReplacer$1)
			.replace(re_astralSymbols$1, astralReplacer$1)
			.replace(re_nonASCII$1, singleCharReplacer$1);
}

var escape$1 = escapeXML$1;

var encode$1 = {
	XML: XML$1,
	HTML: HTML$1,
	escape: escape$1
};

var decode$1$1 = {
	"0": 65533,
	"128": 8364,
	"130": 8218,
	"131": 402,
	"132": 8222,
	"133": 8230,
	"134": 8224,
	"135": 8225,
	"136": 710,
	"137": 8240,
	"138": 352,
	"139": 8249,
	"140": 338,
	"142": 381,
	"145": 8216,
	"146": 8217,
	"147": 8220,
	"148": 8221,
	"149": 8226,
	"150": 8211,
	"151": 8212,
	"152": 732,
	"153": 8482,
	"154": 353,
	"155": 8250,
	"156": 339,
	"158": 382,
	"159": 376
};

var decode$1$2 = Object.freeze({
	default: decode$1$1
});

var require$$0$1$2 = ( decode$1$2 && decode$1$1 ) || decode$1$2;

var decodeMap$1 = require$$0$1$2;

var decode_codepoint$1 = decodeCodePoint$1;


function decodeCodePoint$1(codePoint){

	if((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF){
		return "\uFFFD";
	}

	if(codePoint in decodeMap$1){
		codePoint = decodeMap$1[codePoint];
	}

	var output = "";

	if(codePoint > 0xFFFF){
		codePoint -= 0x10000;
		output += String.fromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
		codePoint = 0xDC00 | codePoint & 0x3FF;
	}

	output += String.fromCharCode(codePoint);
	return output;
}

var Aacute$1$2 = "";
var aacute$1$2 = "";
var Acirc$1$2 = "";
var acirc$1$2 = "";
var acute$1$2 = "";
var AElig$1$2 = "";
var aelig$1$2 = "";
var Agrave$1$2 = "";
var agrave$1$2 = "";
var amp$2$1 = "&";
var AMP$1$2 = "&";
var Aring$1$2 = "";
var aring$1$2 = "";
var Atilde$1$2 = "";
var atilde$1$2 = "";
var Auml$1$2 = "";
var auml$1$2 = "";
var brvbar$1$2 = "";
var Ccedil$1$2 = "";
var ccedil$1$2 = "";
var cedil$1$2 = "";
var cent$1$2 = "";
var copy$1$2 = "";
var COPY$1$2 = "";
var curren$1$2 = "";
var deg$1$2 = "";
var divide$1$2 = "";
var Eacute$1$2 = "";
var eacute$1$2 = "";
var Ecirc$1$2 = "";
var ecirc$1$2 = "";
var Egrave$1$2 = "";
var egrave$1$2 = "";
var ETH$1$2 = "";
var eth$1$2 = "";
var Euml$1$2 = "";
var euml$1$2 = "";
var frac12$1$2 = "";
var frac14$1$2 = "";
var frac34$1$2 = "";
var gt$2$1 = ">";
var GT$1$2 = ">";
var Iacute$1$2 = "";
var iacute$1$2 = "";
var Icirc$1$2 = "";
var icirc$1$2 = "";
var iexcl$1$2 = "";
var Igrave$1$2 = "";
var igrave$1$2 = "";
var iquest$1$2 = "";
var Iuml$1$2 = "";
var iuml$1$2 = "";
var laquo$1$2 = "";
var lt$2$1 = "<";
var LT$1$2 = "<";
var macr$1$2 = "";
var micro$1$2 = "";
var middot$1$2 = "";
var nbsp$1$2 = "";
var not$1$2 = "";
var Ntilde$1$2 = "";
var ntilde$1$2 = "";
var Oacute$1$2 = "";
var oacute$1$2 = "";
var Ocirc$1$2 = "";
var ocirc$1$2 = "";
var Ograve$1$2 = "";
var ograve$1$2 = "";
var ordf$1$2 = "";
var ordm$1$2 = "";
var Oslash$1$2 = "";
var oslash$1$2 = "";
var Otilde$1$2 = "";
var otilde$1$2 = "";
var Ouml$1$2 = "";
var ouml$1$2 = "";
var para$1$2 = "";
var plusmn$1$2 = "";
var pound$1$2 = "";
var quot$2$1 = "\"";
var QUOT$1$2 = "\"";
var raquo$1$2 = "";
var reg$1$2 = "";
var REG$1$2 = "";
var sect$1$2 = "";
var shy$1$2 = "";
var sup1$1$2 = "";
var sup2$1$2 = "";
var sup3$1$2 = "";
var szlig$1$2 = "";
var THORN$1$2 = "";
var thorn$1$2 = "";
var times$1$2 = "";
var Uacute$1$2 = "";
var uacute$1$2 = "";
var Ucirc$1$2 = "";
var ucirc$1$2 = "";
var Ugrave$1$2 = "";
var ugrave$1$2 = "";
var uml$1$2 = "";
var Uuml$1$2 = "";
var uuml$1$2 = "";
var Yacute$1$2 = "";
var yacute$1$2 = "";
var yen$1$2 = "";
var yuml$1$2 = "";
var legacyJSON$1 = {
	Aacute: Aacute$1$2,
	aacute: aacute$1$2,
	Acirc: Acirc$1$2,
	acirc: acirc$1$2,
	acute: acute$1$2,
	AElig: AElig$1$2,
	aelig: aelig$1$2,
	Agrave: Agrave$1$2,
	agrave: agrave$1$2,
	amp: amp$2$1,
	AMP: AMP$1$2,
	Aring: Aring$1$2,
	aring: aring$1$2,
	Atilde: Atilde$1$2,
	atilde: atilde$1$2,
	Auml: Auml$1$2,
	auml: auml$1$2,
	brvbar: brvbar$1$2,
	Ccedil: Ccedil$1$2,
	ccedil: ccedil$1$2,
	cedil: cedil$1$2,
	cent: cent$1$2,
	copy: copy$1$2,
	COPY: COPY$1$2,
	curren: curren$1$2,
	deg: deg$1$2,
	divide: divide$1$2,
	Eacute: Eacute$1$2,
	eacute: eacute$1$2,
	Ecirc: Ecirc$1$2,
	ecirc: ecirc$1$2,
	Egrave: Egrave$1$2,
	egrave: egrave$1$2,
	ETH: ETH$1$2,
	eth: eth$1$2,
	Euml: Euml$1$2,
	euml: euml$1$2,
	frac12: frac12$1$2,
	frac14: frac14$1$2,
	frac34: frac34$1$2,
	gt: gt$2$1,
	GT: GT$1$2,
	Iacute: Iacute$1$2,
	iacute: iacute$1$2,
	Icirc: Icirc$1$2,
	icirc: icirc$1$2,
	iexcl: iexcl$1$2,
	Igrave: Igrave$1$2,
	igrave: igrave$1$2,
	iquest: iquest$1$2,
	Iuml: Iuml$1$2,
	iuml: iuml$1$2,
	laquo: laquo$1$2,
	lt: lt$2$1,
	LT: LT$1$2,
	macr: macr$1$2,
	micro: micro$1$2,
	middot: middot$1$2,
	nbsp: nbsp$1$2,
	not: not$1$2,
	Ntilde: Ntilde$1$2,
	ntilde: ntilde$1$2,
	Oacute: Oacute$1$2,
	oacute: oacute$1$2,
	Ocirc: Ocirc$1$2,
	ocirc: ocirc$1$2,
	Ograve: Ograve$1$2,
	ograve: ograve$1$2,
	ordf: ordf$1$2,
	ordm: ordm$1$2,
	Oslash: Oslash$1$2,
	oslash: oslash$1$2,
	Otilde: Otilde$1$2,
	otilde: otilde$1$2,
	Ouml: Ouml$1$2,
	ouml: ouml$1$2,
	para: para$1$2,
	plusmn: plusmn$1$2,
	pound: pound$1$2,
	quot: quot$2$1,
	QUOT: QUOT$1$2,
	raquo: raquo$1$2,
	reg: reg$1$2,
	REG: REG$1$2,
	sect: sect$1$2,
	shy: shy$1$2,
	sup1: sup1$1$2,
	sup2: sup2$1$2,
	sup3: sup3$1$2,
	szlig: szlig$1$2,
	THORN: THORN$1$2,
	thorn: thorn$1$2,
	times: times$1$2,
	Uacute: Uacute$1$2,
	uacute: uacute$1$2,
	Ucirc: Ucirc$1$2,
	ucirc: ucirc$1$2,
	Ugrave: Ugrave$1$2,
	ugrave: ugrave$1$2,
	uml: uml$1$2,
	Uuml: Uuml$1$2,
	uuml: uuml$1$2,
	Yacute: Yacute$1$2,
	yacute: yacute$1$2,
	yen: yen$1$2,
	yuml: yuml$1$2
};

var _entities$1 = {
  encodeXML: encode$1.XML,
  decodeCodepoint: decode_codepoint$1,
  entitiesJSON: entitiesJSON$1,
  legacyJSON: legacyJSON$1,
  xmlJSON: xmlJSON$1
};

var _entities_decodeCodepoint = _entities$1.decodeCodepoint;

var _entities_decodeCodepoint$1 = Object.freeze({
	default: _entities_decodeCodepoint
});

var _entities_entitiesJSON = _entities$1.entitiesJSON;


var _entities_entitiesJSON$1 = Object.freeze({
	default: _entities_entitiesJSON
});

var _entities_legacyJSON = _entities$1.legacyJSON;

var _entities_legacyJSON$1 = Object.freeze({
	default: _entities_legacyJSON
});

var _entities_xmlJSON = _entities$1.xmlJSON;

var _entities_xmlJSON$1 = Object.freeze({
	default: _entities_xmlJSON
});

var require$$0$1$1$1 = ( _entities_decodeCodepoint$1 && _entities_decodeCodepoint ) || _entities_decodeCodepoint$1;

var require$$1$1$1 = ( _entities_entitiesJSON$1 && _entities_entitiesJSON ) || _entities_entitiesJSON$1;

var require$$2 = ( _entities_legacyJSON$1 && _entities_legacyJSON ) || _entities_legacyJSON$1;

var require$$3 = ( _entities_xmlJSON$1 && _entities_xmlJSON ) || _entities_xmlJSON$1;

var Tokenizer_1 = Tokenizer$1;

var decodeCodePoint$1$1 = require$$0$1$1$1;
var entityMap = require$$1$1$1;
var legacyMap = require$$2;
var xmlMap    = require$$3;
var i = 0;
var TEXT                      = i++;
var BEFORE_TAG_NAME           = i++;
var IN_TAG_NAME               = i++;
var IN_SELF_CLOSING_TAG       = i++;
var BEFORE_CLOSING_TAG_NAME   = i++;
var IN_CLOSING_TAG_NAME       = i++;
var AFTER_CLOSING_TAG_NAME    = i++;
var BEFORE_ATTRIBUTE_NAME     = i++;
var IN_ATTRIBUTE_NAME         = i++;
var AFTER_ATTRIBUTE_NAME      = i++;
var BEFORE_ATTRIBUTE_VALUE    = i++;
var IN_ATTRIBUTE_VALUE_DQ     = i++;
var IN_ATTRIBUTE_VALUE_SQ     = i++;
var IN_ATTRIBUTE_VALUE_NQ     = i++;
var BEFORE_DECLARATION        = i++;
var IN_DECLARATION            = i++;
var IN_PROCESSING_INSTRUCTION = i++;
var BEFORE_COMMENT            = i++;
var IN_COMMENT                = i++;
var AFTER_COMMENT_1           = i++;
var AFTER_COMMENT_2           = i++;
var BEFORE_CDATA_1            = i++;
var BEFORE_CDATA_2            = i++;
var BEFORE_CDATA_3            = i++;
var BEFORE_CDATA_4            = i++;
var BEFORE_CDATA_5            = i++;
var BEFORE_CDATA_6            = i++;
var IN_CDATA                  = i++;
var AFTER_CDATA_1             = i++;
var AFTER_CDATA_2             = i++;
var BEFORE_SPECIAL            = i++;
var BEFORE_SPECIAL_END        = i++;
var BEFORE_SCRIPT_1           = i++;
var BEFORE_SCRIPT_2           = i++;
var BEFORE_SCRIPT_3           = i++;
var BEFORE_SCRIPT_4           = i++;
var BEFORE_SCRIPT_5           = i++;
var AFTER_SCRIPT_1            = i++;
var AFTER_SCRIPT_2            = i++;
var AFTER_SCRIPT_3            = i++;
var AFTER_SCRIPT_4            = i++;
var AFTER_SCRIPT_5            = i++;
var BEFORE_STYLE_1            = i++;
var BEFORE_STYLE_2            = i++;
var BEFORE_STYLE_3            = i++;
var BEFORE_STYLE_4            = i++;
var AFTER_STYLE_1             = i++;
var AFTER_STYLE_2             = i++;
var AFTER_STYLE_3             = i++;
var AFTER_STYLE_4             = i++;
var BEFORE_ENTITY             = i++;
var BEFORE_NUMERIC_ENTITY     = i++;
var IN_NAMED_ENTITY           = i++;
var IN_NUMERIC_ENTITY         = i++;
var IN_HEX_ENTITY             = i++;
var j = 0;
var SPECIAL_NONE              = j++;
var SPECIAL_SCRIPT            = j++;
var SPECIAL_STYLE             = j++;

function whitespace(c){
	return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function characterState(char, SUCCESS){
	return function(c){
		if(c === char) { this._state = SUCCESS; }
	};
}

function ifElseState(upper, SUCCESS, FAILURE){
	var lower = upper.toLowerCase();

	if(upper === lower){
		return function(c){
			if(c === lower){
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	} else {
		return function(c){
			if(c === lower || c === upper){
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	}
}

function consumeSpecialNameChar(upper, NEXT_STATE){
	var lower = upper.toLowerCase();

	return function(c){
		if(c === lower || c === upper){
			this._state = NEXT_STATE;
		} else {
			this._state = IN_TAG_NAME;
			this._index--; 
		}
	};
}

function Tokenizer$1(options, cbs){
	this._state = TEXT;
	this._buffer = "";
	this._sectionStart = 0;
	this._index = 0;
	this._bufferOffset = 0; 
	this._baseState = TEXT;
	this._special = SPECIAL_NONE;
	this._cbs = cbs;
	this._running = true;
	this._ended = false;
	this._xmlMode = !!(options && options.xmlMode);
	this._decodeEntities = !!(options && options.decodeEntities);
}

Tokenizer$1.prototype._stateText = function(c){
	if(c === "<"){
		if(this._index > this._sectionStart){
			this._cbs.ontext(this._getSection());
		}
		this._state = BEFORE_TAG_NAME;
		this._sectionStart = this._index;
	} else if(this._decodeEntities && this._special === SPECIAL_NONE && c === "&"){
		if(this._index > this._sectionStart){
			this._cbs.ontext(this._getSection());
		}
		this._baseState = TEXT;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer$1.prototype._stateBeforeTagName = function(c){
	if(c === "/"){
		this._state = BEFORE_CLOSING_TAG_NAME;
	} else if(c === "<"){
		this._cbs.ontext(this._getSection());
		this._sectionStart = this._index;
	} else if(c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) {
		this._state = TEXT;
	} else if(c === "!"){
		this._state = BEFORE_DECLARATION;
		this._sectionStart = this._index + 1;
	} else if(c === "?"){
		this._state = IN_PROCESSING_INSTRUCTION;
		this._sectionStart = this._index + 1;
	} else {
		this._state = (!this._xmlMode && (c === "s" || c === "S")) ?
						BEFORE_SPECIAL : IN_TAG_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer$1.prototype._stateInTagName = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._emitToken("onopentagname");
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer$1.prototype._stateBeforeCloseingTagName = function(c){
	if(whitespace(c)){  }
	else if(c === ">"){
		this._state = TEXT;
	} else if(this._special !== SPECIAL_NONE){
		if(c === "s" || c === "S"){
			this._state = BEFORE_SPECIAL_END;
		} else {
			this._state = TEXT;
			this._index--;
		}
	} else {
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer$1.prototype._stateInCloseingTagName = function(c){
	if(c === ">" || whitespace(c)){
		this._emitToken("onclosetag");
		this._state = AFTER_CLOSING_TAG_NAME;
		this._index--;
	}
};

Tokenizer$1.prototype._stateAfterCloseingTagName = function(c){
	
	if(c === ">"){
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer$1.prototype._stateBeforeAttributeName = function(c){
	if(c === ">"){
		this._cbs.onopentagend();
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c === "/"){
		this._state = IN_SELF_CLOSING_TAG;
	} else if(!whitespace(c)){
		this._state = IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer$1.prototype._stateInSelfClosingTag = function(c){
	if(c === ">"){
		this._cbs.onselfclosingtag();
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(!whitespace(c)){
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer$1.prototype._stateInAttributeName = function(c){
	if(c === "=" || c === "/" || c === ">" || whitespace(c)){
		this._cbs.onattribname(this._getSection());
		this._sectionStart = -1;
		this._state = AFTER_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer$1.prototype._stateAfterAttributeName = function(c){
	if(c === "="){
		this._state = BEFORE_ATTRIBUTE_VALUE;
	} else if(c === "/" || c === ">"){
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if(!whitespace(c)){
		this._cbs.onattribend();
		this._state = IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer$1.prototype._stateBeforeAttributeValue = function(c){
	if(c === "\""){
		this._state = IN_ATTRIBUTE_VALUE_DQ;
		this._sectionStart = this._index + 1;
	} else if(c === "'"){
		this._state = IN_ATTRIBUTE_VALUE_SQ;
		this._sectionStart = this._index + 1;
	} else if(!whitespace(c)){
		this._state = IN_ATTRIBUTE_VALUE_NQ;
		this._sectionStart = this._index;
		this._index--; 
	}
};

Tokenizer$1.prototype._stateInAttributeValueDoubleQuotes = function(c){
	if(c === "\""){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer$1.prototype._stateInAttributeValueSingleQuotes = function(c){
	if(c === "'"){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer$1.prototype._stateInAttributeValueNoQuotes = function(c){
	if(whitespace(c) || c === ">"){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer$1.prototype._stateBeforeDeclaration = function(c){
	this._state = c === "[" ? BEFORE_CDATA_1 :
					c === "-" ? BEFORE_COMMENT :
						IN_DECLARATION;
};

Tokenizer$1.prototype._stateInDeclaration = function(c){
	if(c === ">"){
		this._cbs.ondeclaration(this._getSection());
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer$1.prototype._stateInProcessingInstruction = function(c){
	if(c === ">"){
		this._cbs.onprocessinginstruction(this._getSection());
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer$1.prototype._stateBeforeComment = function(c){
	if(c === "-"){
		this._state = IN_COMMENT;
		this._sectionStart = this._index + 1;
	} else {
		this._state = IN_DECLARATION;
	}
};

Tokenizer$1.prototype._stateInComment = function(c){
	if(c === "-") { this._state = AFTER_COMMENT_1; }
};

Tokenizer$1.prototype._stateAfterComment1 = function(c){
	if(c === "-"){
		this._state = AFTER_COMMENT_2;
	} else {
		this._state = IN_COMMENT;
	}
};

Tokenizer$1.prototype._stateAfterComment2 = function(c){
	if(c === ">"){
		
		this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c !== "-"){
		this._state = IN_COMMENT;
	}
	
};

Tokenizer$1.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION);
Tokenizer$1.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION);
Tokenizer$1.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION);
Tokenizer$1.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION);
Tokenizer$1.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION);

Tokenizer$1.prototype._stateBeforeCdata6 = function(c){
	if(c === "["){
		this._state = IN_CDATA;
		this._sectionStart = this._index + 1;
	} else {
		this._state = IN_DECLARATION;
		this._index--;
	}
};

Tokenizer$1.prototype._stateInCdata = function(c){
	if(c === "]") { this._state = AFTER_CDATA_1; }
};

Tokenizer$1.prototype._stateAfterCdata1 = characterState("]", AFTER_CDATA_2);

Tokenizer$1.prototype._stateAfterCdata2 = function(c){
	if(c === ">"){
		
		this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c !== "]") {
		this._state = IN_CDATA;
	}
	
};

Tokenizer$1.prototype._stateBeforeSpecial = function(c){
	if(c === "c" || c === "C"){
		this._state = BEFORE_SCRIPT_1;
	} else if(c === "t" || c === "T"){
		this._state = BEFORE_STYLE_1;
	} else {
		this._state = IN_TAG_NAME;
		this._index--; 
	}
};

Tokenizer$1.prototype._stateBeforeSpecialEnd = function(c){
	if(this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")){
		this._state = AFTER_SCRIPT_1;
	} else if(this._special === SPECIAL_STYLE && (c === "t" || c === "T")){
		this._state = AFTER_STYLE_1;
	}
	else { this._state = TEXT; }
};

Tokenizer$1.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2);
Tokenizer$1.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3);
Tokenizer$1.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4);
Tokenizer$1.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5);

Tokenizer$1.prototype._stateBeforeScript5 = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._special = SPECIAL_SCRIPT;
	}
	this._state = IN_TAG_NAME;
	this._index--; 
};

Tokenizer$1.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
Tokenizer$1.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
Tokenizer$1.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
Tokenizer$1.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);

Tokenizer$1.prototype._stateAfterScript5 = function(c){
	if(c === ">" || whitespace(c)){
		this._special = SPECIAL_NONE;
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 6;
		this._index--; 
	}
	else { this._state = TEXT; }
};

Tokenizer$1.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2);
Tokenizer$1.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3);
Tokenizer$1.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4);

Tokenizer$1.prototype._stateBeforeStyle4 = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._special = SPECIAL_STYLE;
	}
	this._state = IN_TAG_NAME;
	this._index--; 
};

Tokenizer$1.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
Tokenizer$1.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
Tokenizer$1.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);

Tokenizer$1.prototype._stateAfterStyle4 = function(c){
	if(c === ">" || whitespace(c)){
		this._special = SPECIAL_NONE;
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 5;
		this._index--; 
	}
	else { this._state = TEXT; }
};

Tokenizer$1.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);
Tokenizer$1.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY);


Tokenizer$1.prototype._parseNamedEntityStrict = function(){
	
	if(this._sectionStart + 1 < this._index){
		var entity = this._buffer.substring(this._sectionStart + 1, this._index),
		    map = this._xmlMode ? xmlMap : entityMap;

		if(map.hasOwnProperty(entity)){
			this._emitPartial(map[entity]);
			this._sectionStart = this._index + 1;
		}
	}
};



Tokenizer$1.prototype._parseLegacyEntity = function(){
	var this$1 = this;

	var start = this._sectionStart + 1,
	    limit = this._index - start;

	if(limit > 6) { limit = 6; } 

	while(limit >= 2){ 
		var entity = this$1._buffer.substr(start, limit);

		if(legacyMap.hasOwnProperty(entity)){
			this$1._emitPartial(legacyMap[entity]);
			this$1._sectionStart += limit + 1;
			return;
		} else {
			limit--;
		}
	}
};

Tokenizer$1.prototype._stateInNamedEntity = function(c){
	if(c === ";"){
		this._parseNamedEntityStrict();
		if(this._sectionStart + 1 < this._index && !this._xmlMode){
			this._parseLegacyEntity();
		}
		this._state = this._baseState;
	} else if((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")){
		if(this._xmlMode){  }
		else if(this._sectionStart + 1 === this._index){  }
		else if(this._baseState !== TEXT){
			if(c !== "="){
				this._parseNamedEntityStrict();
			}
		} else {
			this._parseLegacyEntity();
		}

		this._state = this._baseState;
		this._index--;
	}
};

Tokenizer$1.prototype._decodeNumericEntity = function(offset, base){
	var sectionStart = this._sectionStart + offset;

	if(sectionStart !== this._index){
		
		var entity = this._buffer.substring(sectionStart, this._index);
		var parsed = parseInt(entity, base);

		this._emitPartial(decodeCodePoint$1$1(parsed));
		this._sectionStart = this._index;
	} else {
		this._sectionStart--;
	}

	this._state = this._baseState;
};

Tokenizer$1.prototype._stateInNumericEntity = function(c){
	if(c === ";"){
		this._decodeNumericEntity(2, 10);
		this._sectionStart++;
	} else if(c < "0" || c > "9"){
		if(!this._xmlMode){
			this._decodeNumericEntity(2, 10);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

Tokenizer$1.prototype._stateInHexEntity = function(c){
	if(c === ";"){
		this._decodeNumericEntity(3, 16);
		this._sectionStart++;
	} else if((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")){
		if(!this._xmlMode){
			this._decodeNumericEntity(3, 16);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

Tokenizer$1.prototype._cleanup = function (){
	if(this._sectionStart < 0){
		this._buffer = "";
		this._bufferOffset += this._index;
		this._index = 0;
	} else if(this._running){
		if(this._state === TEXT){
			if(this._sectionStart !== this._index){
				this._cbs.ontext(this._buffer.substr(this._sectionStart));
			}
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else if(this._sectionStart === this._index){
			
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else {
			
			this._buffer = this._buffer.substr(this._sectionStart);
			this._index -= this._sectionStart;
			this._bufferOffset += this._sectionStart;
		}

		this._sectionStart = 0;
	}
};


Tokenizer$1.prototype.write = function(chunk){
	if(this._ended) { this._cbs.onerror(Error(".write() after done!")); }

	this._buffer += chunk;
	this._parse();
};

Tokenizer$1.prototype._parse = function(){
	var this$1 = this;

	while(this._index < this._buffer.length && this._running){
		var c = this$1._buffer.charAt(this$1._index);
		if(this$1._state === TEXT) {
			this$1._stateText(c);
		} else if(this$1._state === BEFORE_TAG_NAME){
			this$1._stateBeforeTagName(c);
		} else if(this$1._state === IN_TAG_NAME) {
			this$1._stateInTagName(c);
		} else if(this$1._state === BEFORE_CLOSING_TAG_NAME){
			this$1._stateBeforeCloseingTagName(c);
		} else if(this$1._state === IN_CLOSING_TAG_NAME){
			this$1._stateInCloseingTagName(c);
		} else if(this$1._state === AFTER_CLOSING_TAG_NAME){
			this$1._stateAfterCloseingTagName(c);
		} else if(this$1._state === IN_SELF_CLOSING_TAG){
			this$1._stateInSelfClosingTag(c);
		}

		
		else if(this$1._state === BEFORE_ATTRIBUTE_NAME){
			this$1._stateBeforeAttributeName(c);
		} else if(this$1._state === IN_ATTRIBUTE_NAME){
			this$1._stateInAttributeName(c);
		} else if(this$1._state === AFTER_ATTRIBUTE_NAME){
			this$1._stateAfterAttributeName(c);
		} else if(this$1._state === BEFORE_ATTRIBUTE_VALUE){
			this$1._stateBeforeAttributeValue(c);
		} else if(this$1._state === IN_ATTRIBUTE_VALUE_DQ){
			this$1._stateInAttributeValueDoubleQuotes(c);
		} else if(this$1._state === IN_ATTRIBUTE_VALUE_SQ){
			this$1._stateInAttributeValueSingleQuotes(c);
		} else if(this$1._state === IN_ATTRIBUTE_VALUE_NQ){
			this$1._stateInAttributeValueNoQuotes(c);
		}

		
		else if(this$1._state === BEFORE_DECLARATION){
			this$1._stateBeforeDeclaration(c);
		} else if(this$1._state === IN_DECLARATION){
			this$1._stateInDeclaration(c);
		}

		
		else if(this$1._state === IN_PROCESSING_INSTRUCTION){
			this$1._stateInProcessingInstruction(c);
		}

		
		else if(this$1._state === BEFORE_COMMENT){
			this$1._stateBeforeComment(c);
		} else if(this$1._state === IN_COMMENT){
			this$1._stateInComment(c);
		} else if(this$1._state === AFTER_COMMENT_1){
			this$1._stateAfterComment1(c);
		} else if(this$1._state === AFTER_COMMENT_2){
			this$1._stateAfterComment2(c);
		}

		
		else if(this$1._state === BEFORE_CDATA_1){
			this$1._stateBeforeCdata1(c);
		} else if(this$1._state === BEFORE_CDATA_2){
			this$1._stateBeforeCdata2(c);
		} else if(this$1._state === BEFORE_CDATA_3){
			this$1._stateBeforeCdata3(c);
		} else if(this$1._state === BEFORE_CDATA_4){
			this$1._stateBeforeCdata4(c);
		} else if(this$1._state === BEFORE_CDATA_5){
			this$1._stateBeforeCdata5(c);
		} else if(this$1._state === BEFORE_CDATA_6){
			this$1._stateBeforeCdata6(c);
		} else if(this$1._state === IN_CDATA){
			this$1._stateInCdata(c);
		} else if(this$1._state === AFTER_CDATA_1){
			this$1._stateAfterCdata1(c);
		} else if(this$1._state === AFTER_CDATA_2){
			this$1._stateAfterCdata2(c);
		}

		
		else if(this$1._state === BEFORE_SPECIAL){
			this$1._stateBeforeSpecial(c);
		} else if(this$1._state === BEFORE_SPECIAL_END){
			this$1._stateBeforeSpecialEnd(c);
		}

		
		else if(this$1._state === BEFORE_SCRIPT_1){
			this$1._stateBeforeScript1(c);
		} else if(this$1._state === BEFORE_SCRIPT_2){
			this$1._stateBeforeScript2(c);
		} else if(this$1._state === BEFORE_SCRIPT_3){
			this$1._stateBeforeScript3(c);
		} else if(this$1._state === BEFORE_SCRIPT_4){
			this$1._stateBeforeScript4(c);
		} else if(this$1._state === BEFORE_SCRIPT_5){
			this$1._stateBeforeScript5(c);
		}

		else if(this$1._state === AFTER_SCRIPT_1){
			this$1._stateAfterScript1(c);
		} else if(this$1._state === AFTER_SCRIPT_2){
			this$1._stateAfterScript2(c);
		} else if(this$1._state === AFTER_SCRIPT_3){
			this$1._stateAfterScript3(c);
		} else if(this$1._state === AFTER_SCRIPT_4){
			this$1._stateAfterScript4(c);
		} else if(this$1._state === AFTER_SCRIPT_5){
			this$1._stateAfterScript5(c);
		}

		
		else if(this$1._state === BEFORE_STYLE_1){
			this$1._stateBeforeStyle1(c);
		} else if(this$1._state === BEFORE_STYLE_2){
			this$1._stateBeforeStyle2(c);
		} else if(this$1._state === BEFORE_STYLE_3){
			this$1._stateBeforeStyle3(c);
		} else if(this$1._state === BEFORE_STYLE_4){
			this$1._stateBeforeStyle4(c);
		}

		else if(this$1._state === AFTER_STYLE_1){
			this$1._stateAfterStyle1(c);
		} else if(this$1._state === AFTER_STYLE_2){
			this$1._stateAfterStyle2(c);
		} else if(this$1._state === AFTER_STYLE_3){
			this$1._stateAfterStyle3(c);
		} else if(this$1._state === AFTER_STYLE_4){
			this$1._stateAfterStyle4(c);
		}

		
		else if(this$1._state === BEFORE_ENTITY){
			this$1._stateBeforeEntity(c);
		} else if(this$1._state === BEFORE_NUMERIC_ENTITY){
			this$1._stateBeforeNumericEntity(c);
		} else if(this$1._state === IN_NAMED_ENTITY){
			this$1._stateInNamedEntity(c);
		} else if(this$1._state === IN_NUMERIC_ENTITY){
			this$1._stateInNumericEntity(c);
		} else if(this$1._state === IN_HEX_ENTITY){
			this$1._stateInHexEntity(c);
		}

		else {
			this$1._cbs.onerror(Error("unknown _state"), this$1._state);
		}

		this$1._index++;
	}

	this._cleanup();
};

Tokenizer$1.prototype.pause = function(){
	this._running = false;
};
Tokenizer$1.prototype.resume = function(){
	this._running = true;

	if(this._index < this._buffer.length){
		this._parse();
	}
	if(this._ended){
		this._finish();
	}
};

Tokenizer$1.prototype.end = function(chunk){
	if(this._ended) { this._cbs.onerror(Error(".end() after done!")); }
	if(chunk) { this.write(chunk); }

	this._ended = true;

	if(this._running) { this._finish(); }
};

Tokenizer$1.prototype._finish = function(){
	
	if(this._sectionStart < this._index){
		this._handleTrailingData();
	}

	this._cbs.onend();
};

Tokenizer$1.prototype._handleTrailingData = function(){
	var data = this._buffer.substr(this._sectionStart);

	if(this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2){
		this._cbs.oncdata(data);
	} else if(this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2){
		this._cbs.oncomment(data);
	} else if(this._state === IN_NAMED_ENTITY && !this._xmlMode){
		this._parseLegacyEntity();
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(this._state === IN_NUMERIC_ENTITY && !this._xmlMode){
		this._decodeNumericEntity(2, 10);
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(this._state === IN_HEX_ENTITY && !this._xmlMode){
		this._decodeNumericEntity(3, 16);
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(
		this._state !== IN_TAG_NAME &&
		this._state !== BEFORE_ATTRIBUTE_NAME &&
		this._state !== BEFORE_ATTRIBUTE_VALUE &&
		this._state !== AFTER_ATTRIBUTE_NAME &&
		this._state !== IN_ATTRIBUTE_NAME &&
		this._state !== IN_ATTRIBUTE_VALUE_SQ &&
		this._state !== IN_ATTRIBUTE_VALUE_DQ &&
		this._state !== IN_ATTRIBUTE_VALUE_NQ &&
		this._state !== IN_CLOSING_TAG_NAME
	){
		this._cbs.ontext(data);
	}
	
	
};

Tokenizer$1.prototype.reset = function(){
	Tokenizer$1.call(this, {xmlMode: this._xmlMode, decodeEntities: this._decodeEntities}, this._cbs);
};

Tokenizer$1.prototype.getAbsoluteIndex = function(){
	return this._bufferOffset + this._index;
};

Tokenizer$1.prototype._getSection = function(){
	return this._buffer.substring(this._sectionStart, this._index);
};

Tokenizer$1.prototype._emitToken = function(name){
	this._cbs[name](this._getSection());
	this._sectionStart = -1;
};

Tokenizer$1.prototype._emitPartial = function(value){
	if(this._baseState !== TEXT){
		this._cbs.onattribdata(value); 
	} else {
		this._cbs.ontext(value);
	}
};

var _inherits = function() {};

var _inherits$1 = Object.freeze({
	default: _inherits
});

var _resolve_empty = {};

var _resolve_empty$1 = Object.freeze({
	default: _resolve_empty
});

var require$$1$2 = ( _inherits$1 && _inherits ) || _inherits$1;

var require$$2$1 = ( _resolve_empty$1 && _resolve_empty ) || _resolve_empty$1;

var Tokenizer$1$1 = Tokenizer_1;





var formTags = {
	input: true,
	option: true,
	optgroup: true,
	select: true,
	button: true,
	datalist: true,
	textarea: true
};

var openImpliesClose = {
	tr      : { tr:true, th:true, td:true },
	th      : { th:true },
	td      : { thead:true, th:true, td:true },
	body    : { head:true, link:true, script:true },
	li      : { li:true },
	p       : { p:true },
	h1      : { p:true },
	h2      : { p:true },
	h3      : { p:true },
	h4      : { p:true },
	h5      : { p:true },
	h6      : { p:true },
	select  : formTags,
	input   : formTags,
	output  : formTags,
	button  : formTags,
	datalist: formTags,
	textarea: formTags,
	option  : { option:true },
	optgroup: { optgroup:true }
};

var voidElements = {
	__proto__: null,
	area: true,
	base: true,
	basefont: true,
	br: true,
	col: true,
	command: true,
	embed: true,
	frame: true,
	hr: true,
	img: true,
	input: true,
	isindex: true,
	keygen: true,
	link: true,
	meta: true,
	param: true,
	source: true,
	track: true,
	wbr: true,

	
	path: true,
	circle: true,
	ellipse: true,
	line: true,
	rect: true,
	use: true,
	stop: true,
	polyline: true,
	polygon: true
};

var re_nameEnd = /\s|\//;

function Parser$1(cbs, options){
	this._options = options || {};
	this._cbs = cbs || {};

	this._tagname = "";
	this._attribname = "";
	this._attribvalue = "";
	this._attribs = null;
	this._stack = [];

	this.startIndex = 0;
	this.endIndex = null;

	this._lowerCaseTagNames = "lowerCaseTags" in this._options ?
									!!this._options.lowerCaseTags :
									!this._options.xmlMode;
	this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ?
									!!this._options.lowerCaseAttributeNames :
									!this._options.xmlMode;

	if(this._options.Tokenizer) {
		Tokenizer$1$1 = this._options.Tokenizer;
	}
	this._tokenizer = new Tokenizer$1$1(this._options, this);

	if(this._cbs.onparserinit) { this._cbs.onparserinit(this); }
}

require$$1$2(Parser$1, require$$2$1.EventEmitter);

Parser$1.prototype._updatePosition = function(initialOffset){
	if(this.endIndex === null){
		if(this._tokenizer._sectionStart <= initialOffset){
			this.startIndex = 0;
		} else {
			this.startIndex = this._tokenizer._sectionStart - initialOffset;
		}
	}
	else { this.startIndex = this.endIndex + 1; }
	this.endIndex = this._tokenizer.getAbsoluteIndex();
};


Parser$1.prototype.ontext = function(data){
	this._updatePosition(1);
	this.endIndex--;

	if(this._cbs.ontext) { this._cbs.ontext(data); }
};

Parser$1.prototype.onopentagname = function(name){
	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	this._tagname = name;

	if(!this._options.xmlMode && name in openImpliesClose) {
		for(
			var el;
			(el = this._stack[this._stack.length - 1]) in openImpliesClose[name];
			this.onclosetag(el)
		){  }
	}

	if(this._options.xmlMode || !(name in voidElements)){
		this._stack.push(name);
	}

	if(this._cbs.onopentagname) { this._cbs.onopentagname(name); }
	if(this._cbs.onopentag) { this._attribs = {}; }
};

Parser$1.prototype.onopentagend = function(){
	this._updatePosition(1);

	if(this._attribs){
		if(this._cbs.onopentag) { this._cbs.onopentag(this._tagname, this._attribs); }
		this._attribs = null;
	}

	if(!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements){
		this._cbs.onclosetag(this._tagname);
	}

	this._tagname = "";
};

Parser$1.prototype.onclosetag = function(name){
	var this$1 = this;

	this._updatePosition(1);
	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}
	
	
	
	if(this._options.xmlMode) {
		var stack = this._stack;
		var last = stack.pop();
		while(last !== name) {
			if(this$1._cbs.onerror) {
				this$1._cbs.onerror("Unclosed tag <"+last+">");
			}
			last = stack.pop();
		}
		this.onopentagend();
		if(this._cbs.onclosetag) {
			this._cbs.onclosetag(last);
		}
	} else {
		if(this._stack.length && (!(name in voidElements))) {
			var pos = this._stack.lastIndexOf(name);
			if(pos !== -1){
				if(this._cbs.onclosetag){
					pos = this._stack.length - pos;
					while(pos--) { this$1._cbs.onclosetag(this$1._stack.pop()); }
				}
				else { this._stack.length = pos; }
			} else if(name === "p"){
				this.onopentagname(name);
				this._closeCurrentTag();
			}
		} else if(name === "br" || name === "p"){
			this.onopentagname(name);
			this._closeCurrentTag();
		}
	}
};

Parser$1.prototype.onselfclosingtag = function(){
	if(this._options.xmlMode || this._options.recognizeSelfClosing){
		this._closeCurrentTag();
	} else {
		this.onopentagend();
	}
};

Parser$1.prototype._closeCurrentTag = function(){
	var name = this._tagname;

	this.onopentagend();

	
	
	if(this._stack[this._stack.length - 1] === name){
		if(this._cbs.onclosetag){
			this._cbs.onclosetag(name);
		}
		this._stack.pop();
	}
};

Parser$1.prototype.onattribname = function(name){
	if(this._lowerCaseAttributeNames){
		name = name.toLowerCase();
	}
	this._attribname = name;
};

Parser$1.prototype.onattribdata = function(value){
	this._attribvalue += value;
};

Parser$1.prototype.onattribend = function(){
	if(this._cbs.onattribute) { this._cbs.onattribute(this._attribname, this._attribvalue); }
	if(
		this._attribs &&
		!Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)
	){
		this._attribs[this._attribname] = this._attribvalue;
	}
	this._attribname = "";
	this._attribvalue = "";
};

Parser$1.prototype._getInstructionName = function(value){
	var idx = value.search(re_nameEnd),
	    name = idx < 0 ? value : value.substr(0, idx);

	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	return name;
};

Parser$1.prototype.ondeclaration = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("!" + name, "!" + value);
	}
};

Parser$1.prototype.onprocessinginstruction = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("?" + name, "?" + value);
	}
};

Parser$1.prototype.oncomment = function(value){
	this._updatePosition(4);

	if(this._cbs.oncomment) { this._cbs.oncomment(value); }
	if(this._cbs.oncommentend) { this._cbs.oncommentend(); }
};

Parser$1.prototype.oncdata = function(value){
	this._updatePosition(1);

	if(this._options.xmlMode || this._options.recognizeCDATA){
		if(this._cbs.oncdatastart) { this._cbs.oncdatastart(); }
		if(this._cbs.ontext) { this._cbs.ontext(value); }
		if(this._cbs.oncdataend) { this._cbs.oncdataend(); }
	} else {
		this.oncomment("[CDATA[" + value + "]]");
	}
};

Parser$1.prototype.onerror = function(err){
	if(this._cbs.onerror) { this._cbs.onerror(err); }
};

Parser$1.prototype.onend = function(){
	if(this._cbs.onclosetag){
		for(
			var i = this._stack.length;
			i > 0;
			this._cbs.onclosetag(this._stack[--i])
		){  }
	}
	if(this._cbs.onend) { this._cbs.onend(); }
};



Parser$1.prototype.reset = function(){
	if(this._cbs.onreset) { this._cbs.onreset(); }
	this._tokenizer.reset();

	this._tagname = "";
	this._attribname = "";
	this._attribs = null;
	this._stack = [];

	if(this._cbs.onparserinit) { this._cbs.onparserinit(this); }
};


Parser$1.prototype.parseComplete = function(data){
	this.reset();
	this.end(data);
};

Parser$1.prototype.write = function(chunk){
	this._tokenizer.write(chunk);
};

Parser$1.prototype.end = function(chunk){
	this._tokenizer.end(chunk);
};

Parser$1.prototype.pause = function(){
	this._tokenizer.pause();
};

Parser$1.prototype.resume = function(){
	this._tokenizer.resume();
};


Parser$1.prototype.parseChunk = Parser$1.prototype.write;
Parser$1.prototype.done = Parser$1.prototype.end;

var Parser_1 = Parser$1;

Parser_1.prototype.oncdata = function(value){
  this._updatePosition(1);

  if(this._options.xmlMode || this._options.recognizeCDATA){
    if(this._cbs.oncdatastart) { this._cbs.oncdatastart(value); }
    
    if(this._cbs.oncdataend) { this._cbs.oncdataend(); }
  } else {
    this.oncomment("[CDATA[" + value + "]]");
  }
};

function parseMarkup(markup, options) {
  var format = options.ownerDocument ? options.ownerDocument.format : options.format;
  
  if (!format) {
    throw new Error("Either 'ownerDocument' or 'format' must be set.")
  }
  var parserOptions = {
    xmlMode : (format === 'xml')
  };
  var handler = new DomHandler({ format: format });
  var parser = new Parser_1(handler, parserOptions);
  parser.end(markup);
  return handler.document
}


var re_whitespace = /\s+/g;


var DomHandler = function DomHandler(options) {
  if ( options === void 0 ) options = {};

  this.options = options;
  this.document = null;
  this._tagStack = [];
};


DomHandler.prototype.onparserinit = function onparserinit (){
  this.document = new MemoryDOMElement('document', { format: this.options.format });
  this._tagStack = [this.document];
};

DomHandler.prototype.onend = function onend (){
  
  if (this._tagStack.length>1) {
    throw new Error("Unexpected EOF. Tag was opened but not closed.")
  }
};

DomHandler.prototype.onerror = function onerror (error) {
  throw new Error(error)
};

DomHandler.prototype.onclosetag = function onclosetag () {
  this._tagStack.pop();
};

DomHandler.prototype._addDomElement = function _addDomElement (element) {
  var parent = this._tagStack[this._tagStack.length - 1];
  if (!parent.childNodes) { parent.childNodes = []; }
  var siblings = parent.childNodes;

  var previousSibling = siblings[siblings.length - 1];
  
  element.next = null;
  if(previousSibling){
    element.prev = previousSibling;
    previousSibling.next = element;
  } else {
    element.prev = null;
  }
  
  siblings.push(element);
  element.parent = parent || null;
};

DomHandler.prototype.onopentag = function onopentag (name, attributes) {
  var element = this.document.createElement(name);
  forEach(attributes, function (val, key) {
    element.setAttribute(key, val);
  });
  this._addDomElement(element);
  this._tagStack.push(element);
};

DomHandler.prototype.ontext = function ontext (text) {
  if (this.options.normalizeWhitespace) {
    text = text.replace(re_whitespace, " ");
  }
  var lastTag;
  var _top = this._tagStack[this._tagStack.length - 1];
  if (_top && _top.childNodes) { lastTag = _top.childNodes[_top.childNodes.length - 1]; }
  if (lastTag && lastTag.type === index.Text) {
    lastTag.data += text;
  } else {
    var element = this.document.createTextNode(text);
    this._addDomElement(element);
  }
};

DomHandler.prototype.oncomment = function oncomment (data) {
  var lastTag = this._tagStack[this._tagStack.length - 1];
  if(lastTag && lastTag.type === index.Comment){
    lastTag.data += data;
  } else {
    var element = this.document.createComment(data);
    this._addDomElement(element);
    this._tagStack.push(element);
  }
};

DomHandler.prototype.oncommentend = function oncommentend () {
  this._tagStack.pop();
};

DomHandler.prototype.oncdatastart = function oncdatastart (data) {
  var element = this.document.createCDATASection(data);
  this._addDomElement(element);
  this._tagStack.push(element);
};

DomHandler.prototype.oncdataend = function oncdataend () {
  this._tagStack.pop();
};

DomHandler.prototype.onprocessinginstruction = function onprocessinginstruction (name, data) {
  var element = this.document.createProcessingInstruction(name, data);
  this._addDomElement(element);
};

var MemoryDOMElement = (function (DOMElement$$1) {
  function MemoryDOMElement(type, args) {
    if ( args === void 0 ) args = {};

    DOMElement$$1.call(this);

    this.type = type;
    if (!type) { throw new Error("'type' is mandatory") }

    this.ownerDocument = args.ownerDocument;
    
    if (type !== 'document' && !this.ownerDocument) {
      throw new Error("'ownerDocument' is mandatory")
    }

    
    
    

    switch(type) {
      case index.Tag: {
        if (!args.name) { throw new Error("'name' is mandatory.") }
        this.name = this._normalizeName(args.name);
        this.nameWithoutNS = nameWithoutNS(this.name);
        this.properties = new Map();
        this.attributes = new Map();
        this.classes = new Set();
        this.styles = new Map();
        this.eventListeners = [];
        this.childNodes = args.children || args.childNodes || [];
        this._assign(args);
        break
      }
      case index.Text:
      case index.Comment: {
        this.data = args.data || '';
        break
      }
      case index.CDATA: {
        this.data = args.data || '';
        break
      }
      case index.Directive: {
        if (!args.name) { throw new Error("'name' is mandatory.") }
        this.name = this._normalizeName(args.name);
        this.nameWithoutNS = nameWithoutNS(this.name);
        this.data = args.data;
        break
      }
      case 'document': {
        var format = args.format;
        this.format = format;
        if (!format) { throw new Error("'format' is mandatory.") }
        this.childNodes = args.children || args.childNodes || [];
        switch(format) {
          case 'xml':
            this.contentType = 'application/xml';
            break
          case 'html':
            this.contentType = 'text/html';
            break
          default:
            throw new Error('Unsupported format ' + format)
        }
        break
      }
      default:
        this.name = null;
        this.properties = new Map();
        this.attributes = new Map();
        this.classes = new Set();
        this.styles = new Map();
        this.eventListeners = [];
        this.childNodes = args.children || args.childNodes || [];
    }
  }

  if ( DOMElement$$1 ) MemoryDOMElement.__proto__ = DOMElement$$1;
  MemoryDOMElement.prototype = Object.create( DOMElement$$1 && DOMElement$$1.prototype );
  MemoryDOMElement.prototype.constructor = MemoryDOMElement;

  var prototypeAccessors = { tagName: {},children: {} };

  MemoryDOMElement.prototype.getNativeElement = function getNativeElement () {
    return this
  };

  MemoryDOMElement.prototype.getNodeType = function getNodeType () {
    switch(this.type) {
      case index.Tag:
      case index.Script:
      case index.Style:
        return 'element'
      default:
        return this.type
    }
  };

  MemoryDOMElement.prototype.isTextNode = function isTextNode () {
    return this.type === "text"
  };

  MemoryDOMElement.prototype.isElementNode = function isElementNode () {
    return this.type === "tag" || this.type === "script"
  };

  MemoryDOMElement.prototype.isCommentNode = function isCommentNode () {
    return this.type === "comment"
  };

  MemoryDOMElement.prototype.isDocumentNode = function isDocumentNode () {
    return this.type === "document"
  };

  MemoryDOMElement.prototype.isComponentNode = function isComponentNode () {
    return this.type === "component"
  };

  MemoryDOMElement.prototype.clone = function clone$$1 (deep) {
    var clone$$1 = new MemoryDOMElement(this.type, this);
    if (this.childNodes) {
      clone$$1.childNodes.length = 0;
      if (deep) {
        this.childNodes.forEach(function (child) {
          clone$$1.appendChild(child.clone(deep));
        });
      }
    }
    return clone$$1
  };

  prototypeAccessors.tagName.get = function () {
    return this.getTagName()
  };

  prototypeAccessors.tagName.set = function (tagName) {
    this.setTagName(tagName);
  };

  MemoryDOMElement.prototype.getTagName = function getTagName () {
    return this.name
  };

  MemoryDOMElement.prototype.setTagName = function setTagName (tagName) {
    if (this._isXML()) {
      this.name = String(tagName);
    } else {
      this.name = String(tagName).toLowerCase();
    }
    return this
  };

  MemoryDOMElement.prototype.hasAttribute = function hasAttribute (name) {
    return this.attributes.has(name)
  };

  MemoryDOMElement.prototype.getAttribute = function getAttribute (name) {
    return this.attributes.get(name)
  };

  MemoryDOMElement.prototype.setAttribute = function setAttribute (name, value) {
    value = String(value);
    
    switch(name) {
      case 'class':
        parseClasses(this.classes, value);
        break
      case 'style':
        parseStyles(this.styles, value);
        break
      default:
        
    }
    this.attributes.set(name, value);
    if (this._isHTML()) {
      deriveHTMLPropertyFromAttribute(this, name, value);
    }
    return this
  };

  MemoryDOMElement.prototype.removeAttribute = function removeAttribute (name) {
    switch(name) {
      case 'class':
        this.classes = new Set();
        break
      case 'style':
        this.styles = new Map();
        break
      default:
        
    }
    this.attributes.delete(name);
    return this
  };

  MemoryDOMElement.prototype.getAttributes = function getAttributes () {
    return this.attributes
  };

  MemoryDOMElement.prototype.getProperty = function getProperty (name) {
    if (this.properties) {
      return this.properties.get(name)
    }
  };

  MemoryDOMElement.prototype.setProperty = function setProperty (name, value) {
    if (this.properties) {
      if (this._isXML()) {
        throw new Error('setProperty() is only be used on HTML elements')
      }
      _setHTMLPropertyValue(this, name, value);
    }
    return this
  };

  MemoryDOMElement.prototype.hasClass = function hasClass (name) {
    if (this.classes) {
      return this.classes.has(name)
    }
  };

  MemoryDOMElement.prototype.addClass = function addClass (name) {
    this.classes.add(name);
    this.attributes.set('class', stringifyClasses(this.classes));
    return this
  };

  MemoryDOMElement.prototype.removeClass = function removeClass (name) {
    if (this.classes && this.classes.has(name)) {
      this.classes.delete(name);
      this.attributes.set('class', stringifyClasses(this.classes));
    }
    return this
  };

  MemoryDOMElement.prototype.getContentType = function getContentType () {
    return this.getOwnerDocument().contentType
  };

  MemoryDOMElement.prototype.getInnerHTML = function getInnerHTML () {
    return index$2.getInnerHTML(this)
  };

  
  
  MemoryDOMElement.prototype.setInnerHTML = function setInnerHTML (html) {
    var this$1 = this;

    if (this.childNodes) {
      var _doc = parseMarkup(html, {
        ownerDocument: this.getOwnerDocument()
      });
      this.empty();
      
      
      _doc.childNodes.slice(0).forEach(function (child) {
        this$1.appendChild(child);
      });
    }
    return this
  };

  MemoryDOMElement.prototype.getOuterHTML = function getOuterHTML () {
    return index$2.getOuterHTML(this, { xmlMode: this._isXML() })
  };

  MemoryDOMElement.prototype.getTextContent = function getTextContent () {
    return index$2.getText(this)
  };

  MemoryDOMElement.prototype.setTextContent = function setTextContent (text) {
    switch(this.type) {
      case index.Text:
      case index.Comment:
      case index.CDATA: {
        this.data = text;
        break
      }
      default: {
        if (this.childNodes) {
          var child = this.createTextNode(text);
          this.empty();
          this.appendChild(child);
        }
      }
    }
    return this
  };

  MemoryDOMElement.prototype.getStyle = function getStyle (name) {
    if (this.styles) {
      return this.styles.get(name)
    }
  };

  MemoryDOMElement.prototype.setStyle = function setStyle (name, value) {
    if (this.styles) {
      if (DOMElement$$1.pxStyles[name] && isNumber(value)) {
        value = value + "px";
      }
      this.styles.set(name, value);
      this.attributes.set('style', stringifyStyles(this.styles));
    }
    return this
  };

  MemoryDOMElement.prototype.is = function is (cssSelector) {
    return index$1.is(this, cssSelector, { xmlMode: this._isXML() })
  };

  MemoryDOMElement.prototype.find = function find$$1 (cssSelector) {
    return index$1.selectOne(cssSelector, this, { xmlMode: this._isXML() })
  };

  MemoryDOMElement.prototype.findAll = function findAll (cssSelector) {
    return index$1.selectAll(cssSelector, this, { xmlMode: this._isXML() })
  };

  MemoryDOMElement.prototype.getChildCount = function getChildCount () {
    if (this.childNodes) {
      return this.childNodes.length
    } else {
      return 0
    }
  };

  MemoryDOMElement.prototype.getChildNodes = function getChildNodes () {
    return this.childNodes.slice(0)
  };

  MemoryDOMElement.prototype.getChildren = function getChildren () {
    return this.childNodes.filter(function(node) {
      return node.type === "tag"
    })
  };

  prototypeAccessors.children.get = function () {
    return this.getChildren()
  };

  MemoryDOMElement.prototype.getChildAt = function getChildAt (pos) {
    if (this.childNodes) {
      return this.childNodes[pos]
    }
  };

  MemoryDOMElement.prototype.getChildIndex = function getChildIndex (child) {
    if (this.childNodes) {
      return this.childNodes.indexOf(child)
    }
  };

  MemoryDOMElement.prototype.getLastChild = function getLastChild () {
    if (this.childNodes) {
      return last$1(this.childNodes)
    }
  };

  MemoryDOMElement.prototype.getFirstChild = function getFirstChild () {
    if (this.childNodes) {
      return this.childNodes[0]
    }
  };

  MemoryDOMElement.prototype.getNextSibling = function getNextSibling () {
    return this.next
  };

  MemoryDOMElement.prototype.getPreviousSibling = function getPreviousSibling () {
    return this.prev
  };

  MemoryDOMElement.prototype.getParent = function getParent () {
    return this.parent
  };

  MemoryDOMElement.prototype.getOwnerDocument = function getOwnerDocument () {
    return (this.type === 'document') ? this : this.ownerDocument
  };

  MemoryDOMElement.prototype.getFormat = function getFormat () {
    return this.getOwnerDocument().format
  };

  MemoryDOMElement.prototype.createDocument = function createDocument (format) {
    return MemoryDOMElement.createDocument(format)
  };

  MemoryDOMElement.prototype.createElement = function createElement (tagName) {
    return new MemoryDOMElement(index.Tag, { name: tagName, ownerDocument: this.getOwnerDocument() })
  };

  MemoryDOMElement.prototype.createTextNode = function createTextNode (text) {
    return new MemoryDOMElement(index.Text, { data: text, ownerDocument: this.getOwnerDocument() })
  };

  MemoryDOMElement.prototype.createComment = function createComment (data) {
    return new MemoryDOMElement(index.Comment, { data: data, ownerDocument: this.getOwnerDocument() })
  };

  MemoryDOMElement.prototype.createProcessingInstruction = function createProcessingInstruction (name, data) {
    return new MemoryDOMElement(index.Directive, { name: name, data: data, ownerDocument: this.getOwnerDocument() })
  };

  MemoryDOMElement.prototype.createCDATASection = function createCDATASection (data) {
    return new MemoryDOMElement(index.CDATA, { data: data, ownerDocument: this.getOwnerDocument() })
  };

  MemoryDOMElement.prototype.appendChild = function appendChild (child) {
    if (this.childNodes && !isNil(child)) {
      child = this._normalizeChild(child);
      if (!child) { return this }
      index$2.appendChild(this, child);
      child.ownerDocument = this.getOwnerDocument();
    }
    return this
  };

  MemoryDOMElement.prototype.removeChild = function removeChild (child) {
    if (child.parentNode === this) {
      child.remove();
    }
  };

  MemoryDOMElement.prototype.insertAt = function insertAt (pos, child) {
    child = this._normalizeChild(child);
    if (!child) { return this }
    var childNodes = this.childNodes;
    if (childNodes) {
      
      if (pos >= childNodes.length) {
        index$2.appendChild(this, child);
      } else {
        index$2.prepend(childNodes[pos], child);
      }
      child.ownerDocument = this.getOwnerDocument();
    }
    return this
  };

  MemoryDOMElement.prototype.insertBefore = function insertBefore (newChild, before) {
    if (this.childNodes) {
      var pos = this.childNodes.indexOf(before);
      if (pos > -1) {
        index$2.prepend(before, newChild);
        newChild.ownerDocument = this.getOwnerDocument();
      } else {
        throw new Error('insertBefore(): reference node is not a child of this element.')
      }
    }
    return this
  };

  MemoryDOMElement.prototype.removeAt = function removeAt (pos) {
    var childNodes = this.childNodes;
    if (childNodes) {
      var child = childNodes[pos];
      child.remove();
    }
    return this
  };

  MemoryDOMElement.prototype.empty = function empty () {
    var childNodes = this.childNodes;
    if (childNodes) {
      childNodes.forEach(function (child) {
        child.next = child.prev = child.parent = null;
      });
      childNodes.length = 0;
    }
    return this
  };

  MemoryDOMElement.prototype.remove = function remove () {
    index$2.removeElement(this);
    return this
  };

  MemoryDOMElement.prototype.replaceChild = function replaceChild (oldChild, newChild) {
    if (oldChild.parent === this) {
      oldChild.replaceWith(newChild);
    }
    return this
  };

  MemoryDOMElement.prototype.replaceWith = function replaceWith (newEl) {
    newEl = this._normalizeChild(newEl);
    index$2.replaceElement(this, newEl);
    newEl.ownerDocument = this.getOwnerDocument();
    return this
  };

  MemoryDOMElement.prototype.getEventListeners = function getEventListeners () {
    return this.eventListeners
  };

  MemoryDOMElement.prototype.click = function click () {
    this.emit('click', { target: this });
    return this
  };

  MemoryDOMElement.prototype.emit = function emit (name, data) {
    this._propagateEvent(new MemoryDOMElementEvent(name, this, data));
  };

  MemoryDOMElement.prototype._propagateEvent = function _propagateEvent (event) {
    var listeners = this.eventListeners;
    if (listeners) {
      var listener = listeners.find(function (l) {
        return l.eventName === event.type
      });
      if (listener) { listener.handler(event); }
      if (event.stopped) { return }
      var p = this.parentNode;
      if (p) { p._propagateEvent(event); }
    }
  };

  MemoryDOMElement.prototype.removeAllEventListeners = function removeAllEventListeners () {
    this.eventListeners = [];
    return this
  };

  MemoryDOMElement.prototype._assign = function _assign (other) {
    var this$1 = this;

    if (other.name) { this.name = other.name; }
    if (this.classes && other.classes) {
      other.classes.forEach(function (val) {
        this$1.classes.add(val);
      });
    }
    if (this.styles && other.styles) {
      forEach(other.styles, function (val, name) {
        this$1.styles.set(name, val);
      });
    }
    
    
    var otherAttributes = other.attributes || other.attribs;
    if (this.attributes && otherAttributes) {
      forEach(otherAttributes, function (val, name) {
        switch (name) {
          case 'class': {
            parseClasses(this$1.classes, val);
            break
          }
          case 'style': {
            parseStyles(this$1.styles, val);
            break
          }
          default:
            this$1.attributes.set(name, val);
        }
      });
    }
    if (this.eventListeners && other.eventListeners) {
      this.eventListeners = this.eventListeners.concat(other.eventListeners);
    }
  };

  MemoryDOMElement.prototype._normalizeChild = function _normalizeChild (child) {
    if (isString$1(child)) {
      child = this.createTextNode(child);
    }
    
    if (!child || !child._isMemoryDOMElement) {
      throw new Error('Illegal argument: only String and MemoryDOMElement instances are valid.')
    }
    return child
  };

  MemoryDOMElement.prototype._normalizeName = function _normalizeName (name) {
    if (this._isXML()) {
      return name
    } else {
      return name.toLowerCase()
    }
  };

  MemoryDOMElement.prototype._isHTML = function _isHTML () {
    return this.getFormat() === 'html'
  };

  MemoryDOMElement.prototype._isXML = function _isXML () {
    return this.getFormat() === 'xml'
  };

  Object.defineProperties( MemoryDOMElement.prototype, prototypeAccessors );

  return MemoryDOMElement;
}(DOMElement));

MemoryDOMElement.prototype._isMemoryDOMElement = true;

MemoryDOMElement.createDocument = function(format) {
  if (format === 'xml') {
    return new MemoryDOMElement('document', { format: format })
  } else {
    return MemoryDOMElement.parseMarkup(DOMElement.EMPTY_HTML, 'html')
  }
};

MemoryDOMElement.parseMarkup = function(str, format, options) {
  if ( options === void 0 ) options={};

  if (!str) {
    return MemoryDOMElement.createDocument(format)
  }
  if (options.snippet) {
    str = "<__snippet__>" + str + "</__snippet__>";
  }
  var doc;
  if (format === 'html') {
    doc = parseMarkup(str, { format: format });
    _sanitizeHTMLStructure(doc);
  } else if (format === 'xml') {
    doc = parseMarkup(str, { format: format });
  }
  if (options.snippet) {
    var childNodes = doc.find('__snippet__').childNodes;
    if (childNodes.length === 1) {
      return childNodes[0]
    } else {
      return childNodes
    }
  } else {
    return doc
  }
};

MemoryDOMElement.wrap =
MemoryDOMElement.wrapNativeElement = function(el) {
  if (inBrowser) {
    
    
    
    
    if (el === window || el === window.document) {
      return new DOMElementStub()
    }
    
    
    
    else if (el instanceof window.Node || el._isBrowserDOMElement) {
      
    }
  }
  
  if (!el._isMemoryDOMElement) {
    throw new Error('Illegal argument: expected MemoryDOMElement instance')
  }
  return el
};

MemoryDOMElement.unwrap = function(el) {
  
  if (!el._isMemoryDOMElement) {
    throw new Error('Illegal argument: expected MemoryDOMElement instance')
  }
  return el
};




MemoryDOMElement.isReverse = function() {
  return false
};

function parseClasses(classes, classStr) {
  classStr.split(/\s+/).forEach(function (name) {
    classes.add(name);
  });
}

function stringifyClasses(classes) {
  return Array.from(classes).join(' ')
}

function parseStyles(styles, styleStr) {
  styleStr = (styleStr || '').trim();
  if (!styleStr) { return }
  styleStr.split(';').forEach(function (style) {
    var n = style.indexOf(':');
    
    if (n < 1 || n === style.length-1) { return }
    var name = style.slice(0,n).trim();
    var val = style.slice(n+1).trim();
    styles.set(name, val);
  });
}

function stringifyStyles(styles) {
  if (!styles) { return '' }
  var str = Object.keys(styles).map(function (name) {
    return name + ':' + styles[name]
  }).join(';');
  if (str.length > 0) { str += ';'; }
  return str
}

var BUILTIN_EVENTS = [
  'keydown', 'keyup', 'keypress',
  'mousedown', 'mouseup', 'mouseover', 'click', 'dblclick'
].reduce(function (m, k){m[k]=true;return m}, {});

var MemoryDOMElementEvent = function MemoryDOMElementEvent(type, target, detail) {
  this.type = type;
  this.timeStamp = Date.now();
  this.target = target;

  if (BUILTIN_EVENTS[type]) {
    
    if (detail) {
      Object.assign(this, detail);
    }
  } else {
    this.detail = detail;
  }
};

MemoryDOMElementEvent.prototype.stopPropagation = function stopPropagation () {
  this.stopped = true;
};

MemoryDOMElementEvent.prototype.preventDefault = function preventDefault () {
  this.defaultPrevented = true;
};

var DOMElementStub = function DOMElementStub () {};

DOMElementStub.prototype.on = function on () {};
DOMElementStub.prototype.off = function off (){};

function nameWithoutNS(name) {
  var idx = name.indexOf(':');
  if (idx > 0) {
    return name.slice(idx+1)
  } else {
    return name
  }
}



var ATTR_TO_PROPS = {
  "input": {
    "value": true,
    "checked": function (el, name, value) {
      var checked = (value !== 'off');
      el.setProperty('checked', checked);
    }
  }
};

function deriveHTMLPropertyFromAttribute(el, name, value) {
  var mappings = ATTR_TO_PROPS[el.tagName];
  if (mappings) {
    var mapper = mappings[name];
    if (mapper === true) {
      el.setProperty(name, value);
    } else if (mapper) {
      mapper(el, name, value);
    }
  }
}

var PROPERTY_TRANSFORMATIONS = {
  "input": {
    "checked": function (el, name, value) {
      if (value === true) {
        el.properties.set(name, true);
        el.properties.set('value', 'on');
      } else {
        el.properties.set(name, false);
        el.properties.set('value', 'off');
      }
    },
    "value": function (el, name, value) {
      var type = el.getAttribute('type');
      switch(type) {
        case 'checkbox':
          if (value === 'on') {
            el.properties.set(name, true);
            el.properties.set('value', 'on');
          } else {
            el.properties.set(name, false);
            el.properties.set('value', 'off');
          }
          break
        default:
          _setProperty(el, name, value);
      }
    }
  }
};

function _setProperty(el, name, value) {
  if (value === undefined) {
    el.properties.delete(name);
  } else {
    el.properties.set(name, String(value));
  }
}

function _setHTMLPropertyValue(el, name, value) {
  var trafos = PROPERTY_TRANSFORMATIONS[el.tagName];
  if (trafos) {
    var mapper = trafos[name];
    if (mapper) {
      mapper(el, name, value);
      return
    }
  }
  _setProperty(el, name, value);
}

function _sanitizeHTMLStructure(doc) {
  
  
  
  
  var htmlEl = doc.find('html');
  if (!htmlEl) {
    
    
    var headEl = doc.find('head');
    var titleEl = doc.find('title');
    var metaEls = doc.findAll('meta');
    var bodyEl = doc.find('body');
    if (headEl) { headEl.remove(); }
    if (titleEl) { titleEl.remove(); }
    metaEls.forEach(function (e) { return e.remove(); });
    if (bodyEl) { bodyEl.remove(); }

    
    
    var contentNodes = doc.childNodes.slice();
    contentNodes.forEach(function (c){c.parent = null;});
    doc.childNodes.length = 0;

    htmlEl = doc.createElement('html');
    
    
    
    if (!headEl) {
      headEl = doc.createElement('head');
      headEl.appendChild(titleEl);
      headEl.append(metaEls);
      htmlEl.appendChild(headEl);
    }
    if (!bodyEl) {
      bodyEl = doc.createElement('body');
      bodyEl.append(contentNodes);
    }
    htmlEl.appendChild(bodyEl);

    doc.append(htmlEl);
  }
}

var DefaultDOMElement = {};

DefaultDOMElement.createDocument = function(format) {
  return _getDefaultImpl().createDocument(format)
};


DefaultDOMElement.createElement = function(tagName) {
  console.error("DEPRECATED: every element should have an ownerDocument. Use DefaultDOMElement.createDocument() to create a document first");
  var doc = DefaultDOMElement.createDocument('html');
  return doc.createElement(tagName)
};


DefaultDOMElement.createTextNode = function(text) {
  console.error("DEPRECATED: every element should have a ownerDocument. Use DefaultDOMElement.createDocument() to create a document first");
  var doc = DefaultDOMElement.createDocument('html');
  return doc.createTextNode(text)
};


DefaultDOMElement.getBrowserWindow = function() {
  return _getDefaultImpl().getBrowserWindow()
};


DefaultDOMElement.parseHTML = function(html, options) {
  return _getDefaultImpl().parseMarkup(html, 'html', options)
};


DefaultDOMElement.parseXML = function(xml, options) {
  return _getDefaultImpl().parseMarkup(xml, 'xml', options)
};

DefaultDOMElement.parseSnippet = function(str, format) {
  return _getDefaultImpl().parseMarkup(str, format, {snippet: true})
};

DefaultDOMElement.wrap =
DefaultDOMElement.wrapNativeElement = function(nativeEl) {
  if (!nativeEl) { throw new Error('Illegal argument') }
  return _getDefaultImpl().wrap(nativeEl)
};

DefaultDOMElement.unwrap = function(nativeEl) {
  if (!nativeEl) { throw new Error('Illegal argument') }
  return _getDefaultImpl().unwrap(nativeEl)
};



DefaultDOMElement.isReverse = function(anchorNode, anchorOffset, focusNode, focusOffset) {
  return _getDefaultImpl().isReverse(anchorNode, anchorOffset, focusNode, focusOffset)
};

function _getDefaultImpl() {
  if (platform.inBrowser && !platform.inNodeJS) {
    return BrowserDOMElement
  } else {
    return MemoryDOMElement
  }
}

var HTMLExporter = (function (DOMExporter$$1) {
  function HTMLExporter(config, context) {
    DOMExporter$$1.call(this, _defaultConfig(config), context);
  }

  if ( DOMExporter$$1 ) HTMLExporter.__proto__ = DOMExporter$$1;
  HTMLExporter.prototype = Object.create( DOMExporter$$1 && DOMExporter$$1.prototype );
  HTMLExporter.prototype.constructor = HTMLExporter;

  HTMLExporter.prototype.exportDocument = function exportDocument (doc) {
    var htmlEl = DefaultDOMElement.parseHTML('<html><head></head><body></body></html>');
    return this.convertDocument(doc, htmlEl)
  };

  HTMLExporter.prototype.getDefaultBlockConverter = function getDefaultBlockConverter () {
    return defaultBlockConverter 
  };

  HTMLExporter.prototype.getDefaultPropertyAnnotationConverter = function getDefaultPropertyAnnotationConverter () {
    return defaultAnnotationConverter 
  };

  return HTMLExporter;
}(DOMExporter));

function _defaultConfig(config) {
  config = Object.assign({
    idAttribute: 'data-id'
  }, config);
  if (!config.elementFactory) {
    config.elementFactory = DefaultDOMElement.createDocument('html');
  }
  return config
}


var defaultAnnotationConverter = {
  tagName: 'span',
  export: function(node, el) {
    el.tagName = 'span';
    el.attr('data-type', node.type);
    var properties = node.toJSON();
    forEach(properties, function(value, name) {
      if (name === 'id' || name === 'type') { return }
      if (isString$1(value) || isNumber(value) || isBoolean(value)) {
        el.attr('data-'+name, value);
      }
    });
  }
};

var defaultBlockConverter = {
  export: function(node, el, converter) {
    el.attr('data-type', node.type);
    var properties = node.toJSON();
    forEach(properties, function(value, name) {
      if (name === 'id' || name === 'type') {
        return
      }
      var prop = converter.$$('div').attr('property', name);
      if (node.getPropertyType(name) === 'string' && value) {
        prop.append(converter.annotatedText([node.id, name]));
      } else {
        prop.text(value);
      }
      el.append(prop);
    });
  }
};

var HTMLImporter = (function (DOMImporter$$1) {
  function HTMLImporter(config) {
    DOMImporter$$1.call(this, Object.assign({ idAttribute: 'data-id' }, config));

    
    this._el = DefaultDOMElement.parseHTML('<html></html>');
  }

  if ( DOMImporter$$1 ) HTMLImporter.__proto__ = DOMImporter$$1;
  HTMLImporter.prototype = Object.create( DOMImporter$$1 && DOMImporter$$1.prototype );
  HTMLImporter.prototype.constructor = HTMLImporter;

  HTMLImporter.prototype.importDocument = function importDocument (html) {
    this.reset();
    var parsed = DefaultDOMElement.parseHTML(html);
    this.convertDocument(parsed);
    return this.state.doc
  };

  
  HTMLImporter.prototype.convertDocument = function convertDocument (documentEl) { 
    throw new Error('This method is abstract')
  };

  return HTMLImporter;
}(DOMImporter));

var InlineNode = (function (PropertyAnnotation$$1) {
	function InlineNode () {
		PropertyAnnotation$$1.apply(this, arguments);
	}if ( PropertyAnnotation$$1 ) InlineNode.__proto__ = PropertyAnnotation$$1;
	InlineNode.prototype = Object.create( PropertyAnnotation$$1 && PropertyAnnotation$$1.prototype );
	InlineNode.prototype.constructor = InlineNode;

	

	return InlineNode;
}(PropertyAnnotation));

InlineNode.prototype._isInlineNode = true;

InlineNode.isInline = true;

var Marker = (function (PropertyAnnotation$$1) {
  function Marker () {
    PropertyAnnotation$$1.apply(this, arguments);
  }

  if ( PropertyAnnotation$$1 ) Marker.__proto__ = PropertyAnnotation$$1;
  Marker.prototype = Object.create( PropertyAnnotation$$1 && PropertyAnnotation$$1.prototype );
  Marker.prototype.constructor = Marker;

  Marker.prototype.invalidate = function invalidate () {};
  Marker.prototype.remove = function remove () {
    this.getDocument().data.delete(this.id);
  };

  
  Marker.prototype.containsSelection = function containsSelection (sel) {
    if (sel.isNull()) { return false; }
    if (sel.isPropertySelection()) {
      return (isArrayEqual(this.start.path, sel.start.path) &&
        this.start.offset <= sel.start.offset &&
        this.end.offset >= sel.end.offset)
    } else {
      console.warn('Marker.contains() does not support other selection types.');
    }
  };

  return Marker;
}(PropertyAnnotation));


Marker.prototype._isPropertyAnnotation = false;
Marker.prototype._isMarker = true;
Marker.autoExpandRight = false;

var Range = function Range(start, end, reverse, containerId, surfaceId) {
  
  if (arguments[0] === 'SKIP') { return }
  if (arguments.length === 1 && isPlainObject$1(arguments[0])) {
    var data = arguments[0];
    this.start = data.start;
    this.end = data.end;
    this.reverse = Boolean(data.reverse);
    this.containerId = data.containerId;
    this.surfaceId = data.surfaceId;
  } else {
    this.start = start;
    this.end = end;
    this.reverse = Boolean(reverse);
    this.containerId = containerId;
    this.surfaceId = surfaceId;
  }
};

Range.prototype.isCollapsed = function isCollapsed () {
  return this.start.equals(this.end)
};

Range.prototype.equals = function equals (other) {
  if (this === other) { return true }
  else {
    return (
      this.containerId === other.containerId &&
      this.start.equals(other.start) &&
      this.end.equals(other.end)
    )
  }
};

Range.prototype.isReverse = function isReverse () {
  return this.reverse
};

Range.prototype.toString = function toString () {
  var str = [this.start.toString(), '->', this.end.toString()];
  if (this.isReverse()) {
    str.push('[reverse]');
  }
  if (this.containerId) {
    str.push('[container='+this.containerId+']');
  }
  if (this.surfaceId) {
    str.push('[surface='+this.surfaceId+']');
  }
  return str.join('')
};

Range.prototype._isRange = true;

var SelectionState = function SelectionState(doc) {
  this.document = doc;

  this.selection = Selection.nullSelection;
  this._state = {};
  this._resetState();
};

SelectionState.prototype.setSelection = function setSelection (sel) {
  
  if (!sel) {
    sel = Selection.nullSelection;
  } else {
    sel.attach(this.document);
  }
  
  
  this._deriveState(sel);
  this.selection = sel;
  return true
};

SelectionState.prototype.getSelection = function getSelection () {
  return this.selection
};

SelectionState.prototype.getAnnotationsForType = function getAnnotationsForType (type) {
  var state = this._state;
  if (state.annosByType) {
    return state.annosByType.get(type) || []
  }
  return []
};

SelectionState.prototype.getMarkers = function getMarkers () {
  
  return this._state.markers || []
};

SelectionState.prototype.isInlineNodeSelection = function isInlineNodeSelection () {
  return this._state.isInlineNodeSelection
};

SelectionState.prototype.getContainer = function getContainer () {
  return this._state.container
};

SelectionState.prototype.getPreviousNode = function getPreviousNode () {
  return this._state.previousNode
};

SelectionState.prototype.getNextNode = function getNextNode () {
  return this._state.nextNode
};


SelectionState.prototype.isFirst = function isFirst$$1 () {
  return Boolean(this._state.isFirst)
};


SelectionState.prototype.isLast = function isLast$$1 () {
  return Boolean(this._state.isLast)
};

SelectionState.prototype.get = function get (key) {
  return this._state[key]
};


SelectionState.prototype.set = function set (key, value) {
  if (this._state[key]) {
    throw new Error(("State " + key + " is already set"))
  }
  this._state[key] = value;
};

SelectionState.prototype._deriveState = function _deriveState (sel) {
  this._resetState();
  this._deriveContainerSelectionState(sel);
  this._deriveAnnoState(sel);
  if (this.document.getIndex('markers')) {
    this._deriveMarkerState(sel);
  }
  
};

SelectionState.prototype._deriveContainerSelectionState = function _deriveContainerSelectionState (sel) {
  var state = this._state;
  var doc = this.document;
  if (sel.containerId) {
    var container = doc.get(sel.containerId);
    state.container = container;
    var startId = sel.start.getNodeId();
    var endId = sel.end.getNodeId();
    var startNode = doc.get(startId).getRoot();
    var startPos = container.getPosition(startNode);
    if (startPos > 0) {
      state.previousNode = container.getNodeAt(startPos-1);
    }
    state.isFirst = isFirst(doc, sel.start);
    var endNode, endPos;
    if (endId === startId) {
      endNode = startNode;
      endPos = startPos;
    } else {
      endNode = doc.get(endId).getRoot();
      endPos = container.getPosition(endNode);
    }
    if (endPos < container.getLength()-1) {
      state.nextNode = container.getNodeAt(endPos+1);
    }
    state.isLast = isLast(doc, sel.end);
  }
};

SelectionState.prototype._deriveAnnoState = function _deriveAnnoState (sel) {
  var doc = this.document;
  var state = this._state;

  
  var annosByType = new TreeIndex.Arrays();
  var propAnnos = documentHelpers.getPropertyAnnotationsForSelection(doc, sel);
  propAnnos.forEach(function(anno) {
    annosByType.add(anno.type, anno);
  });

  if (propAnnos.length === 1 && propAnnos[0].isInline()) {
    state.isInlineNodeSelection = propAnnos[0].getSelection().equals(sel);
  }

  var containerId = sel.containerId;
  if (containerId) {
    var containerAnnos = documentHelpers.getContainerAnnotationsForSelection(doc, sel, containerId);
    containerAnnos.forEach(function(anno) {
      annosByType.add(anno.type, anno);
    });
  }
  state.annosByType = annosByType;
};

SelectionState.prototype._deriveMarkerState = function _deriveMarkerState (sel) {
  var doc = this.document;
  var state = this._state;
  var markers = documentHelpers.getMarkersForSelection(doc, sel);
  state.markers = markers;
};

SelectionState.prototype._resetState = function _resetState () {
  this._state = {
    
    annosByType: null,
    
    markers: null,
    
    isInlineNodeSelection: false,
    
    container: null,
    previousNode: null,
    nextNode: null,
    
    isFirst: false,
    
    isLast: false
  };
  return this._state
};

var TextNode = (function (DocumentNode$$1) {
  function TextNode () {
    DocumentNode$$1.apply(this, arguments);
  }

  if ( DocumentNode$$1 ) TextNode.__proto__ = DocumentNode$$1;
  TextNode.prototype = Object.create( DocumentNode$$1 && DocumentNode$$1.prototype );
  TextNode.prototype.constructor = TextNode;

  TextNode.prototype.getTextPath = function getTextPath () {
    
    
    return this.getPath()
  };

  TextNode.prototype.getPath = function getPath () {
    return [this.id, 'content']
  };

  TextNode.prototype.getText = function getText () {
    return this.content
  };

  TextNode.prototype.isEmpty = function isEmpty () {
    return !this.content
  };

  TextNode.prototype.getLength = function getLength () {
    return this.content.length
  };

  return TextNode;
}(DocumentNode));

TextNode.isText = true;

TextNode.schema = {
  type: "text",
  content: "text",
  direction: { type: "string", optional: true },
  textAlign: { type: "string", optional: true }
};

var TextBlock = (function (TextNode$$1) {
	function TextBlock () {
		TextNode$$1.apply(this, arguments);
	}if ( TextNode$$1 ) TextBlock.__proto__ = TextNode$$1;
	TextBlock.prototype = Object.create( TextNode$$1 && TextNode$$1.prototype );
	TextBlock.prototype.constructor = TextBlock;

	

	return TextBlock;
}(TextNode));

TextBlock.isBlock = true;

var Transaction = (function (EditingInterface$$1) {
  function Transaction(doc, editorSession) {
    EditingInterface$$1.call(this);

    
    
    this._stageDoc = this._document = new TransactionDocument(doc, this);
    this._editorSession = editorSession;

    
    this._isTransacting = false;
    this._state = 'idle';
    this._surface = null;
  }

  if ( EditingInterface$$1 ) Transaction.__proto__ = EditingInterface$$1;
  Transaction.prototype = Object.create( EditingInterface$$1 && EditingInterface$$1.prototype );
  Transaction.prototype.constructor = Transaction;

  var prototypeAccessors = { ops: {} };

  Transaction.prototype.dispose = function dispose () {
    this._stageDoc.dispose();
  };

  Transaction.prototype.setSelection = function setSelection (sel) {
    EditingInterface$$1.prototype.setSelection.call(this, sel);

    
    
    
    sel = this._selection;
    if (!sel.isNull()) {
      if (!sel.surfaceId) {
        
        var surface = this._editorSession.getFocusedSurface();
        if (surface) {
          sel.surfaceId = surface.id;
        } else {
          
          console.warn('No focused surface. Selection will not be rendered.');
        }
      }
    }
  };

  

  
  
  prototypeAccessors.ops.get = function () {
    return this._stageDoc.ops
  };
  prototypeAccessors.ops.set = function (ops) {
    this._stageDoc.ops = ops;
  };

  Transaction.prototype.rollback = function rollback () {
    this._stageDoc._rollback();
  };

  Transaction.prototype._apply = function _apply () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    (ref = this._stageDoc)._apply.apply(ref, args);
    var ref;
  };

  
  
  

  
  Transaction.prototype._recordChange = function _recordChange (transformation, selection) {
    
    if (this._isTransacting) { throw new Error('Nested transactions are not supported.') }
    if (!isFunction$1(transformation)) { throw new Error('Document.transaction() requires a transformation function.') }
    this._isTransacting = true;
    this._reset();
    this._state = 'started';
    var change;
    try {
      this.setSelection(selection);
      var selBefore = this.getSelection();
      transformation(this, {
        selection: selBefore
      });
      var ops = this.ops;
      if (ops.length > 0) {
        change = new DocumentChange(ops, this._before, this._after);
        change.before = { selection: selBefore };
        change.after = { selection: this.getSelection() };
      }
      this._state = 'finished';
    } finally {
      if (this._state !== 'finished') {
        this.rollback();
      }
      this._state = 'idle';
      this._isTransacting = false;
    }
    return change
  };

  Transaction.prototype._reset = function _reset () {
    this._before = {};
    this._after = {};
    this._stageDoc._reset();
    this._info = {};
    this.setSelection(null);
  };

  Object.defineProperties( Transaction.prototype, prototypeAccessors );

  return Transaction;
}(EditingInterface));

var XMLExporter = (function (DOMExporter$$1) {
  function XMLExporter(config, context) {
    DOMExporter$$1.call(this, _defaultConfig$1(config), context);
  }

  if ( DOMExporter$$1 ) XMLExporter.__proto__ = DOMExporter$$1;
  XMLExporter.prototype = Object.create( DOMExporter$$1 && DOMExporter$$1.prototype );
  XMLExporter.prototype.constructor = XMLExporter;

  XMLExporter.prototype.getDefaultBlockConverter = function getDefaultBlockConverter () {
    return defaultBlockConverter$1 
  };

  XMLExporter.prototype.getDefaultPropertyAnnotationConverter = function getDefaultPropertyAnnotationConverter () {
    return defaultAnnotationConverter$1 
  };

  return XMLExporter;
}(DOMExporter));

function _defaultConfig$1(config) {
  config = Object.assign({
    idAttribute: 'id'
  }, config);
  if (!config.elementFactory) {
    config.elementFactory = DefaultDOMElement.createDocument('xml');
  }
  return config
}

var defaultAnnotationConverter$1 = {
  tagName: 'annotation',
  export: function(node, el) {
    el.attr('type', node.type);
    var properties = node.toJSON();
    forEach(properties, function(value, name) {
      if (name === 'id' || name === 'type') { return }
      if (isString$1(value) || isNumber(value) || isBoolean(value)) {
        el.attr(name, value);
      }
    });
  }
};

var defaultBlockConverter$1 = {
  tagName: 'block',
  export: function(node, el, converter) {
    el.attr('type', node.type);
    var properties = node.toJSON();
    forEach(properties, function(value, name) {
      if (name === 'id' || name === 'type') {
        return
      }
      var prop = converter.$$(name);
      if (node.getPropertyType(name) === 'string') {
        prop.append(converter.annotatedText([node.id, name]));
      } else {
        prop.text(value);
      }
      el.append(prop);
    });
  }
};

var XMLImporter = (function (DOMImporter$$1) {
  function XMLImporter(config, context) {
    DOMImporter$$1.call(this, Object.assign({ idAttribute: 'id' }, config), context);
  }

  if ( DOMImporter$$1 ) XMLImporter.__proto__ = DOMImporter$$1;
  XMLImporter.prototype = Object.create( DOMImporter$$1 && DOMImporter$$1.prototype );
  XMLImporter.prototype.constructor = XMLImporter;

  XMLImporter.prototype.importDocument = function importDocument (xml) {
    this.reset();
    var dom = DefaultDOMElement.parseXML(xml);
    this.convertDocument(dom);
    return this.state.doc
  };

  return XMLImporter;
}(DOMImporter));

var CollabEngine = (function (EventEmitter$$1) {
  function CollabEngine(documentEngine) {
    EventEmitter$$1.call(this);
    this.documentEngine = documentEngine;
    
    this._collaborators = {};
  }

  if ( EventEmitter$$1 ) CollabEngine.__proto__ = EventEmitter$$1;
  CollabEngine.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  CollabEngine.prototype.constructor = CollabEngine;

  
  CollabEngine.prototype._register = function _register (collaboratorId, documentId, collaboratorInfo) {
    var collaborator = this._collaborators[collaboratorId];

    if (!collaborator) {
      collaborator = this._collaborators[collaboratorId] = {
        collaboratorId: collaboratorId,
        documents: {}
      };
    }

    
    collaborator.info = collaboratorInfo;

    
    collaborator.documents[documentId] = {};
  };

  
  CollabEngine.prototype._unregister = function _unregister (collaboratorId, documentId) {
    var collaborator = this._collaborators[collaboratorId];
    delete collaborator.documents[documentId];
    var docCount = Object.keys(collaborator.documents).length;
    
    if (docCount === 0) {
      delete this._collaborators[collaboratorId];
    }
  };

  
  CollabEngine.prototype.getDocumentIds = function getDocumentIds (collaboratorId) {
    var collaborator = this._collaborators[collaboratorId];
    if (!collaborator) {
      
      
      return []
    }
    return Object.keys(collaborator.documents)
  };

  
  CollabEngine.prototype.getCollaborators = function getCollaborators (documentId, collaboratorId) {
    var collaborators = {};
    forEach(this._collaborators, function(collab) {
      var doc = collab.documents[documentId];
      if (doc && collab.collaboratorId !== collaboratorId) {
        var entry = {
          
          collaboratorId: collab.collaboratorId
        };
        entry = Object.assign({}, collab.info, entry);
        collaborators[collab.collaboratorId] = entry;
      }
    });
    return collaborators
  };

  
  CollabEngine.prototype.getCollaboratorIds = function getCollaboratorIds (documentId, collaboratorId) {
    var collaborators = this.getCollaborators(documentId, collaboratorId);
    return map(collaborators, function(c) {
      return c.collaboratorId
    })
  };

  
  CollabEngine.prototype.sync = function sync (ref, cb) {
    var documentId = ref.documentId;
    var version = ref.version;
    var change = ref.change;
    var collaboratorId = ref.collaboratorId;

    this._sync({documentId: documentId, version: version, change: change}, function(err, result) {
      if (err) { return cb(err) }
      
      this._register(collaboratorId, documentId);
      cb(null, result);
    }.bind(this));
  };

  
  CollabEngine.prototype._sync = function _sync (ref, cb) {
    var this$1 = this;
    var documentId = ref.documentId;
    var version = ref.version;
    var change = ref.change;

    this.documentEngine.getVersion(documentId, function (err, serverVersion) {
      if (version > serverVersion) {
        cb(new SubstanceError('InvalidVersionError', {
          message: 'Client version greater than server version'
        }));
      } else if (change && serverVersion === version) {
        this$1._syncFF({documentId: documentId, version: version, change: change}, cb);
      } else if (change && serverVersion > version) {
        this$1._syncRB({documentId: documentId, version: version, change: change}, cb);
      } else if (!change) {
        
        this$1._syncPullOnly({documentId: documentId, version: version, change: change}, cb);
      } else {
        console.warn('Unhandled case');
      }
    });
  };

  CollabEngine.prototype._syncPullOnly = function _syncPullOnly (ref, cb) {
    var this$1 = this;
    var documentId = ref.documentId;
    var version = ref.version;
    var change = ref.change;

    console.warn('This code is not yet tested');
    this.documentEngine.getChanges(documentId, version, function (err, changes) {
      var serverChange;

      
      if (changes.length > 0) {
        var ops = [];
        changes.forEach(function (change) {
          ops = ops.concat(change.ops);
        });
        serverChange = new DocumentChange(ops, {}, {});
        serverChange = this$1.serializeChange(serverChange);
      }
      cb(null, {
        serverChange: serverChange,
        change: change,
        version: version
      });
    });
  };

  
  CollabEngine.prototype._syncFF = function _syncFF (ref, cb) {
    var documentId = ref.documentId;
    var change = ref.change;

    this.documentEngine.addChange(documentId, change, function (err, serverVersion) {
      if (err) { return cb(err) }
      cb(null, {
        change: change, 
        serverChange: null,
        version: serverVersion
      });
    });
  };

  
  CollabEngine.prototype._syncRB = function _syncRB (ref, cb) {
    var documentId = ref.documentId;
    var change = ref.change;
    var version = ref.version;

    this._rebaseChange({documentId: documentId, change: change, version: version}, function(err, rebased) {
      
      if (err) { return cb(err) }
      
      this.documentEngine.addChange(
        documentId,
        change,
        function(err, serverVersion) {
          if (err) { return cb(err) }
          cb(null, {
            change: rebased.change,
            
            serverChange: rebased.serverChange,
            version: serverVersion
          });
        }
      );
    }.bind(this));
  };

  
  CollabEngine.prototype._rebaseChange = function _rebaseChange (ref, cb) {
    var documentId = ref.documentId;
    var change = ref.change;
    var version = ref.version;

    this.documentEngine.getChanges(documentId, version, function(err, result) {
      
      var changes = result.changes || [];
      var B = changes.map(this.deserializeChange);
      var a = this.deserializeChange(change);
      
      transformDocumentChange(a, B);
      var ops = B.reduce(function(ops, change) {
        return ops.concat(change.ops)
      }, []);
      var serverChange = new DocumentChange(ops, {}, {});

      cb(null, {
        change: this.serializeChange(a),
        serverChange: this.serializeChange(serverChange),
        version: result.version
      });
    }.bind(this));
  };

  
  CollabEngine.prototype.disconnect = function disconnect (args) {
    this._unregister(args.collaboratorId, args.documentId);
  };

  
  CollabEngine.prototype.serializeChange = function serializeChange (change) {
    return change.toJSON()
  };

  
  CollabEngine.prototype.deserializeChange = function deserializeChange (serializedChange) {
    var ch = DocumentChange.fromJSON(serializedChange);
    return ch
  };

  return CollabEngine;
}(EventEmitter));

var CollabServer = (function (Server$$1) {
  function CollabServer(config) {
    Server$$1.call(this, config);

    this.scope = 'substance/collab';
    this.configurator = config.configurator;
    this.documentEngine = this.configurator.getDocumentEngine();
    this.collabEngine = new CollabEngine(this.documentEngine);
  }

  if ( Server$$1 ) CollabServer.__proto__ = Server$$1;
  CollabServer.prototype = Object.create( Server$$1 && Server$$1.prototype );
  CollabServer.prototype.constructor = CollabServer;

  
  CollabServer.prototype._error = function _error (req, res, err) {
    console.error(err);
    res.error({
      scope: this.scope,
      type: 'error',
      error: {
        name: req.message.type+'Error',
        cause: {
          name: err.name
        }
      },
      documentId: req.message.documentId
    });
    this.next(req, res);
  };

  
  CollabServer.prototype.authenticate = function authenticate (req, res) {
    var this$1 = this;

    if (this.config.authenticate) {
      this.config.authenticate(req, function (err, session) {
        if (err) {
          console.error(err);
          
          this$1._error(req, res, new SubstanceError('AuthenticationError', {cause: err}));
          return
        }
        req.setAuthenticated(session);
        this$1.next(req, res);
      });
    } else {
      Server$$1.prototype.authenticate.apply(this, arguments);
    }
  };

  
  CollabServer.prototype.enhanceRequest = function enhanceRequest (req, res) {
    var this$1 = this;

    if (this.config.enhanceRequest) {
      this.config.enhanceRequest(req, function (err) {
        if (err) {
          console.error('enhanceRequest returned an error', err);
          this$1._error(req, res, err);
          return
        }
        req.setEnhanced();
        this$1.next(req, res);
      });
    } else {
      Server$$1.prototype.enhanceRequest.apply(this, arguments);
    }
  };

  
  CollabServer.prototype.onDisconnect = function onDisconnect (collaboratorId) {
    
    
    var documentIds = this.collabEngine.getDocumentIds(collaboratorId);
    documentIds.forEach(function(documentId) {
      this._disconnectDocument(collaboratorId, documentId);
    }.bind(this));
  };

  
  CollabServer.prototype.execute = function execute (req, res) {
    var msg = req.message;
    var method = this[msg.type];

    if (method) {
      method.call(this, req, res);
    } else {
      console.error('Method', msg.type, 'not implemented for CollabServer');
    }
  };

  
  CollabServer.prototype.sync = function sync (req, res) {
    var this$1 = this;

    var args = req.message;

    
    this.collabEngine.sync(args, function (err, result) {
      
      if (err) {
        this$1._error(req, res, err);
        return
      }

      
      var collaborators = this$1.collabEngine.getCollaborators(args.documentId, args.collaboratorId);

      
      res.send({
        scope: this$1.scope,
        type: 'syncDone',
        documentId: args.documentId,
        version: result.version,
        serverChange: result.serverChange,
      });

      
      forEach(collaborators, function (collaborator) {
        this$1.send(collaborator.collaboratorId, {
          scope: this$1.scope,
          type: 'update',
          documentId: args.documentId,
          version: result.version,
          change: result.change
        });
      });
      this$1.next(req, res);
    });
  };

  
  CollabServer.prototype.disconnect = function disconnect (req, res) {
    var args = req.message;
    var collaboratorId = args.collaboratorId;
    var documentId = args.documentId;
    this._disconnectDocument(collaboratorId, documentId);
    
    res.send({
      scope: this.scope,
      type: 'disconnectDone',
      documentId: args.documentId
    });
    this.next(req, res);
  };

  CollabServer.prototype._disconnectDocument = function _disconnectDocument (collaboratorId, documentId) {
    
    this.collabEngine.disconnect({
      documentId: documentId,
      collaboratorId: collaboratorId
    });
  };

  return CollabServer;
}(Server));

var DocumentClient = function DocumentClient(config) {
  this.config = config;
};


DocumentClient.prototype.createDocument = function createDocument (newDocument, cb) {
  request('POST', this.config.httpUrl, newDocument, cb);
};



DocumentClient.prototype.getDocument = function getDocument (documentId, cb) {
  request('GET', this.config.httpUrl+documentId, null, cb);
};



DocumentClient.prototype.deleteDocument = function deleteDocument (documentId, cb) {
  request('DELETE', this.config.httpUrl+documentId, null, cb);
};

var ClientConnection = (function (EventEmitter$$1) {
  function ClientConnection(config) {
    EventEmitter$$1.call(this);

    this.config = config;
    this._onMessage = this._onMessage.bind(this);
    this._onConnectionOpen = this._onConnectionOpen.bind(this);
    this._onConnectionClose = this._onConnectionClose.bind(this);

    
    this._connect();
  }

  if ( EventEmitter$$1 ) ClientConnection.__proto__ = EventEmitter$$1;
  ClientConnection.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  ClientConnection.prototype.constructor = ClientConnection;

  ClientConnection.prototype._createWebSocket = function _createWebSocket () {
    throw SubstanceError('AbstractMethodError')
  };

  
  ClientConnection.prototype._connect = function _connect () {
    this.ws = this._createWebSocket();
    this.ws.addEventListener('open', this._onConnectionOpen);
    this.ws.addEventListener('close', this._onConnectionClose);
    this.ws.addEventListener('message', this._onMessage);
  };

  
  ClientConnection.prototype._disconnect = function _disconnect () {
    this.ws.removeEventListener('message', this._onMessage);
    this.ws.removeEventListener('open', this._onConnectionOpen);
    this.ws.removeEventListener('close', this._onConnectionClose);
    this.ws = null;
  };

  
  ClientConnection.prototype._onConnectionOpen = function _onConnectionOpen () {
    this.emit('open');
  };

  
  ClientConnection.prototype._onConnectionClose = function _onConnectionClose () {
    this._disconnect();
    this.emit('close');
    console.info('websocket connection closed. Attempting to reconnect in 5s.');
    setTimeout(function() {
      this._connect();
    }.bind(this), 5000);
  };

  
  ClientConnection.prototype._onMessage = function _onMessage (msg) {
    msg = this.deserializeMessage(msg.data);
    this.emit('message', msg);
  };

  
  ClientConnection.prototype.send = function send (msg) {
    if (!this.isOpen()) {
      console.warn('Message could not be sent. Connection is not open.', msg);
      return
    }
    this.ws.send(this.serializeMessage(msg));
  };

  
  ClientConnection.prototype.isOpen = function isOpen () {
    return this.ws && this.ws.readyState === 1
  };

  ClientConnection.prototype.serializeMessage = function serializeMessage (msg) {
    return JSON.stringify(msg)
  };

  ClientConnection.prototype.deserializeMessage = function deserializeMessage (msg) {
    return JSON.parse(msg)
  };

  return ClientConnection;
}(EventEmitter));

var WebSocketConnection = (function (ClientConnection$$1) {
  function WebSocketConnection () {
    ClientConnection$$1.apply(this, arguments);
  }

  if ( ClientConnection$$1 ) WebSocketConnection.__proto__ = ClientConnection$$1;
  WebSocketConnection.prototype = Object.create( ClientConnection$$1 && ClientConnection$$1.prototype );
  WebSocketConnection.prototype.constructor = WebSocketConnection;

  WebSocketConnection.prototype._createWebSocket = function _createWebSocket () {
    return new window.WebSocket(this.config.wsUrl);
  };

  return WebSocketConnection;
}(ClientConnection));

function computeSnapshot(jsonDoc, changeset) {
  
  jsonDoc = cloneDeep(jsonDoc);
  var nodes = jsonDoc.nodes;
  changeset.forEach(function (change) {
    change.ops.forEach(function (opData) {
      try {
        var op = ObjectOperation.fromJSON(opData);
        op.apply(nodes);
      } catch (err) {
        console.error(err, opData);
      }
    });
  });
  return jsonDoc
}

var EMPTY_DOC = { nodes: {} };


var SnapshotEngine = function SnapshotEngine(config) {
  this.changeStore = config.changeStore;
  this.snapshotStore = config.snapshotStore;
};


SnapshotEngine.prototype.getSnapshot = function getSnapshot (documentId, version, cb) {
    var this$1 = this;

  var jsonDoc = EMPTY_DOC;
  this._getClosestSnapshot(documentId, version, function (err, snapshot, closestVersion) {
    if (err) {
      return cb(err)
    }
    if (snapshot && version === closestVersion) {
      
      return cb(null, snapshot, version)
    }
    var knownVersion;
    if (snapshot) {
      knownVersion = closestVersion;
    } else {
      knownVersion = 0; 
    }
    if (snapshot) {
      jsonDoc = snapshot;
    }
    
    this$1.changeStore.getChanges(documentId, knownVersion, version, function (err, changes) {
      if (err) { return cb(err) }
      if (changes.length < (version - knownVersion)) {
        return cb('Changes missing for reconstructing version '+ version)
      }
      jsonDoc = computeSnapshot(jsonDoc, changes);
      cb(null, jsonDoc, version);
    });
  });
};


SnapshotEngine.prototype.createSnapshot = function createSnapshot (documentId, version, cb) {
    var this$1 = this;

  this.getSnapshot(documentId, version, function (err, snapshot) {
    if (err) { return cb(err) }
    this$1.snapshotStore.saveSnapshot(documentId, version, snapshot, cb);
  });
};

SnapshotEngine.prototype._getClosestSnapshot = function _getClosestSnapshot (documentId, version, cb) {
    var this$1 = this;

  var closestVersion;

  this.snapshotStore.getVersions(documentId, function (err, versions) {
    if (versions.indexOf(version) >= 0) {
      closestVersion = version;
    } else {
      
      var smallerVersions = versions.filter(function(v) {
        return parseInt(v, 10) < version
      });
      
      closestVersion = Math.max.apply(null, smallerVersions);
    }
    if (!closestVersion) {
      return cb(null, undefined)
    }
    this$1.snapshotStore.getSnapshot(documentId, version, cb);
  });
};

var DocumentEngine = (function (EventEmitter$$1) {
  function DocumentEngine(config) {
    EventEmitter$$1.call(this);
    this.changeStore = config.changeStore;
    this.snapshotStore = config.snapshotStore;
    
    
    this.snapshotFrequency = config.snapshotFrequency || 1;
    this.snapshotEngine = new SnapshotEngine({
      changeStore: this.changeStore,
      snapshotStore: this.snapshotStore
    });
  }

  if ( EventEmitter$$1 ) DocumentEngine.__proto__ = EventEmitter$$1;
  DocumentEngine.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  DocumentEngine.prototype.constructor = DocumentEngine;

  
  DocumentEngine.prototype.createDocument = function createDocument (documentId, initialChange, cb) {
    this.addChange(documentId, initialChange, cb);
  };

  
  DocumentEngine.prototype.getDocument = function getDocument (documentId, version, cb) {
    var this$1 = this;

    if (typeof version === 'function') {
      cb = version;
      version = undefined;
    }
    if (!documentId) {
      throw new Error('Invalid Arguments')
    }
    if (version === undefined) {
      this.getVersion(documentId, function (err, version) {
        if (err) { return cb(err) }
        this$1.snapshotEngine.getSnapshot(documentId, version, cb);
      });
    } else {
      this.snapshotEngine.getSnapshot(documentId, version, cb);
    }
  };

  
  DocumentEngine.prototype.deleteDocument = function deleteDocument (documentId, cb) {
    this.changeStore.deleteChanges(documentId, function (err) {
      if (err) {
        return cb(new Error('Deleting changes failed'))
      }
    });
  };

  
  DocumentEngine.prototype.documentExists = function documentExists (documentId, cb) {
    this.getVersion(documentId, function (err, version) {
      if (version >= 0) {
        cb(null, true);
      } else {
        cb(null, false);
      }
    });
  };

  
  DocumentEngine.prototype.getChanges = function getChanges (documentId, sinceVersion, toVersion, cb) {
    this.changeStore.getChanges(documentId, sinceVersion, toVersion, cb);
  };

  
  DocumentEngine.prototype.getVersion = function getVersion (documentId, cb) {
    this.changeStore.getVersion(documentId, cb);
  };

  
  DocumentEngine.prototype.requestSnapshot = function requestSnapshot (documentId, version, cb) {
    if (version % this.snapshotFrequency === 0) {
      this.snapshotEngine.createSnapshot(documentId, version, cb);
    } else {
      cb(null); 
    }
  };

  
  DocumentEngine.prototype.addChange = function addChange (documentId, change, cb) {
    var this$1 = this;

    this.changeStore.addChange(documentId, change, function (err, newVersion) {
      if (err) { return cb(err) }

      this$1.requestSnapshot(documentId, newVersion, function () {
        
        cb(null, newVersion);
      });
    });
  };

  return DocumentEngine;
}(EventEmitter));

var CollabServerConfigurator = function CollabServerConfigurator() {
  this.config = {
    heartbeat: 30*1000,
    documentStore: undefined,
    changeStore: undefined,
    snapshotStore: undefined
  };
};

CollabServerConfigurator.prototype.setHost = function setHost (host) {
  this.config.host = host;
};

CollabServerConfigurator.prototype.setPort = function setPort (port) {
  this.config.port = port;
};




CollabServerConfigurator.prototype.setDocumentStore = function setDocumentStore (documentStore) {
  this.config.documentStore = documentStore;
};

CollabServerConfigurator.prototype.setChangeStore = function setChangeStore (changeStore) {
  this.config.changeStore = changeStore;
};

CollabServerConfigurator.prototype.setSnapshotStore = function setSnapshotStore (snapshotStore) {
  this.config.snapshotStore = snapshotStore;
};




CollabServerConfigurator.prototype.getHost = function getHost () {
  return this.config.host
};

CollabServerConfigurator.prototype.getPort = function getPort () {
  return this.config.port
};

CollabServerConfigurator.prototype.getDocumentStore = function getDocumentStore () {
  return this.config.documentStore
};

CollabServerConfigurator.prototype.getChangeStore = function getChangeStore () {
  return this.config.changeStore
};

CollabServerConfigurator.prototype.getSnapshotStore = function getSnapshotStore () {
  return this.config.snapshotStore
};


CollabServerConfigurator.prototype.getDocumentEngine = function getDocumentEngine () {
  if (!this.documentEngine) {
    this.documentEngine = new DocumentEngine({
      documentStore: this.config.documentStore,
      changeStore: this.config.changeStore,
      snapshotStore: this.config.snapshotStore
    });
  }
  return this.documentEngine
};


CollabServerConfigurator.prototype.import = function import$1 (pkg, options) {
  pkg.configure(this, options || {});
  return this
};

var CollabClient = (function (EventEmitter$$1) {
  function CollabClient(config) {
    EventEmitter$$1.call(this);

    this.config = config;
    this.connection = config.connection;

    
    this.scope = 'substance/collab';

    
    this._onMessage = this._onMessage.bind(this);
    this._onConnectionOpen = this._onConnectionOpen.bind(this);
    this._onConnectionClose = this._onConnectionClose.bind(this);

    
    this.connection.on('open', this._onConnectionOpen);
    this.connection.on('close', this._onConnectionClose);
    this.connection.on('message', this._onMessage);
  }

  if ( EventEmitter$$1 ) CollabClient.__proto__ = EventEmitter$$1;
  CollabClient.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  CollabClient.prototype.constructor = CollabClient;

  CollabClient.prototype._onConnectionClose = function _onConnectionClose () {
    this.emit('disconnected');
  };

  CollabClient.prototype._onConnectionOpen = function _onConnectionOpen () {
    this.emit('connected');
  };

  
  CollabClient.prototype._onMessage = function _onMessage (msg) {
    if (msg.scope === this.scope) {
      this.emit('message', msg);
    } else if (msg.scope !== '_internal') {
      console.info('Message ignored. Not sent in hub scope', msg);
    }
  };

  
  CollabClient.prototype.send = function send (msg) {
    if (!this.connection.isOpen()) {
      console.warn('Message could not be sent. Connection not open.', msg);
      return
    }

    msg.scope = this.scope;
    if (this.config.enhanceMessage) {
      msg = this.config.enhanceMessage(msg);
    }
    this.connection.send(msg);
  };

  
  CollabClient.prototype.isConnected = function isConnected () {
    return this.connection.isOpen()
  };

  CollabClient.prototype.dispose = function dispose () {
    this.connection.off(this);
  };

  return CollabClient;
}(EventEmitter));

var SnapshotStore = function SnapshotStore(seed) {
  this._snapshots = seed || {};
};


SnapshotStore.prototype.getVersions = function getVersions (documentId, cb) {
  var versions = this._getVersions(documentId);
  cb(null, versions);
};


SnapshotStore.prototype.getSnapshot = function getSnapshot (documentId, version, cb) {
  if (!arguments.length === 3) {
    throw new Error('Invalid Arguments')
  }
  var docEntry = this._snapshots[documentId];
  if (!docEntry) { return cb(null, undefined) }
  var snapshot = docEntry[version];
  if (snapshot) {
    cb(null, snapshot, version);
  } else {
    cb(null, undefined);
  }
};


SnapshotStore.prototype.saveSnapshot = function saveSnapshot (documentId, version, data, cb) {
  if (!documentId || !version || !data) {
    throw new Error('Invalid arguments')
  }
  var docEntry = this._snapshots[documentId];
  if (!docEntry) {
    docEntry = this._snapshots[documentId] = {};
  }
  docEntry[version] = data;
  cb(null, docEntry[version]);
};


SnapshotStore.prototype.deleteSnapshot = function deleteSnapshot (documentId, version, cb) {
  var docEntry = this._snapshots[documentId];
  if (!docEntry || !docEntry[version]) {
    return cb(new Error('Snapshot does not exist and can not be deleted'))
  }
  var snapshot = this._snapshots[documentId][version];
  delete this._snapshots[documentId][version];
  cb(null, snapshot);
};


SnapshotStore.prototype._getVersions = function _getVersions (documentId) {
  var docEntry = this._snapshots[documentId];
  if (!docEntry) { return [] } 
  return Object.keys(docEntry)
};

var CollabServerPackage = {
  name: 'collab-server',
  configure: function (config) {
    config.setChangeStore(new ChangeStore());
    config.setSnapshotStore(new SnapshotStore());
  }
};

var DocumentServer = function DocumentServer(params) {
  this.configurator = params.configurator;
  this.engine = this.configurator.getDocumentEngine();
  
  this.path = '/api/documents';
};


DocumentServer.prototype.bind = function bind (app) {
  app.post(this.path, this._createDocument.bind(this));
  app.get(this.path + '/:id', this._getDocument.bind(this));
  app.delete(this.path + '/:id', this._deleteDocument.bind(this));
};


DocumentServer.prototype._createDocument = function _createDocument (req, res, next) {
  var ref = req.body;
    var documentId = ref.documentId;
    var change = ref.change;
  this.engine.createDocument(documentId, change, function(err, version) {
    if (err) { return next(err) }
    res.json(version);
  });
};


DocumentServer.prototype._getDocument = function _getDocument (req, res, next) {
  var documentId = req.params.id;
  this.engine.getDocument(documentId, function(err, jsonDoc, version) {
    if (err) { return next(err) }
    res.json({
      data: jsonDoc,
      version: version
    });
  });
};


DocumentServer.prototype._deleteDocument = function _deleteDocument (req, res, next) {
  var documentId = req.params.id;
  this.engine.deleteDocument(documentId, function(err, result) {
    if (err) { return next(err) }
    res.json(result);
  });
};

var VirtualElement = (function (DOMElement$$1) {
  function VirtualElement(owner) {
    DOMElement$$1.call(this);

    
    this.parent = null;
    
    this._owner = owner;
    
    this._ref = null;
  }

  if ( DOMElement$$1 ) VirtualElement.__proto__ = DOMElement$$1;
  VirtualElement.prototype = Object.create( DOMElement$$1 && DOMElement$$1.prototype );
  VirtualElement.prototype.constructor = VirtualElement;

  var prototypeAccessors = { childNodes: {} };

  VirtualElement.prototype.getParent = function getParent () {
    return this.parent
  };

  prototypeAccessors.childNodes.get = function () {
    return this.getChildNodes()
  };

  
  VirtualElement.prototype.getComponent = function getComponent () {
    return this._comp
  };

  
  VirtualElement.prototype.ref = function ref (ref$1) {
    if (!ref$1) { throw new Error('Illegal argument') }
    
    if (this._ref) { throw new Error('A VirtualElement can only be referenced once.') }
    this._ref = ref$1;
    if (this._context) {
      var refs = this._context.refs;
      if(refs[ref$1]) {
        throw new Error('An item with reference "'+ref$1+'" already exists.')
      }
      refs[ref$1] = this;
    }
    return this
  };

  VirtualElement.prototype.isInDocument = function isInDocument () {
    return false
  };

  Object.defineProperties( VirtualElement.prototype, prototypeAccessors );

  return VirtualElement;
}(DOMElement));

VirtualElement.prototype._isVirtualElement = true;


var VirtualHTMLElement = (function (VirtualElement) {
  function VirtualHTMLElement(tagName) {
    VirtualElement.call(this);

    this._tagName = tagName;
    this.classNames = null;
    this.attributes = null;
    this.htmlProps = null;
    this.style = null;
    this.eventListeners = null;

    
    this.children = [];
  }

  if ( VirtualElement ) VirtualHTMLElement.__proto__ = VirtualElement;
  VirtualHTMLElement.prototype = Object.create( VirtualElement && VirtualElement.prototype );
  VirtualHTMLElement.prototype.constructor = VirtualHTMLElement;

  VirtualHTMLElement.prototype.getTagName = function getTagName () {
    return this._tagName
  };

  VirtualHTMLElement.prototype.setTagName = function setTagName (tagName) {
    this._tagName = tagName;
    return this
  };

  VirtualHTMLElement.prototype.hasClass = function hasClass (className) {
    if (this.classNames) {
      return this.classNames.indexOf(className) > -1
    }
    return false
  };

  VirtualHTMLElement.prototype.addClass = function addClass (className) {
    if (!this.classNames) {
      this.classNames = [];
    }
    this.classNames.push(className);
    return this
  };

  VirtualHTMLElement.prototype.removeClass = function removeClass (className) {
    if (this.classNames) {
      this.classNames = without(this.classNames, className);
    }
    return this
  };

  VirtualHTMLElement.prototype.removeAttribute = function removeAttribute (name) {
    if (this.attributes) {
      delete this.attributes[name];
    }
    return this
  };

  VirtualHTMLElement.prototype.getAttribute = function getAttribute (name) {
    if (this.attributes) {
      return this.attributes[name]
    }
  };

  VirtualHTMLElement.prototype.setAttribute = function setAttribute (name, value) {
    if (!this.attributes) {
      this.attributes = {};
    }
    this.attributes[name] = value;
    return this
  };

  VirtualHTMLElement.prototype.getAttributes = function getAttributes () {
    
    
    
    var attributes = {};
    if (this.attributes) {
      Object.assign(attributes, this.attributes);
    }
    if (this.classNames) {
      attributes.class = this.classNames.join(' ');
    }
    if (this.style) {
      attributes.style = map(this.style, function(val, key) {
        return key + ":" + val
      }).join(';');
    }
    return attributes
  };

  VirtualHTMLElement.prototype.getId = function getId () {
    return this.getAttribute('id')
  };

  VirtualHTMLElement.prototype.setId = function setId (id) {
    this.setAttribute('id', id);
    return this
  };

  VirtualHTMLElement.prototype.setTextContent = function setTextContent (text) {
    text = String(text || '');
    this.empty();
    this.appendChild(text);
    return this
  };

  VirtualHTMLElement.prototype.setInnerHTML = function setInnerHTML (html) {
    html = html || '';
    this.empty();
    this._innerHTMLString = html;
    return this
  };

  VirtualHTMLElement.prototype.getInnerHTML = function getInnerHTML () {
    if (!this.hasOwnProperty('_innerHTMLString')) {
      throw new Error('Not supported.')
    } else {
      return this._innerHTMLString
    }
  };

  VirtualHTMLElement.prototype.getValue = function getValue () {
    return this.htmlProp('value')
  };

  VirtualHTMLElement.prototype.setValue = function setValue (value) {
    this.htmlProp('value', value);
    return this
  };

  VirtualHTMLElement.prototype.getChildNodes = function getChildNodes () {
    return this.children
  };

  VirtualHTMLElement.prototype.getChildren = function getChildren () {
    return this.children.filter(function(child) {
      return child.getNodeType() !== "text"
    })
  };

  VirtualHTMLElement.prototype.isTextNode = function isTextNode () {
    return false
  };

  VirtualHTMLElement.prototype.isElementNode = function isElementNode () {
    return true
  };

  VirtualHTMLElement.prototype.isCommentNode = function isCommentNode () {
    return false
  };

  VirtualHTMLElement.prototype.isDocumentNode = function isDocumentNode () {
    return false
  };

  VirtualHTMLElement.prototype.append = function append () {
    if (this._innerHTMLString) {
      throw Error('It is not possible to mix $$.html() with $$.append(). You can call $$.empty() to reset this virtual element.')
    }
    this._append(this.children, arguments);
    return this
  };

  VirtualHTMLElement.prototype.appendChild = function appendChild (child) {
    if (this._innerHTMLString) {
      throw Error('It is not possible to mix $$.html() with $$.append(). You can call $$.empty() to reset this virtual element.')
    }
    this._appendChild(this.children, child);
    return this
  };

  VirtualHTMLElement.prototype.insertAt = function insertAt (pos, child) {
    child = this._normalizeChild(child);
    if (!child) {
      throw new Error('Illegal child: ' + child)
    }
    if (!child._isVirtualElement) {
      throw new Error('Illegal argument for $$.insertAt():' + child)
    }
    if (pos < 0 || pos > this.children.length) {
      throw new Error('insertAt(): index out of bounds.')
    }
    this._insertAt(this.children, pos, child);
    return this
  };

  VirtualHTMLElement.prototype.insertBefore = function insertBefore (child, before) {
    var pos = this.children.indexOf(before);
    if (pos > -1) {
      this.insertAt(pos, child);
    } else {
      throw new Error('insertBefore(): reference node is not a child of this element.')
    }
    return this
  };

  VirtualHTMLElement.prototype.removeAt = function removeAt (pos) {
    if (pos < 0 || pos >= this.children.length) {
      throw new Error('removeAt(): Index out of bounds.')
    }
    this._removeAt(pos);
    return this
  };

  VirtualHTMLElement.prototype.removeChild = function removeChild (child) {
    if (!child || !child._isVirtualElement) {
      throw new Error('removeChild(): Illegal arguments. Expecting a CheerioDOMElement instance.')
    }
    var idx = this.children.indexOf(child);
    if (idx < 0) {
      throw new Error('removeChild(): element is not a child.')
    }
    this.removeAt(idx);
    return this
  };

  VirtualHTMLElement.prototype.replaceChild = function replaceChild (oldChild, newChild) {
    if (!newChild || !oldChild ||
        !newChild._isVirtualElement || !oldChild._isVirtualElement) {
      throw new Error('replaceChild(): Illegal arguments. Expecting BrowserDOMElement instances.')
    }
    var idx = this.children.indexOf(oldChild);
    if (idx < 0) {
      throw new Error('replaceChild(): element is not a child.')
    }
    this.removeAt(idx);
    this.insertAt(idx, newChild);
    return this
  };

  VirtualHTMLElement.prototype.empty = function empty () {
    var children = this.children;
    while (children.length) {
      var child = children.pop();
      child.parent = null;
    }
    delete this._innerHTMLString;
    return this
  };

  VirtualHTMLElement.prototype.getProperty = function getProperty (name) {
    if (this.htmlProps) {
      return this.htmlProps[name]
    }
  };

  VirtualHTMLElement.prototype.setProperty = function setProperty (name, value) {
    if (!this.htmlProps) {
      this.htmlProps = {};
    }
    this.htmlProps[name] = value;
    return this
  };

  VirtualHTMLElement.prototype.removeProperty = function removeProperty (name) {
    if (this.htmlProps) {
      delete this.htmlProps[name];
    }
    return this
  };

  VirtualHTMLElement.prototype.getStyle = function getStyle (name) {
    if (this.style) {
      return this.style[name]
    }
  };

  VirtualHTMLElement.prototype.setStyle = function setStyle (name, value) {
    if (!this.style) {
      this.style = {};
    }
    if (DOMElement.pxStyles[name] && isNumber(value)) { value = value + 'px'; }
    this.style[name] = value;
    return this
  };

  VirtualHTMLElement.prototype._createEventListener = function _createEventListener (eventName, handler, options) {
    options.context = options.context || this._owner._comp;
    return VirtualElement.prototype._createEventListener.call(this, eventName, handler, options)
  };

  VirtualHTMLElement.prototype.getNodeType = function getNodeType () {
    return "element"
  };

  VirtualHTMLElement.prototype.hasInnerHTML = function hasInnerHTML () {
    return Boolean(this._innerHTMLString)
  };

  VirtualHTMLElement.prototype._normalizeChild = function _normalizeChild (child) {
    if (isNil(child)) {
      return
    } else if (child._isVirtualElement) {
      return child
    } else if (isString$1(child) || isBoolean(child) || isNumber(child)) {
      return new VirtualTextNode(String(child))
    } else {
      throw new Error('Unsupported child type')
    }
  };

  VirtualHTMLElement.prototype._append = function _append (outlet, args) {
    if (args.length === 1 && !isArray$1(args[0])) {
      this._appendChild(outlet, args[0]);
      return
    }
    var children;
    if (isArray$1(args[0])) {
      children = args[0];
    } else if (arguments.length > 1) {
      children = Array.prototype.slice.call(args,0);
    } else {
      return
    }
    children.forEach(this._appendChild.bind(this, outlet));
  };

  VirtualHTMLElement.prototype._appendChild = function _appendChild (outlet, child) {
    child = this._normalizeChild(child);
    
    
    if (!child) { return }
    outlet.push(child);
    this._attach(child);
    return child
  };

  VirtualHTMLElement.prototype._insertAt = function _insertAt (outlet, pos, child) {
    if (!child) { return }
    outlet.splice(pos, 0, child);
    this._attach(child);
  };

  VirtualHTMLElement.prototype._removeAt = function _removeAt (outlet, pos) {
    var child = outlet[pos];
    outlet.splice(pos, 1);
    this._detach(child);
  };

  VirtualHTMLElement.prototype._attach = function _attach (child) {
    child.parent = this;
    if (this._context && child._owner !== this._owner && child._ref) {
      this._context.foreignRefs[child._ref] = child;
    }
  };

  VirtualHTMLElement.prototype._detach = function _detach (child) {
    child.parent = null;
    if (this._context && child._owner !== this._owner && child._ref) {
      delete this.context.foreignRefs[child._ref];
    }
  };

  VirtualHTMLElement.prototype._mergeHTMLConfig = function _mergeHTMLConfig (other) {
    if (other.classNames) {
      if (!this.classNames) {
        this.classNames = [];
      }
      this.classNames = this.classNames.concat(other.classNames);
    }
    if (other.attributes) {
      if (!this.attributes) {
        this.attributes = {};
      }
      Object.assign(this.attributes, other.attributes);
    }
    if (other.htmlProps) {
      if (!this.htmlProps) {
        this.htmlProps = {};
      }
      Object.assign(this.htmlProps, other.htmlProps);
    }
    if (other.style) {
      if (!this.style) {
        this.style = {};
      }
      Object.assign(this.style, other.style);
    }
    if (other.eventListeners) {
      if (!this.eventListeners) {
        this.eventListeners = [];
      }
      this.eventListeners = this.eventListeners.concat(other.eventListeners);
    }
  };

  return VirtualHTMLElement;
}(VirtualElement));

VirtualHTMLElement.prototype._isVirtualHTMLElement = true;



var VirtualComponent = (function (VirtualHTMLElement) {
  function VirtualComponent(ComponentClass, props) {
    VirtualHTMLElement.call(this);

    props = props || {};

    this.ComponentClass = ComponentClass;
    this.props = props;
    if (!props.children) {
      props.children = [];
    }
    this.children = props.children;
  }

  if ( VirtualHTMLElement ) VirtualComponent.__proto__ = VirtualHTMLElement;
  VirtualComponent.prototype = Object.create( VirtualHTMLElement && VirtualHTMLElement.prototype );
  VirtualComponent.prototype.constructor = VirtualComponent;

  var prototypeAccessors$1 = { _isVirtualComponent: {} };

  prototypeAccessors$1._isVirtualComponent.get = function () { return true; };

  VirtualComponent.prototype.getComponent = function getComponent () {
    return this._comp
  };

  
  
  VirtualComponent.prototype.getChildren = function getChildren () {
    return this.props.children
  };

  VirtualComponent.prototype.getNodeType = function getNodeType () {
    return 'component'
  };

  VirtualComponent.prototype.outlet = function outlet (name) {
    return new Outlet(this, name)
  };

  VirtualComponent.prototype._attach = function _attach (child) {
    child._preliminaryParent = this;
  };

  VirtualComponent.prototype._detach = function _detach (child) {
    child._preliminaryParent = null;
  };

  VirtualComponent.prototype._copyHTMLConfig = function _copyHTMLConfig () {
    return {
      classNames: clone(this.classNames),
      attributes: clone(this.attributes),
      htmlProps: clone(this.htmlProps),
      style: clone(this.style),
      eventListeners: clone(this.eventListeners)
    }
  };

  Object.defineProperties( VirtualComponent.prototype, prototypeAccessors$1 );

  return VirtualComponent;
}(VirtualHTMLElement));

var Outlet = function Outlet(virtualEl, name) {
  this.virtualEl = virtualEl;
  this.name = name;
  Object.freeze(this);
};

Outlet.prototype._getOutlet = function _getOutlet () {
  var outlet = this.virtualEl.props[this.name];
  if (!outlet) {
    outlet = [];
    this.virtualEl.props[this.name] = outlet;
  }
  return outlet
};

Outlet.prototype.append = function append () {
  var outlet = this._getOutlet();
  this.virtualEl._append(outlet, arguments);
  return this
};

Outlet.prototype.empty = function empty () {
  var arr = this.virtualEl.props[this.name];
  arr.forEach(function(el) {
    this._detach(el);
  }.bind(this));
  arr.splice(0, arr.length);
  return this
};


var VirtualTextNode = (function (VirtualElement) {
  function VirtualTextNode(text) {
    VirtualElement.call(this);
    this.text = text;
  }

  if ( VirtualElement ) VirtualTextNode.__proto__ = VirtualElement;
  VirtualTextNode.prototype = Object.create( VirtualElement && VirtualElement.prototype );
  VirtualTextNode.prototype.constructor = VirtualTextNode;

  var prototypeAccessors$2 = { _isVirtualTextNode: {} };

  prototypeAccessors$2._isVirtualTextNode.get = function () { return true; };

  Object.defineProperties( VirtualTextNode.prototype, prototypeAccessors$2 );

  return VirtualTextNode;
}(VirtualElement));

VirtualElement.Component = VirtualComponent;
VirtualElement.TextNode = VirtualTextNode;


VirtualElement.createElement = function() {
  var content;
  var _first = arguments[0];
  var _second = arguments[1];
  var type;
  if (isString$1(_first)) {
    type = "element";
  } else if (isFunction$1(_first) && _first.prototype._isComponent) {
    type = "component";
  } else if (isNil(_first)) {
    throw new Error('$$(null): provided argument was null or undefined.')
  } else {
    throw new Error('Illegal usage of $$()')
  }
  
  var props = {};
  var classNames, ref;
  var eventHandlers = [];
  for(var key in _second) {
    if (!_second.hasOwnProperty(key)) { continue }
    var val = _second[key];
    switch(key) {
      case 'class':
        classNames = val;
        break
      case 'ref':
        ref = val;
        break
      default:
        props[key] = val;
    }
  }
  if (type === 'element') {
    content = new VirtualHTMLElement(_first);
    
    
    content.attr(props);
  } else {
    content = new VirtualComponent(_first, props);
  }
  
  
  content._owner = this.owner;
  if (classNames) {
    content.addClass(classNames);
  }
  if (ref) {
    content.ref(ref);
  }
  eventHandlers.forEach(function(h) {
    if (isFunction$1(h.handler)) {
      content.on(h.name, h.handler);
    } else if (isPlainObject$1(h.handler)) {
      var params = h.handler;
      content.on(h.name, params.handler, params.context, params);
    } else {
      throw new Error('Illegal arguments for $$(_,{ on'+h.name+'})')
    }
  });
  
  
  if (arguments.length > 2) {
    content.append(flattenOften(Array.prototype.slice.call(arguments, 2), 3));
  }
  return content
};

var RenderingEngine = function RenderingEngine(options) {
  if ( options === void 0 ) options = {};

  this.elementFactory = options.elementFactory || DefaultDOMElement.createDocument('html');
};

RenderingEngine.prototype._render = function _render$1 (comp, oldProps, oldState) {
  
  var vel = _createWrappingVirtualComponent(comp);
  var state = new RenderingEngine.State(this.elementFactory);
  if (oldProps) {
    state.setOldProps(vel, oldProps);
  }
  if (oldState) {
    state.setOldState(vel, oldState);
  }
  try {
    
    
    
    _capture(state, vel, 'forceCapture');
    

    
    
    _render(state, vel);
    

    _triggerUpdate(state, vel);

  } finally {
    state.dispose();
  }
  
};


RenderingEngine.prototype._renderChild = function _renderChild (comp, vel) {
  
  
  var state = new RenderingEngine.State(this.elementFactory);
  vel.parent = { _comp: comp };
  try {
    _capture(state, vel);
    _render(state, vel);
    return vel._comp
  } finally {
    state.dispose();
  }
};

function _create(state, vel) {
  var comp = vel._comp;
  console.assert(!comp, "Component instance should not exist when this method is used.");
  var parent = vel.parent._comp;
  
  if (!parent) {
    parent = _create(state, vel.parent);
  }
  if (vel._isVirtualComponent) {
    console.assert(parent, "A Component should have a parent.");
    comp = new vel.ComponentClass(parent, vel.props);
    
    vel.props = comp.props;
    comp.__htmlConfig__ = vel._copyHTMLConfig();
  } else if (vel._isVirtualHTMLElement) {
    comp = new Component.Element(parent, vel);
  } else if (vel._isVirtualTextNode) {
    comp = new Component.TextNode(parent, vel);
  }
  if (vel._ref) {
    comp._ref = vel._ref;
  }
  if (vel._owner) {
    comp._owner = vel._owner._comp;
  }
  vel._comp = comp;
  return comp
}

function _capture(state, vel, forceCapture) {
  if (state.isCaptured(vel)) {
    return vel
  }
  
  var comp = vel._comp;
  if (!comp) {
    comp = _create(state, vel);
    state.setNew(vel);
  }
  if (vel._isVirtualComponent) {
    var needRerender;
    
    
    
    if (forceCapture) {
      needRerender = true;
    } else {
      
      needRerender = !comp.el || comp.shouldRerender(vel.props, comp.state);
      comp.__htmlConfig__ = vel._copyHTMLConfig();
      state.setOldProps(vel, comp.props);
      state.setOldState(vel, comp.state);
      
      comp._setProps(vel.props);
      if (!state.isNew(vel)) {
        state.setUpdated(vel);
      }
    }
    if (needRerender) {
      var context = new CaptureContext(vel);
      var content = comp.render(context.$$);
      if (!content || !content._isVirtualHTMLElement) {
        throw new Error("Component.render must return VirtualHTMLElement")
      }

      if (comp.__htmlConfig__) {
        content._mergeHTMLConfig(comp.__htmlConfig__);
      }
      content._comp = comp;
      vel._content = content;
      if (!state.isNew(vel) && comp.isMounted()) {
        state.setUpdated(vel);
      }
      
      _prepareVirtualComponent(state, comp, content);
      
      
      if (substanceGlobals.DEBUG_RENDERING) {
        
        
        
        
        var stack = content.children.slice(0);
        while (stack.length) {
          var child = stack.shift();
          if (state.isCaptured(child)) { continue }
          
          if (child._isVirtualComponent) { continue }
          if (!child._comp) {
            _create(state, child);
          }
          if (child._isVirtualHTMLElement && child.children.length > 0) {
            stack = stack.concat(child.children);
          }
          state.setCaptured(child);
        }
        state.setCaptured(content);
        
        
        var descendingContext = new DescendingContext(state, context);
        while (descendingContext.hasPendingCaptures()) {
          descendingContext.reset();
          comp.render(descendingContext.$$);
        }
      } else {
        
        
        _capture(state, vel._content);
      }
    } else {
      state.setSkipped(vel);
    }
  } else if (vel._isVirtualHTMLElement) {
    for (var i = 0; i < vel.children.length; i++) {
      _capture(state, vel.children[i]);
    }
  }
  state.setCaptured(vel);
  return vel
}

function _render(state, vel) {
  if (state.isSkipped(vel)) { return }
  

  
  
  
  
  
  

  var comp = vel._comp;
  console.assert(comp && comp._isComponent, "A captured VirtualElement must have a component instance attached.");

  
  if (vel._isVirtualComponent) {
    _render(state, vel._content);

    
    var context = vel._content._context;
    var refs = {};
    var foreignRefs = {};
    forEach(context.refs, function (vel, ref) {
      refs[ref] = vel._comp;
    });
    forEach(context.foreignRefs, function (vel, ref) {
      foreignRefs[ref] = vel._comp;
    });
    comp.refs = refs;
    comp.__foreignRefs__ = foreignRefs;
    return
  }

  
  if (!comp.el) {
    comp.el = _createElement(state, vel);
    comp.el._comp = comp;
  }
  _updateElement(comp, vel);

  
  if (vel._isVirtualHTMLElement && !vel.hasInnerHTML()) {
    var newChildren = vel.children;
    var oldComp, virtualComp, newComp;
    var pos1 = 0; var pos2 = 0;

    
    
    
    var oldChildren = [];
    comp.el.getChildNodes().forEach(function(node) {
      var childComp = node._comp;

      
      
      
      

      
      if (!childComp || state.isRelocated(childComp)) {
        comp.el.removeChild(node);
      } else {
        oldChildren.push(childComp);
      }
    });

    while(pos1 < oldChildren.length || pos2 < newChildren.length) {
      
      
      
      
      do {
        oldComp = oldChildren[pos1++];
      } while (oldComp && (state.isDetached(oldComp)))

      virtualComp = newChildren[pos2++];
      
      if (oldComp && !virtualComp) {
        while (oldComp) {
          _removeChild(state, comp, oldComp);
          oldComp = oldChildren[pos1++];
        }
        break
      }

      
      if (oldComp && oldComp.el.isTextNode() &&
          virtualComp && virtualComp._isVirtualTextNode &&
          oldComp.el.textContent === virtualComp.text ) {
        continue
      }

      if (!state.isRendered(virtualComp)) {
        _render(state, virtualComp);
      }

      newComp = virtualComp._comp;

      
      if (state.isRelocated(newComp)) {
        newComp._setParent(comp);
      }

      console.assert(newComp, 'Component instance should now be available.');
      
      if (virtualComp && !oldComp) {
        _appendChild(state, comp, newComp);
        continue
      }
      
      else if (state.isMapped(virtualComp)) {
        
        if (newComp === oldComp) {
          
        } else {
          
          state.setDetached(oldComp);
          _removeChild(state, comp, oldComp);
          pos2--;
        }
      }
      else if (state.isMapped(oldComp)) {
        _insertChildBefore(state, comp, newComp, oldComp);
        pos1--;
      }
      else {
        
        
        
        
        _replaceChild(state, comp, oldComp, newComp);
      }
    }
  }

  state.setRendered(vel);
}

function _triggerUpdate(state, vel) {
  if (vel._isVirtualComponent) {
    if (!state.isSkipped(vel)) {
      vel._content.children.forEach(_triggerUpdate.bind(null, state));
    }
    if (state.isUpdated(vel)) {
      vel._comp.didUpdate(state.getOldProps(vel), state.getOldState(vel));
    }
  } else if (vel._isVirtualHTMLElement) {
    vel.children.forEach(_triggerUpdate.bind(null, state));
  }
}

function _appendChild(state, parent, child) {
  parent.el.appendChild(child.el);
  _triggerDidMount(state, parent, child);
}

function _replaceChild(state, parent, oldChild, newChild) {
  parent.el.replaceChild(oldChild.el, newChild.el);
  if (!state.isDetached(oldChild)) {
    oldChild.triggerDispose();
  }
  _triggerDidMount(state, parent, newChild);
}

function _insertChildBefore(state, parent, child, before) {
  parent.el.insertBefore(child.el, before.el);
  _triggerDidMount(state, parent, child);
}

function _removeChild(state, parent, child) {
  parent.el.removeChild(child.el);
  if (!state.isDetached(child)) {
    child.triggerDispose();
  }
}

function _triggerDidMount(state, parent, child) {
  if (!state.isDetached(child) &&
      parent.isMounted() && !child.isMounted()) {
    child.triggerDidMount(true);
  }
}


function _prepareVirtualComponent(state, comp, vc) {
  var newRefs = {};
  var foreignRefs = {};
  
  
  
  
  if (vc._context) {
    newRefs = vc._context.refs;
    foreignRefs = vc._context.foreignRefs;
  }
  var oldRefs = comp.refs;
  var oldForeignRefs = comp.__foreignRefs__;
  
  forEach(newRefs, function(vc, ref) {
    var comp = oldRefs[ref];
    if (comp) { _mapComponents(state, comp, vc); }
  });
  forEach(foreignRefs, function(vc, ref) {
    var comp = oldForeignRefs[ref];
    if (comp) { _mapComponents(state, comp, vc); }
  });
}



function _mapComponents(state, comp, vc) {
  if (!comp && !vc) { return true }
  if (!comp || !vc) { return false }
  
  
  
  
  
  if (state.isMapped(vc) || state.isMapped(comp)) {
    return vc._comp === comp
  }
  if (vc._comp) {
    if (vc._comp === comp) {
      state.setMapped(vc);
      state.setMapped(comp);
      return true
    } else {
      return false
    }
  }
  if (!_isOfSameType(comp, vc)) {
    return false
  }

  vc._comp = comp;
  state.setMapped(vc);
  state.setMapped(comp);

  var canMapParent;
  var parent = comp.getParent();
  if (vc.parent) {
    canMapParent = _mapComponents(state, parent, vc.parent);
  }
  
  
  
  
  else if (vc._preliminaryParent) {
    while (parent && parent._isElementComponent) {
      parent = parent.getParent();
    }
    canMapParent = _mapComponents(state, parent, vc._preliminaryParent);
  }
  if (!canMapParent) {
    state.setRelocated(vc);
    state.setRelocated(comp);
  }
  return canMapParent
}

function _isOfSameType(comp, vc) {
  return (
    (comp._isElementComponent && vc._isVirtualHTMLElement) ||
    (comp._isComponent && vc._isVirtualComponent && comp.constructor === vc.ComponentClass) ||
    (comp._isTextNodeComponent && vc._isVirtualTextNode)
  )
}

function _createElement(state, vel) {
  var el;
  if (vel._isVirtualTextNode) {
    el = state.elementFactory.createTextNode(vel.text);
  } else {
    el = state.elementFactory.createElement(vel.tagName);
  }
  return el
}

function _updateElement(comp, vel) {
  if (comp._isTextNodeComponent) {
    comp.setTextContent(vel.text);
    return
  }
  var el = comp.el;
  console.assert(el, "Component's element should exist at this point.");
  var tagName = el.getTagName();
  if (vel.tagName.toLowerCase() !== tagName) {
    el.setTagName(vel.tagName);
  }
  _updateHash({
    oldHash: el.getAttributes(),
    newHash: vel.getAttributes(),
    update: function(key, val) {
      el.setAttribute(key, val);
    },
    remove: function(key) {
      el.removeAttribute(key);
    }
  });
  _updateHash({
    oldHash: el.htmlProps,
    newHash: vel.htmlProps,
    update: function(key, val) {
      el.setProperty(key, val);
    },
    remove: function(key) {
      el.removeProperty(key);
    }
  });
  _updateListeners({
    el: el,
    oldListeners: el.getEventListeners(),
    newListeners: vel.getEventListeners()
  });

  
  if (vel.hasInnerHTML()) {
    if (!el._hasInnerHTML) {
      el.empty();
      el.setInnerHTML(vel.getInnerHTML());
    } else {
      var oldInnerHTML = el.getInnerHTML();
      var newInnerHTML = vel.getInnerHTML();
      if (oldInnerHTML !== newInnerHTML) {
        el.setInnerHTML(newInnerHTML);
      }
    }
    el._hasInnerHTML = true;
  }
}

function _updateHash(args) {
  var newHash = args.newHash;
  var oldHash = args.oldHash || {};
  var updatedKeys = {};
  var update = args.update;
  var remove = args.remove;
  var key;
  for (key in newHash) {
    if (newHash.hasOwnProperty(key)) {
      var oldVal = oldHash[key];
      var newVal = newHash[key];
      updatedKeys[key] = true;
      if (oldVal !== newVal) {
        update(key, newVal);
      }
    }
  }
  for (key in oldHash) {
    if (oldHash.hasOwnProperty(key) && !updatedKeys[key]) {
      remove(key);
    }
  }
}

function _updateListeners(args) {
  var el = args.el;
  
  
  
  var newListeners = args.newListeners || [];
  el.removeAllEventListeners();
  for (var i=0; i<newListeners.length;i++) {
    el.addEventListener(newListeners[i]);
  }
}




var DescendingContext = function DescendingContext(state, captureContext) {
  this.state = state;
  this.owner = captureContext.owner;
  this.refs = {};
  this.foreignRefs = {};
  this.elements = captureContext.elements;
  this.pos = 0;
  this.updates = captureContext.components.length;
  this.remaining = this.updates;

  this.$$ = this._createComponent.bind(this);
};

DescendingContext.prototype._createComponent = function _createComponent () {
  var state = this.state;
  var vel = this.elements[this.pos++];
  
  
  
  if (!state.isCaptured(vel) && vel._isVirtualComponent &&
       vel.parent && state.isCaptured(vel.parent)) {
    _capture(state, vel);
    this.updates++;
    this.remaining--;
  }
  
  
  
  
  vel = VirtualElement.createElement.apply(this, arguments);
  
  vel._context = this;
  vel._owner = this.owner;
  
  
  vel._attach = function() {};
  vel._detach = function() {};
  return vel
};

DescendingContext.prototype.hasPendingCaptures = function hasPendingCaptures () {
  return this.updates > 0 && this.remaining > 0
};

DescendingContext.prototype.reset = function reset () {
  this.pos = 0;
  this.updates = 0;
  this.refs = {};
};

DescendingContext.prototype._ancestorsReady = function _ancestorsReady (vel) {
    var this$1 = this;

  while (vel) {
    if (this$1.state.isCaptured(vel) ||
        
        vel === this$1.owner || vel === this$1.owner._content) {
      return true
    }
    vel = vel.parent;
  }
  return false
};

RenderingEngine._internal = {
  _capture: _capture,
  _wrap: _createWrappingVirtualComponent,
};

var CaptureContext = function CaptureContext(owner) {
  this.owner = owner;
  this.refs = {};
  this.foreignRefs = {};
  this.elements = [];
  this.components = [];
  this.$$ = this._createComponent.bind(this);
  this.$$.capturing = true;
};

CaptureContext.prototype._createComponent = function _createComponent () {
  var vel = VirtualElement.createElement.apply(this, arguments);
  vel._context = this;
  vel._owner = this.owner;
  if (vel._isVirtualComponent) {
    
    this.components.push(vel);
  }
  this.elements.push(vel);
  return vel
};


function _createWrappingVirtualComponent(comp) {
  var vel = new VirtualElement.Component(comp.constructor);
  vel._comp = comp;
  if (comp.__htmlConfig__) {
    vel._mergeHTMLConfig(comp.__htmlConfig__);
  }
  return vel
}

RenderingEngine.createContext = function(comp) {
  var vel = _createWrappingVirtualComponent(comp);
  return new CaptureContext(vel)
};


var RenderingState = function RenderingState(elementFactory) {
  this.elementFactory = elementFactory;
  this.poluted = [];
  this.id = "__"+uuid();
};

RenderingState.prototype.dispose = function dispose () {
  var id = this.id;
  this.poluted.forEach(function(obj) {
    delete obj[id];
  });
};

RenderingState.prototype.set = function set (obj, key, val) {
  var info = obj[this.id];
  if (!info) {
    info = {};
    obj[this.id] = info;
    this.poluted.push(obj);
  }
  info[key] = val;
};

RenderingState.prototype.get = function get (obj, key) {
  var info = obj[this.id];
  if (info) {
    return info[key]
  }
};

RenderingState.prototype.setMapped = function setMapped (c) {
  this.set(c, 'mapped', true);
};


RenderingState.prototype.isMapped = function isMapped (c) {
  return Boolean(this.get(c, 'mapped'))
};

RenderingState.prototype.setRelocated = function setRelocated (c) {
  this.set(c, 'relocated', true);
};

RenderingState.prototype.isRelocated = function isRelocated (c) {
  return Boolean(this.get(c, 'relocated'))
};

RenderingState.prototype.setDetached = function setDetached (c) {
  this.set(c, 'detached', true);
};

RenderingState.prototype.isDetached = function isDetached (c) {
  return Boolean(this.get(c, 'detached'))
};

RenderingState.prototype.setCaptured = function setCaptured (vc) {
  this.set(vc, 'captured', true);
};

RenderingState.prototype.isCaptured = function isCaptured (vc) {
  return Boolean(this.get(vc, 'captured'))
};

RenderingState.prototype.setNew = function setNew (vc) {
  this.set(vc, 'created', true);
};

RenderingState.prototype.isNew = function isNew (vc) {
  return Boolean(this.get(vc, 'created'))
};

RenderingState.prototype.setUpdated = function setUpdated (vc) {
  this.set(vc, 'updated', true);
};

RenderingState.prototype.isUpdated = function isUpdated (vc) {
  return Boolean(this.get(vc, 'updated'))
};

RenderingState.prototype.setSkipped = function setSkipped (vc) {
  this.set(vc, 'skipped', true);
};

RenderingState.prototype.isSkipped = function isSkipped (vc) {
  return Boolean(this.get(vc, 'skipped'))
};

RenderingState.prototype.setRendered = function setRendered (vc) {
  this.set(vc, 'rendered', true);
};

RenderingState.prototype.isRendered = function isRendered (vc) {
  return Boolean(this.get(vc, 'rendered'))
};

RenderingState.prototype.setOldProps = function setOldProps (vc, oldProps) {
  this.set(vc, 'oldProps', oldProps);
};

RenderingState.prototype.getOldProps = function getOldProps (vc) {
  return this.get(vc, 'oldProps')
};

RenderingState.prototype.setOldState = function setOldState (vc, oldState) {
  this.set(vc, 'oldState', oldState);
};

RenderingState.prototype.getOldState = function getOldState (vc) {
  return this.get(vc, 'oldState')
};

RenderingEngine.State = RenderingState;

var Component = (function (EventEmitter$$1) {
  function Component(parent, props, options) {
    if ( props === void 0 ) props = {};
    if ( options === void 0 ) options = {};

    EventEmitter$$1.call(this);

    
    
    
    
    

    this.parent = (parent && parent._isComponent) ? parent : null;

    
    this.el = options.el;

    
    
    var context = options.context ? options.context : this._getContext() || {};
    this.context = context;
    Object.freeze(this.context);

    
    
    
    this.renderingEngine = (parent && parent.renderingEngine) || context.renderingEngine || options.renderingEngine || new RenderingEngine();

    
    
    if (this._SKIP_COMPONENT_INIT) { return }

    this.__id__ = uuid();

    
    this.refs = {};
    
    
    
    this.__foreignRefs__ = {};

    
    this._actionHandlers = {};

    
    this.props = props;
    Object.freeze(this.props);

    
    this.state = this.getInitialState() || {};
    Object.freeze(this.state);
  }

  if ( EventEmitter$$1 ) Component.__proto__ = EventEmitter$$1;
  Component.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  Component.prototype.constructor = Component;

  var prototypeAccessors = { textContent: {},innerHTML: {},outerHTML: {},childNodes: {} };

  Component.prototype.getId = function getId () {
    return this.__id__
  };

  Component.prototype.setId = function setId () {
    throw new Error("'id' is readonly")
  };

  
  Component.prototype.getChildContext = function getChildContext () {
    return this.childContext || {}
  };

  
  Component.prototype.getInitialState = function getInitialState () {
    return {}
  };

  
  Component.prototype.getParent = function getParent () {
    return this.parent
  };

  
  Component.prototype.getRoot = function getRoot () {
    var comp = this;
    var parent = comp;
    while (parent) {
      comp = parent;
      parent = comp.getParent();
    }
    return comp
  };

  Component.prototype.getNativeElement = function getNativeElement () {
    return this.el.getNativeElement()
  };

  
  Component.prototype.getLabel = function getLabel (name) {
    var labelProvider = this.context.labelProvider;
    if (!labelProvider) { throw new Error('Missing labelProvider.') }
    return labelProvider.getLabel(name)
  };

  
  Component.prototype.getComponent = function getComponent (componentName, maybe) {
    var componentRegistry = this.getComponentRegistry();
    if (!componentRegistry) { throw new Error('Missing componentRegistry.') }
    var ComponentClass = componentRegistry.get(componentName);
    if (!maybe && !ComponentClass) {
      throw new Error('No Component registered with name ' + componentName)
    }
    return ComponentClass
  };

  Component.prototype.getComponentRegistry = function getComponentRegistry () {
    return this.props.componentRegistry || this.context.componentRegistry
  };

  Component.prototype.getFlow = function getFlow () {
    return this.context.flow
  };

  
  Component.prototype.render = function render ($$) {
    
    return $$('div')
  };

  
  Component.prototype.mount = function mount (el) {
    if (!el) {
      throw new Error('Element is required.')
    }
    el = DefaultDOMElement.wrap(el);
    
    this.el = null;
    this.renderingEngine = new RenderingEngine({ elementFactory: el.getOwnerDocument() });
    this._render();
    el.appendChild(this.el);
    if (el.isInDocument()) {
      this.triggerDidMount(true);
    }
    return this
  };

  
  Component.prototype.shouldRerender = function shouldRerender (newProps, newState) { 
    return true
  };

  
  Component.prototype.rerender = function rerender () {
    this._rerender(this.props, this.state);
  };

  Component.prototype._rerender = function _rerender (oldProps, oldState) {
    this._render(oldProps, oldState);
    
    if (!this.isMounted()) {
      this.didUpdate(oldProps, oldState);
    }
  };

  Component.prototype._render = function _render (oldProps, oldState) {
    if (this.__isRendering__) {
      throw new Error('Component is rendering already.')
    }
    this.__isRendering__ = true;
    try {
      this.renderingEngine._render(this, oldProps, oldState);
    } finally {
      delete this.__isRendering__;
    }
  };

  
  Component.prototype.triggerDidMount = function triggerDidMount () {
    
    
    

    
    
    if (!this.__isMounted__) {
      this.__isMounted__ = true;
      this.didMount();
    }
    
    this.getChildren().forEach(function(child) {
      
      
      child.triggerDidMount(true);
    });
  };

  
  Component.prototype.didMount = function didMount () {};

  
  Component.prototype.didUpdate = function didUpdate () {};

  
  Component.prototype.isMounted = function isMounted () {
    return this.__isMounted__
  };

  
  Component.prototype.triggerDispose = function triggerDispose () {
    this.getChildren().forEach(function(child) {
      child.triggerDispose();
    });
    this.dispose();
    this.__isMounted__ = false;
  };

  
  Component.prototype.dispose = function dispose () {};

  
  Component.prototype._setParent = function _setParent (newParent) {
    this.parent = newParent;
    this.context = this._getContext() || {};
    Object.freeze(this.context);
  };

  
  Component.prototype.send = function send (action) {
    var arguments$1 = arguments;

    var comp = this;
    while(comp) {
      if (comp._actionHandlers && comp._actionHandlers[action]) {
        comp._actionHandlers[action].apply(comp, Array.prototype.slice.call(arguments$1, 1));
        return true
      }
      comp = comp.getParent();
    }
    console.warn('Action', action, 'was not handled.');
    return false
  };

  
  Component.prototype.handleActions = function handleActions (actionHandlers) {
    forEach(actionHandlers, function(method, actionName) {
      this.handleAction(actionName, method);
    }.bind(this));
    return this
  };

  
  Component.prototype.handleAction = function handleAction (name, handler) {
    if (!name || !handler || !isFunction$1(handler)) {
      throw new Error('Illegal arguments.')
    }
    handler = handler.bind(this);
    this._actionHandlers[name] = handler;
  };

  
  Component.prototype.getState = function getState () {
    return this.state
  };

  
  Component.prototype.setState = function setState (newState) {
    var oldProps = this.props;
    var oldState = this.state;
    
    
    var needRerender = !this.__isSettingProps__ &&
      this.shouldRerender(this.getProps(), newState);
    
    this.willUpdateState(newState);
    this.state = newState || {};
    Object.freeze(this.state);
    if (needRerender) {
      this._rerender(oldProps, oldState);
    } else if (!this.__isSettingProps__) {
      this.didUpdate(oldProps, oldState);
    }
  };

  
  Component.prototype.extendState = function extendState (newState) {
    newState = extend({}, this.state, newState);
    this.setState(newState);
  };

  
  Component.prototype.willUpdateState = function willUpdateState (newState) { 
  };

  
  Component.prototype.getProps = function getProps () {
    return this.props
  };

  
  Component.prototype.setProps = function setProps (newProps) {
    var oldProps = this.props;
    var oldState = this.state;
    var needRerender = this.shouldRerender(newProps, this.state);
    this._setProps(newProps);
    if (needRerender) {
      this._rerender(oldProps, oldState);
    } else {
      this.didUpdate(oldProps, oldState);
    }
  };

  Component.prototype._setProps = function _setProps (newProps) {
    newProps = newProps || {};
    
    this.__isSettingProps__ = true;
    try {
      this.willReceiveProps(newProps);
      this.props = newProps || {};
      Object.freeze(newProps);
    } finally {
      delete this.__isSettingProps__;
    }
  };

  
  Component.prototype.extendProps = function extendProps (updatedProps) {
    var newProps = extend({}, this.props, updatedProps);
    this.setProps(newProps);
  };

  
  Component.prototype.willReceiveProps = function willReceiveProps (newProps) { 
  };

  Component.prototype.getTextContent = function getTextContent () {
    if (this.el) {
      return this.el.textContent
    }
  };

  prototypeAccessors.textContent.get = function () {
    return this.getTextContent()
  };

  Component.prototype.getInnerHTML = function getInnerHTML () {
    if (this.el) {
      return this.el.getInnerHTML()
    }
  };

  prototypeAccessors.innerHTML.get = function () {
    return this.getInnerHTML()
  };

  Component.prototype.getOuterHTML = function getOuterHTML () {
    if (this.el) {
      return this.el.getOuterHTML()
    }
  };

  prototypeAccessors.outerHTML.get = function () {
    return this.getOuterHTML()
  };

  Component.prototype.getAttribute = function getAttribute (name) {
    if (this.el) {
      return this.el.getAttribute(name)
    }
  };

  Component.prototype.setAttribute = function setAttribute (name, val) {
    if (this.el) {
      this.el.setAttribute(name, val);
    }
    return this
  };

  Component.prototype.getProperty = function getProperty (name) {
    if (this.el) {
      return this.el.getProperty(name)
    }
  };

  Component.prototype.setProperty = function setProperty (name, val) {
    if (this.el) {
      this.el.setProperty(name, val);
    }
    return this
  };

  Component.prototype.hasClass = function hasClass (name) {
    if (this.el) {
      return this.el.hasClass(name)
    }
  };

  Component.prototype.addClass = function addClass (name) {
    if (this.el) {
      this.el.addClass(name);
    }
    return this
  };

  Component.prototype.removeClass = function removeClass (name) {
    if (this.el) {
      this.el.removeClass(name);
    }
    return this
  };

  Component.prototype.getStyle = function getStyle (name) {
    if (this.el) {
      return this.el.getStyle(name)
    }
  };

  Component.prototype.setStyle = function setStyle (name, val) {
    if (this.el) {
      return this.el.setStyle(name, val)
    }
    return this
  };

  Component.prototype.getValue = function getValue () {
    if (this.el) {
      return this.el.getValue()
    }
  };

  Component.prototype.setValue = function setValue (val) {
    if (this.el) {
      this.el.setValue(val);
    }
    return this
  };

  Component.prototype.getChildCount = function getChildCount () {
    if (!this.el) { return 0 }
    return this.el.getChildCount()
  };

  prototypeAccessors.childNodes.get = function () {
    return this.getChildNodes()
  };

  Component.prototype.getChildNodes = function getChildNodes () {
    if (!this.el) { return [] }
    var childNodes = this.el.getChildNodes();
    childNodes = childNodes.map(_unwrapComp).filter(Boolean);
    return childNodes
  };

  Component.prototype.getChildren = function getChildren () {
    if (!this.el) { return [] }
    var children = this.el.getChildren();
    children = children.map(_unwrapComp).filter(Boolean);
    return children
  };

  Component.prototype.getChildAt = function getChildAt (pos) {
    var node = this.el.getChildAt(pos);
    return _unwrapCompStrict(node)
  };

  Component.prototype.find = function find$$1 (cssSelector) {
    var el = this.el.find(cssSelector);
    return _unwrapComp(el)
  };

  Component.prototype.findAll = function findAll (cssSelector) {
    var els = this.el.findAll(cssSelector);
    return els.map(_unwrapComp).filter(Boolean)
  };

  Component.prototype.appendChild = function appendChild (child) {
    this.insertAt(this.getChildCount(), child);
  };

  Component.prototype.insertAt = function insertAt (pos, childEl) {
    if (isString$1(childEl)) {
      childEl = new VirtualElement.TextNode(childEl);
    }
    if (!childEl._isVirtualElement) {
      throw new Error('Invalid argument: "child" must be a VirtualElement.')
    }
    var child = this.renderingEngine._renderChild(this, childEl);
    this.el.insertAt(pos, child.el);
    _mountChild(this, child);
  };

  Component.prototype.removeAt = function removeAt (pos) {
    var childEl = this.el.getChildAt(pos);
    if (childEl) {
      var child = _unwrapCompStrict(childEl);
      _disposeChild(child);
      this.el.removeAt(pos);
    }
  };

  Component.prototype.removeChild = function removeChild (child) {
    if (!child || !child._isComponent) {
      throw new Error('removeChild(): Illegal arguments. Expecting a Component instance.')
    }
    
    _disposeChild(child);
    this.el.removeChild(child.el);
  };

  Component.prototype.replaceChild = function replaceChild (oldChild, newChild) {
    if (!newChild || !oldChild ||
        !newChild._isComponent || !oldChild._isComponent) {
      throw new Error('replaceChild(): Illegal arguments. Expecting BrowserDOMElement instances.')
    }
    
    _disposeChild(oldChild);
    this.el.replaceChild(newChild.el, oldChild.el);
    if (this.isMounted()) {
      newChild.triggerDidMount(true);
    }
  };

  
  
  
  
  
  
  Component.prototype.empty = function empty () {
    this._clear();
    return this
  };

  Component.prototype._clear = function _clear () {
    var el = this.el;
    if (el) {
      this.getChildNodes().forEach(function(child) {
        _disposeChild(child);
      });
      el.empty();
    }
    this.refs = {};
    this.__foreignRefs__ = {};
  };

  Component.prototype.remove = function remove () {
    _disposeChild(this);
    this.el.remove();
  };

  Component.prototype.addEventListener = function addEventListener () {
    throw new Error("Not supported.")
  };

  Component.prototype.removeEventListener = function removeEventListener () {
    throw new Error("Not supported.")
  };

  Component.prototype.insertBefore = function insertBefore () {
    throw new Error("Not supported.")
  };

  Component.prototype.click = function click () {
    if (this.el) {
      this.el.click();
    }
  };

  Component.prototype.getComponentPath = function getComponentPath () {
    var path = [];
    var comp = this;
    while (comp) {
      path.unshift(comp);
      comp = comp.getParent();
    }
    return path
  };

  Component.prototype._getContext = function _getContext () {
    var context = {};
    var parent = this.getParent();
    if (parent) {
      context = extend(context, parent.context);
      if (parent.getChildContext) {
        return extend(context, parent.getChildContext())
      }
    }
    return context
  };

  Object.defineProperties( Component.prototype, prototypeAccessors );

  return Component;
}(EventEmitter));

Component.prototype._isComponent = true;

Component.prototype.attr = DOMElement.prototype.attr;

Component.prototype.htmlProp = DOMElement.prototype.htmlProp;

Component.prototype.val = DOMElement.prototype.val;

Component.prototype.css = DOMElement.prototype.css;

Component.prototype.text = DOMElement.prototype.text;

Component.prototype.append = DOMElement.prototype.append;

Component.unwrap = _unwrapComp;

Component.render = function(props) {
  props = props || {};
  var ComponentClass = this;
  var comp = new ComponentClass(null, props);
  comp._render();
  return comp
};

Component.mount = function(props, el) {
  if (arguments.length === 1) {
    el = props;
    props = {};
  }
  if (!el) { throw new Error("'el' is required.") }
  if (isString$1(el)) {
    var selector = el;
    if (platform.inBrowser) {
      el = window.document.querySelector(selector);
    } else {
      throw new Error("This selector is not supported on server side.")
    }
  }
  el = new DefaultDOMElement.wrap(el);
  var ComponentClass = this;
  var comp = new ComponentClass(null, props);
  comp.mount(el);
  return comp
};

Component.getComponentForDOMElement = function(el) {
  return _unwrapComp(el)
};

Component.unwrapDOMElement = function(el) {
  console.warn('DEPRECATED: Use Component.getComponentForDOMElement');
  return Component.getComponentForDOMElement(el)
};

Component.getComponentFromNativeElement = function(nativeEl) {
  
  
  
  return _unwrapComp(DefaultDOMElement.wrap(nativeEl))
};


function _disposeChild(child) {
  child.triggerDispose();
  if (child._owner && child._ref) {
    console.assert(child._owner.refs[child._ref] === child, "Owner's ref should point to this child instance.");
    delete child._owner.refs[child._ref];
  }
}


function _mountChild(parent, child) {
  if (parent.isMounted()) {
    child.triggerDidMount(true);
  }
  if (child._owner && child._ref) {
    child._owner.refs[child._ref] = child;
  }
}


function _unwrapComp(el) {
  if (el) {
    if (!el._isDOMElement) { el = DefaultDOMElement.unwrap(el); }
    if (el) { return el._comp }
  }
}

function _unwrapCompStrict(el) {
  var comp = _unwrapComp(el);
  if (!comp) { throw new Error("Expecting a back-link to the component instance.") }
  return comp
}


var ElementComponent = (function (Component) {
  function ElementComponent(parent) {
    Component.call(this, parent);
  }

  if ( Component ) ElementComponent.__proto__ = Component;
  ElementComponent.prototype = Object.create( Component && Component.prototype );
  ElementComponent.prototype.constructor = ElementComponent;

  return ElementComponent;
}(Component));

ElementComponent.prototype._isElementComponent = true;
ElementComponent.prototype._SKIP_COMPONENT_INIT = true;

var TextNodeComponent = (function (Component) {
  function TextNodeComponent(parent) {
    Component.call(this, parent);
  }

  if ( Component ) TextNodeComponent.__proto__ = Component;
  TextNodeComponent.prototype = Object.create( Component && Component.prototype );
  TextNodeComponent.prototype.constructor = TextNodeComponent;

  TextNodeComponent.prototype.setTextContent = function setTextContent (text) {
    if (!this.el) {
      throw new Error('Component must be rendered first.')
    }
    if (this.el.textContent !== text) {
      this.el.textContent = text;
    }
  };

  TextNodeComponent.prototype.getChildNodes = function getChildNodes () {
    return []
  };

  TextNodeComponent.prototype.getChildren = function getChildren () {
    return []
  };

  return TextNodeComponent;
}(Component));

TextNodeComponent.prototype._isTextNodeComponent = true;
TextNodeComponent.prototype._SKIP_COMPONENT_INIT = true;

Component.Element = ElementComponent;
Component.TextNode = TextNodeComponent;

var ResourceManager = function ResourceManager(editorSession, context) {
  this.editorSession = editorSession;
  this.context = context;
  this.editorSession.onRender('document', this._onDocumentChange, this);
};

ResourceManager.prototype.dispose = function dispose () {
  this.editorSession.off(this);
};


ResourceManager.prototype.triggerFetch = function triggerFetch (resource) {
    var this$1 = this;

  resource.fetchPayload(this.context, function (err, props) {
    if (err) {
      this$1._updateNode(resource.id, {
        errorMessage: err.toString()
      });
    } else {
      this$1._updateNode(resource.id, props);
    }
  });
};

ResourceManager.prototype._onDocumentChange = function _onDocumentChange (change) {
    var this$1 = this;

  var doc = this.editorSession.getDocument();
  forEach(change.created, function (node) {
    node = doc.get(node.id);
    if (node.constructor.isResource) {
      setTimeout(function () {
        this$1.triggerFetch(node);
      });
    }
  });
};


ResourceManager.prototype._updateNode = function _updateNode (nodeId, props) {
  var editorSession = this.editorSession;
  editorSession.transaction(function (tx) {
    forEach(props, function (val, key) {
      tx.set([nodeId, key], val);
    });
  });
};

var AnnotationComponent = (function (Component$$1) {
  function AnnotationComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) AnnotationComponent.__proto__ = Component$$1;
  AnnotationComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  AnnotationComponent.prototype.constructor = AnnotationComponent;

  AnnotationComponent.prototype.didMount = function didMount () {
    var node = this.props.node;
    node.on('highlighted', this.onHighlightedChanged, this);
  };

  
  AnnotationComponent.prototype.dispose = function dispose () {
    var node = this.props.node;
    node.off(this);
  };

  AnnotationComponent.prototype.render = function render ($$) {
    var el = $$(this.getTagName())
      .attr("data-id", this.props.node.id)
      .addClass(this.getClassNames());
    if (this.props.node.highlighted) {
      el.addClass('sm-highlighted');
    }
    el.append(this.props.children);
    return el
  };

  AnnotationComponent.prototype.getClassNames = function getClassNames () {
    return 'sc-'+this.props.node.type
  };

  AnnotationComponent.prototype.onHighlightedChanged = function onHighlightedChanged () {
    if (this.props.node.highlighted) {
      this.el.addClass('sm-highlighted');
    } else {
      this.el.removeClass('sm-highlighted');
    }
  };

  AnnotationComponent.prototype.getTagName = function getTagName () {
    return 'span'
  };

  return AnnotationComponent;
}(Component));

var AbstractIsolatedNodeComponent = (function (Component$$1) {
  function AbstractIsolatedNodeComponent() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Component$$1.apply(this, args);

    this.name = this.props.node.id;
    this._id = this.context.surface.id +'/'+this.name;
    this._state = {
      selectionFragment: null
    };

    this.handleAction('escape', this.escape);
    this.ContentClass = this._getContentClass(this.props.node) || Component$$1;

    
    var useBlocker = platform.isFF || !this.ContentClass.noBlocker;
    this.blockingMode = useBlocker ? 'closed' : 'open';
  }

  if ( Component$$1 ) AbstractIsolatedNodeComponent.__proto__ = Component$$1;
  AbstractIsolatedNodeComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  AbstractIsolatedNodeComponent.prototype.constructor = AbstractIsolatedNodeComponent;

  var prototypeAccessors = { id: {} };

  AbstractIsolatedNodeComponent.prototype.getChildContext = function getChildContext () {
    return {
      isolatedNodeComponent: this,
      
      
      surface: undefined
    }
  };

  AbstractIsolatedNodeComponent.prototype.getInitialState = function getInitialState () {
    var selState = this.context.editorSession.getSelectionState();
    return this._deriveStateFromSelectionState(selState)
  };

  AbstractIsolatedNodeComponent.prototype.didMount = function didMount () {
    Component$$1.prototype.didMount.call(this);

    var editorSession = this.context.editorSession;
    editorSession.onRender('selection', this._onSelectionChanged, this);
  };

  AbstractIsolatedNodeComponent.prototype.dispose = function dispose () {
    Component$$1.prototype.dispose.call(this);

    var editorSession = this.context.editorSession;
    editorSession.off(this);
  };

  AbstractIsolatedNodeComponent.prototype.renderContent = function renderContent ($$, node, options) {
    if ( options === void 0 ) options = {};

    var ComponentClass = this.ContentClass;
    if (!ComponentClass) {
      console.error('Could not resolve a component for type: ' + node.type);
      return $$(this.__elementTag)
    } else {
      var props = Object.assign({
        disabled: this.props.disabled,
        node: node,
        isolatedNodeState: this.state.mode,
        focused: (this.state.mode === 'focused')
      }, options);
      return $$(ComponentClass, props)
    }
  };

  AbstractIsolatedNodeComponent.prototype.getId = function getId () {
    return this._id
  };

  prototypeAccessors.id.get = function () { return this.getId() };

  AbstractIsolatedNodeComponent.prototype.getMode = function getMode () {
    return this.state.mode
  };

  AbstractIsolatedNodeComponent.prototype.isOpen = function isOpen () {
    return this.blockingMode === 'open'
  };

  AbstractIsolatedNodeComponent.prototype.isClosed = function isClosed () {
    return this.blockingMode === 'closed'
  };

  AbstractIsolatedNodeComponent.prototype.isNotSelected = function isNotSelected () {
    return !this.state.mode
  };

  AbstractIsolatedNodeComponent.prototype.isSelected = function isSelected () {
    return this.state.mode === 'selected'
  };

  AbstractIsolatedNodeComponent.prototype.isCoSelected = function isCoSelected () {
    return this.state.mode === 'co-selected'
  };

  AbstractIsolatedNodeComponent.prototype.isFocused = function isFocused () {
    return this.state.mode === 'focused'
  };

  AbstractIsolatedNodeComponent.prototype.isCoFocused = function isCoFocused () {
    return this.state.mode === 'co-focused'
  };

  AbstractIsolatedNodeComponent.prototype.getParentSurface = function getParentSurface () {
    return this.context.surface
  };

  AbstractIsolatedNodeComponent.prototype.escape = function escape () {
    
    this.selectNode();
  };

  AbstractIsolatedNodeComponent.prototype._onSelectionChanged = function _onSelectionChanged () {
    var editorSession = this.context.editorSession;
    var newState = this._deriveStateFromSelectionState(editorSession.getSelectionState());
    if (!newState && this.state.mode) {
      this.extendState({ mode: null });
    } else if (newState && newState.mode !== this.state.mode) {
      this.extendState(newState);
    }
  };

  AbstractIsolatedNodeComponent.prototype.onKeydown = function onKeydown (event) {
    
    
    
    
    if (event.keyCode === keys$1.ESCAPE && this.state.mode === 'focused') {
      event.stopPropagation();
      event.preventDefault();
      this.escape();
    }
  };

  AbstractIsolatedNodeComponent.prototype._getContentClass = function _getContentClass (node) {
    var componentRegistry = this.context.componentRegistry;
    var ComponentClass = componentRegistry.get(node.type);
    return ComponentClass
  };

  AbstractIsolatedNodeComponent.prototype._getSurface = function _getSurface (selState) {
    var surface = selState.get('surface');
    if (surface === undefined) {
      var sel = selState.getSelection();
      if (sel && sel.surfaceId) {
        var surfaceManager = this.context.surfaceManager;
        surface = surfaceManager.getSurface(sel.surfaceId);
      } else {
        surface = null;
      }
      selState.set('surface', surface);
    }
    return surface
  };

  
  
  AbstractIsolatedNodeComponent.prototype._getIsolatedNodes = function _getIsolatedNodes (selState) {
    var isolatedNodes = selState.get('isolatedNodes');
    if (!isolatedNodes) {
      var sel = selState.getSelection();
      isolatedNodes = [];
      if (sel && sel.surfaceId) {
        var surfaceManager = this.context.surfaceManager;
        var surface = surfaceManager.getSurface(sel.surfaceId);
        isolatedNodes = surface.getComponentPath().filter(function (comp) { return comp._isAbstractIsolatedNodeComponent; });
      }
      selState.set('isolatedNodes', isolatedNodes);
    }
    return isolatedNodes
  };

  AbstractIsolatedNodeComponent.prototype._shouldConsumeEvent = function _shouldConsumeEvent (event) {
    var comp = Component$$1.unwrap(event.target);
    return (comp && (comp === this || comp.context.isolatedNodeComponent === this))
  };

  Object.defineProperties( AbstractIsolatedNodeComponent.prototype, prototypeAccessors );

  return AbstractIsolatedNodeComponent;
}(Component));

AbstractIsolatedNodeComponent.prototype._isAbstractIsolatedNodeComponent = true;

var InlineNodeComponent = (function (AbstractIsolatedNodeComponent$$1) {
  function InlineNodeComponent () {
    AbstractIsolatedNodeComponent$$1.apply(this, arguments);
  }

  if ( AbstractIsolatedNodeComponent$$1 ) InlineNodeComponent.__proto__ = AbstractIsolatedNodeComponent$$1;
  InlineNodeComponent.prototype = Object.create( AbstractIsolatedNodeComponent$$1 && AbstractIsolatedNodeComponent$$1.prototype );
  InlineNodeComponent.prototype.constructor = InlineNodeComponent;

  InlineNodeComponent.prototype.render = function render ($$) {
    var node = this.props.node;
    var ContentClass = this.ContentClass;

    var el = $$('span');
    el.addClass(this.getClassNames())
      .addClass('sc-inline-node')
      .addClass('sm-'+this.props.node.type)
      .attr("data-id", node.id)
      .attr('data-inline', '1');

    var disabled = this.isDisabled();

    if (this.state.mode) {
      el.addClass('sm-'+this.state.mode);
    } else {
      el.addClass('sm-not-selected');
    }

    if (!ContentClass.noStyle) {
      el.addClass('sm-default-style');
    }

    
    
    
    el.on('keydown', this.onKeydown);

    el.append(
      this.renderContent($$, node)
        .ref('content')
        .addClass('se-content')
    );

    if (disabled) {
      el.addClass('sm-disabled')
         .attr('contenteditable', false)
         .on('click', this.onClick);
    }

    el.attr('draggable', true);
    return el
  };

  InlineNodeComponent.prototype.isDisabled = function isDisabled () {
    return !this.state.mode || ['co-selected', 'cursor'].indexOf(this.state.mode) > -1;
  };

  InlineNodeComponent.prototype.getClassNames = function getClassNames () {
    return ''
  };

  InlineNodeComponent.prototype.onClick = function onClick (event) {
    if (!this._shouldConsumeEvent(event)) { return }
    this.selectNode();
  };

  InlineNodeComponent.prototype.selectNode = function selectNode () {
    
    var editorSession = this.context.editorSession;
    var surface = this.context.surface;
    var node = this.props.node;
    editorSession.setSelection({
      type: 'property',
      path: node.start.path,
      startOffset: node.start.offset,
      endOffset: node.end.offset,
      containerId: surface.getContainerId(),
      surfaceId: surface.id
    });
  };

  
  
  InlineNodeComponent.prototype._deriveStateFromSelectionState = function _deriveStateFromSelectionState (selState) {
    var surface = this._getSurface(selState);
    if (!surface) { return null }
    
    if (surface === this.context.surface) {
      var sel = selState.getSelection();
      var node = this.props.node;
      if (sel.isPropertySelection() && !sel.isCollapsed() && isEqual(sel.path, node.path)) {
        var nodeSel = node.getSelection();
        if(nodeSel.equals(sel)) {
          return { mode: 'selected' }
        }
        if (sel.contains(nodeSel)) {
          return { mode: 'co-selected' }
        }
      }
    }
    var isolatedNodeComponent = surface.context.isolatedNodeComponent;
    if (!isolatedNodeComponent) { return null }
    if (isolatedNodeComponent === this) {
      return { mode: 'focused' }
    }
    var isolatedNodes = this._getIsolatedNodes(selState);
    if (isolatedNodes.indexOf(this) > -1) {
      return { mode: 'co-focused' }
    }
    return null
  };

  return InlineNodeComponent;
}(AbstractIsolatedNodeComponent));

InlineNodeComponent.prototype._isInlineNodeComponent = true;

var AnnotatedTextComponent = (function (Component$$1) {
  function AnnotatedTextComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) AnnotatedTextComponent.__proto__ = Component$$1;
  AnnotatedTextComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  AnnotatedTextComponent.prototype.constructor = AnnotatedTextComponent;

  AnnotatedTextComponent.prototype.render = function render ($$) {
    var el = this._renderContent($$)
      .addClass('sc-annotated-text')
      .css({ whiteSpace: "pre-wrap" });
    return el
  };

  AnnotatedTextComponent.prototype.getText = function getText () {
    return this.getDocument().get(this.props.path) || ''
  };

  AnnotatedTextComponent.prototype.getAnnotations = function getAnnotations () {
    return this.getDocument().getIndex('annotations').get(this.props.path)
  };

  AnnotatedTextComponent.prototype._getTagName = function _getTagName () {
    return this.props.tagName
  };

  AnnotatedTextComponent.prototype._onDocumentChange = function _onDocumentChange (update) {
    if (update.change && update.change.updated[this.getPath()]) {
      this.rerender();
    }
  };

  AnnotatedTextComponent.prototype._renderContent = function _renderContent ($$) {
    var text = this.getText();
    var annotations = this.getAnnotations();
    var el = $$(this._getTagName() || 'span');
    if (annotations && annotations.length > 0) {
      var fragmenter = new Fragmenter({
        onText: this._renderTextNode.bind(this),
        onEnter: this._renderFragment.bind(this, $$),
        onExit: this._finishFragment.bind(this)
      });
      fragmenter.start(el, text, annotations);
    } else {
      el.append(text);
    }
    return el
  };

  AnnotatedTextComponent.prototype._renderTextNode = function _renderTextNode (context, text) {
    if (text && text.length > 0) {
      context.append(text);
    }
  };

  AnnotatedTextComponent.prototype._renderFragment = function _renderFragment ($$, fragment) {
    var doc = this.getDocument();
    var componentRegistry = this.getComponentRegistry();
    var node = fragment.node;
    
    if (node.type === "container-annotation-fragment") {
      
      
      
    } else if (node.type === "container-annotation-anchor") {
      
      
      
      
    } else {
      var ComponentClass = componentRegistry.get(node.type) || AnnotationComponent;
      if (node.constructor.isInline &&
          
          !ComponentClass.prototype._isInlineNodeComponent &&
          
          !ComponentClass.isCustom) {
        ComponentClass = InlineNodeComponent;
      }
      var el = $$(ComponentClass, { doc: doc, node: node });
      return el
    }
  };

  AnnotatedTextComponent.prototype._finishFragment = function _finishFragment (fragment, context, parentContext) {
    parentContext.append(context);
  };

  
  AnnotatedTextComponent.prototype.getDocument = function getDocument () {
    return this.props.doc || this.context.doc
  };

  return AnnotatedTextComponent;
}(Component));

var CursorComponent = (function (Component$$1) {
  function CursorComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) CursorComponent.__proto__ = Component$$1;
  CursorComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  CursorComponent.prototype.constructor = CursorComponent;

  CursorComponent.prototype.render = function render ($$) {
    
    var el = $$('span').addClass('se-cursor');
    
    
    
    el.append("\uFEFF");
    el.append($$('div').addClass('se-cursor-inner'));

    if (this.props.collaborator) {
      var collaboratorIndex = this.props.collaborator.colorIndex;
      el.addClass('sm-collaborator-'+collaboratorIndex);
    } else {
      el.addClass('sm-local-user');
    }

    return el
  };

  return CursorComponent;
}(Component));

var SelectionFragmentComponent = (function (Component$$1) {
  function SelectionFragmentComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) SelectionFragmentComponent.__proto__ = Component$$1;
  SelectionFragmentComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  SelectionFragmentComponent.prototype.constructor = SelectionFragmentComponent;

  SelectionFragmentComponent.prototype.render = function render ($$) {
    
    var el = $$('span').addClass('se-selection-fragment');
    if (this.props.collaborator) {
      var collaboratorIndex = this.props.collaborator.colorIndex;
      el.addClass('sm-collaborator-'+collaboratorIndex);
    } else {
      el.addClass('sm-local-user');
    }
    el.append(this.props.children);
    return el
  };

  return SelectionFragmentComponent;
}(Component));

var TextPropertyComponent = (function (AnnotatedTextComponent$$1) {
  function TextPropertyComponent () {
    AnnotatedTextComponent$$1.apply(this, arguments);
  }

  if ( AnnotatedTextComponent$$1 ) TextPropertyComponent.__proto__ = AnnotatedTextComponent$$1;
  TextPropertyComponent.prototype = Object.create( AnnotatedTextComponent$$1 && AnnotatedTextComponent$$1.prototype );
  TextPropertyComponent.prototype.constructor = TextPropertyComponent;

  TextPropertyComponent.prototype.getInitialState = function getInitialState () {
    var markersManager = this.context.markersManager;
    var path = this.props.path;
    var markers;
    if (markersManager) {
      
      markersManager.register(this);
      markers = markersManager.getMarkers(path, {
        surfaceId: this.getSurfaceId(),
        containerId: this.getContainerId()
      });
    } else {
      var doc = this.getDocument();
      markers = doc.getAnnotations(path);
    }
    return {
      markers: markers
    }
  };

  TextPropertyComponent.prototype.didMount = function didMount () {
    if (this.context.surface && this.context.surface.hasNativeSpellcheck()) {
      this.domObserver = new window.MutationObserver(this._onDomMutations.bind(this));
      this.domObserver.observe(this.el.getNativeElement(), { subtree: true, characterData: true, characterDataOldValue: true });
    }
  };

  TextPropertyComponent.prototype.dispose = function dispose () {
    if (this.context.markersManager) {
      this.context.markersManager.deregister(this);
    }
  };

  TextPropertyComponent.prototype.render = function render ($$) {
    var path = this.getPath();

    var el = this._renderContent($$)
      .addClass('sc-text-property')
      .attr({
        'data-path': path.join('.')
      })
      .css({
        'white-space': 'pre-wrap'
      });

    if (!this.props.withoutBreak) {
      el.append($$('br'));
    }
    return el
  };

  TextPropertyComponent.prototype.getAnnotations = function getAnnotations () {
    if (this.props.markers) {
      return this.state.markers.concat(this.props.markers)
    } else {
      return this.state.markers
    }
  };

  TextPropertyComponent.prototype._renderFragment = function _renderFragment ($$, fragment) {
    var node = fragment.node;
    var id = node.id;
    var el;
    if (node.type === 'cursor') {
      el = $$(CursorComponent, { collaborator: node.collaborator });
    } else if (node.type === 'selection-fragment') {
      el = $$(SelectionFragmentComponent, { collaborator: node.collaborator });
    } else {
      el = AnnotatedTextComponent$$1.prototype._renderFragment.apply(this, arguments);
      if (id) {
        el.ref(id + '@' + fragment.counter);
      }
    }
    el.attr('data-offset', fragment.pos);
    return el
  };

  TextPropertyComponent.prototype._onDomMutations = function _onDomMutations (mutations) {
    
    if (mutations.length === 2 && mutations[0].target === mutations[1].target) {
      var textEl = DefaultDOMElement.unwrap(mutations[0].target);
      if (textEl) {
        this._applyTextMutation(textEl, mutations[0].oldValue);
        return
      }
    }
    
    this.rerender();
  };

  TextPropertyComponent.prototype._applyTextMutation = function _applyTextMutation (textEl, oldText) {
    
    var offset = _getCharPos(textEl, 0);
    var newText = textEl.textContent;
    var changes = diff(oldText, newText, offset);

    var editorSession = this.context.editorSession;
    var path = this.getPath();
    editorSession.transaction(function(tx) {
      changes.forEach(function(change) {
        
        if (change.type === 'replace') {
          tx.update(path, { type: 'delete', start: change.start, end: change.end });
          tx.update(path, { type: 'insert', start: change.start, text: change.text });
        } else {
          tx.update(path, change);
        }
      });
    });
  };

  TextPropertyComponent.prototype.getPath = function getPath () {
    return this.props.path
  };

  TextPropertyComponent.prototype.getText = function getText () {
    return this.getDocument().get(this.getPath())
  };

  TextPropertyComponent.prototype.getDocument = function getDocument () {
    return this.props.doc ||this.context.doc
  };

  TextPropertyComponent.prototype.getSurface = function getSurface () {
    return this.props.surface || this.context.surface
  };

  TextPropertyComponent.prototype.getSurfaceId = function getSurfaceId () {
    var surface = this.getSurface();
    return surface ? surface.id : null
  };

  TextPropertyComponent.prototype.getContainerId = function getContainerId () {
    var surface = this.getSurface();
    return surface ? surface.getContainerId() : null
  };

  TextPropertyComponent.prototype.isEditable = function isEditable () {
    return this.getSurface().isEditable()
  };

  TextPropertyComponent.prototype.isReadonly = function isReadonly () {
    return this.getSurface().isReadonly()
  };

  TextPropertyComponent.prototype.getDOMCoordinate = function getDOMCoordinate (charPos) {
    return this._getDOMCoordinate(this.el, charPos)
  };


  TextPropertyComponent.prototype._finishFragment = function _finishFragment (fragment, context, parentContext) {
    context.attr('data-length', fragment.length);
    parentContext.append(context);
  };

  TextPropertyComponent.prototype._getDOMCoordinate = function _getDOMCoordinate (el, charPos) {
    var this$1 = this;

    var l;
    var idx = 0;
    if (charPos === 0) {
      return {
        container: el.getNativeElement(),
        offset: 0
      }
    }
    for (var child = el.getFirstChild(); child; child = child.getNextSibling(), idx++) {
      if (child.isTextNode()) {
        l = child.textContent.length;
        if (l >= charPos) {
          return {
            container: child.getNativeElement(),
            offset: charPos
          }
        } else {
          charPos -= l;
        }
      } else if (child.isElementNode()) {
        var length = child.getAttribute('data-length');
        if (length) {
          l = parseInt(length, 10);
          if (l >= charPos) {
            
            if (child.attr('data-inline')) {
              var nextSibling = child.getNextSibling();
              if (nextSibling && nextSibling.isTextNode()) {
                return {
                  container: nextSibling.getNativeElement(),
                  offset: 0
                }
              } else {
                return {
                  container: el.getNativeElement(),
                  offset: el.getChildIndex(child) + 1
                }
              }
            }
            return this$1._getDOMCoordinate(child, charPos, idx)
          } else {
            charPos -= l;
          }
        } else {
          console.error('FIXME: Can not map to DOM coordinates.');
          return null
        }
      }
    }
  };

  return TextPropertyComponent;
}(AnnotatedTextComponent));

TextPropertyComponent.prototype._isTextPropertyComponent = true;





TextPropertyComponent.getCoordinate = function(root, el, offset) {
  var context = _getPropertyContext(root, el, offset);
  if (!context) {
    return null
  }
  
  
  
  var charPos = _getCharPos(context.node, context.offset);
  if (isNumber(charPos)) {
    var coor = new Coordinate(context.path, charPos);
    coor._comp = context.comp;
    return coor
  } else {
    return null
  }
};

function _getPropertyContext(root, node, offset) {
  var result = {
    comp: null,
    el: null,
    path: null,
    node: node,
    offset: offset
  };
  while (node && node !== root) {
    if (node.isElementNode()) {
      var comp = Component.unwrap(node);
      if (comp && comp._isTextPropertyComponent) {
        result.comp = comp;
        result.el = node;
        result.path = comp.getPath();
        return result;
      }
      
      
      
      if (node.getAttribute('data-inline')) {
        result.node = node;
        if (offset > 0) {
          result.offset = 1;
        }
      }
    }
    node = node.getParent();
  }
  return null
}

function _getCharPos(node, offset) {
  var charPos = offset;
  var parent, childIdx;

  

  parent = node.getParent();
  if (node.isTextNode()) {
    
    if (node === parent.firstChild) {
      
      var parentPath = parent.getAttribute('data-path');
      var parentOffset = parent.getAttribute('data-offset');
      if (parentPath) {
        charPos = offset;
      }
      
      else if (parentOffset) {
        charPos = parseInt(parentOffset, 10) + offset;
      }
      
      else {
        charPos = _getCharPos(parent, 0) + offset;
      }
    } else {
      
      childIdx = parent.getChildIndex(node);
      charPos = _getCharPos(parent, childIdx) + offset;
    }
  } else if (node.isElementNode()) {
    var pathStr = node.getAttribute('data-path');
    var offsetStr = node.getAttribute('data-offset');
    
    
    if (pathStr) {
      charPos = _countCharacters(node, offset);
    }
    
    
    else if (offsetStr) {
      childIdx = parent.getChildIndex(node);
      charPos = parseInt(offsetStr, 10) + _countCharacters(node, offset);
    }
    
    
    else {
      childIdx = parent.getChildIndex(node);
      charPos = _getCharPos(parent, childIdx) + _countCharacters(node, offset);
    }
  } else {
    
    return null
  }
  return charPos;
}

function _countCharacters(el, maxIdx) {
  var charPos = 0;
  
  if (el.getAttribute('data-inline')) {
    return maxIdx === 0 ? 0 : 1;
  }
  var l = el.getChildCount();
  if (arguments.length === 1) {
    maxIdx = l;
  }
  maxIdx = Math.min(l, maxIdx);
  for (var i=0, child = el.getFirstChild(); i < maxIdx; child = child.getNextSibling(), i++) {
    if (child.isTextNode()) {
      charPos += child.getTextContent().length;
    } else if (child.isElementNode()) {
      var length = child.getAttribute('data-length');
      if (child.getAttribute('data-inline')) {
        charPos += 1;
      } else if (length) {
        charPos += parseInt(length, 10);
      } else {
        charPos += _countCharacters(child);
      }
    }
  }
  return charPos
}

var BRACKET = 'X';


var IsolatedNodeComponent = (function (AbstractIsolatedNodeComponent$$1) {
  function IsolatedNodeComponent() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    AbstractIsolatedNodeComponent$$1.apply(this, args);
  }

  if ( AbstractIsolatedNodeComponent$$1 ) IsolatedNodeComponent.__proto__ = AbstractIsolatedNodeComponent$$1;
  IsolatedNodeComponent.prototype = Object.create( AbstractIsolatedNodeComponent$$1 && AbstractIsolatedNodeComponent$$1.prototype );
  IsolatedNodeComponent.prototype.constructor = IsolatedNodeComponent;

  IsolatedNodeComponent.prototype.render = function render ($$) {
    var node = this.props.node;
    var ContentClass = this.ContentClass;
    var disabled = this.props.disabled;

    
    var el = $$('div');
    el.addClass(this.getClassNames())
      .addClass('sc-isolated-node')
      .addClass('sm-'+this.props.node.type)
      .attr("data-id", node.id);
    if (disabled) {
      el.addClass('sm-disabled');
    }
    if (this.state.mode) {
      el.addClass('sm-'+this.state.mode);
    }
    if (!ContentClass.noStyle) {
      el.addClass('sm-default-style');
    }
    
    el.on('keydown', this.onKeydown);

    
    var shouldRenderBlocker = (
      this.blockingMode === 'closed' &&
      !this.state.unblocked
    );

    
    
    el.append(
      $$('div').addClass('se-bracket sm-left').ref('left')
        .append(BRACKET)
    );

    var content = this.renderContent($$, node, {
      disabled: this.props.disabled || shouldRenderBlocker
    }).ref('content');
    content.attr('contenteditable', false);

    el.append(content);
    el.append($$(Blocker).ref('blocker'));
    el.append(
      $$('div').addClass('se-bracket sm-right').ref('right')
        .append(BRACKET)
    );

    if (!shouldRenderBlocker) {
      el.addClass('sm-no-blocker');
      el.on('click', this.onClick)
        .on('dblclick', this.onDblClick);
    }
    el.on('mousedown', this._reserveMousedown, this);

    return el
  };

  IsolatedNodeComponent.prototype.getClassNames = function getClassNames () {
    return ''
  };

  IsolatedNodeComponent.prototype.getContent = function getContent () {
    return this.refs.content
  };

  IsolatedNodeComponent.prototype.selectNode = function selectNode () {
    
    var editorSession = this.context.editorSession;
    var surface = this.context.surface;
    var nodeId = this.props.node.id;
    editorSession.setSelection({
      type: 'node',
      nodeId: nodeId,
      containerId: surface.getContainerId(),
      surfaceId: surface.id
    });
  };

  
  
  IsolatedNodeComponent.prototype.onClick = function onClick (event) {
    
    event.stopPropagation();
  };

  IsolatedNodeComponent.prototype.onDblClick = function onDblClick (event) {
    
    event.stopPropagation();
  };

  IsolatedNodeComponent.prototype.grabFocus = function grabFocus (event) {
    var content = this.refs.content;
    if (content.grabFocus) {
      content.grabFocus(event);
      return true
    }
  };

  
  
  IsolatedNodeComponent.prototype._reserveMousedown = function _reserveMousedown (event) {
    if (event.__reserved__) {
      
      return
    } else {
      
      event.__reserved__ = this;
    }
  };

  IsolatedNodeComponent.prototype._deriveStateFromSelectionState = function _deriveStateFromSelectionState (selState) {
    var surface = this._getSurface(selState);
    var newState = { mode: null, unblocked: null};
    if (!surface) { return newState }
    
    if (surface === this.context.surface) {
      var sel = selState.getSelection();
      var nodeId = this.props.node.id;
      if (sel.isNodeSelection() && sel.getNodeId() === nodeId) {
        if (sel.isFull()) {
          newState.mode = 'selected';
          newState.unblocked = true;
        } else if (sel.isBefore()) {
          newState.mode = 'cursor';
          newState.position = 'before';
        } else if (sel.isAfter()) {
          newState.mode = 'cursor';
          newState.position = 'after';
        }
      }
      if (sel.isContainerSelection() && sel.containsNode(nodeId)) {
        newState.mode = 'co-selected';
      }
    } else {
      var isolatedNodeComponent = surface.context.isolatedNodeComponent;
      if (isolatedNodeComponent) {
        if (isolatedNodeComponent === this) {
          newState.mode = 'focused';
          newState.unblocked = true;
        } else {
          var isolatedNodes = this._getIsolatedNodes(selState);
          if (isolatedNodes.indexOf(this) > -1) {
            newState.mode = 'co-focused';
            newState.unblocked = true;
          }
        }
      }
    }
    return newState
  };

  return IsolatedNodeComponent;
}(AbstractIsolatedNodeComponent));

IsolatedNodeComponent.prototype._isIsolatedNodeComponent = true;

IsolatedNodeComponent.prototype._isDisabled = IsolatedNodeComponent.prototype.isDisabled;

IsolatedNodeComponent.getDOMCoordinate = function(comp, coor) {
  var ref = IsolatedNodeComponent.getDOMCoordinates(comp);
  var start = ref.start;
  var end = ref.end;
  if (coor.offset === 0) { return start }
  else { return end }
};

IsolatedNodeComponent.getDOMCoordinates = function(comp) {
  var left = comp.refs.left;
  var right = comp.refs.right;
  return {
    start: {
      container: left.getNativeElement(),
      offset: 0
    },
    end: {
      container: right.getNativeElement(),
      offset: right.getChildCount()
    }
  }
};

IsolatedNodeComponent.getCoordinate = function(nodeEl, options) {
  var comp = Component.unwrap(nodeEl, 'strict').context.isolatedNodeComponent;
  var offset = null;
  if (options.direction === 'left' || nodeEl === comp.refs.left.el) {
    offset = 0;
  } else if (options.direction === 'right' || nodeEl === comp.refs.right.el) {
    offset = 1;
  }
  var coor;
  if (offset !== null) {
    coor = new Coordinate([comp.props.node.id], offset);
    coor._comp = comp;
  }
  return coor
};

var Blocker = (function (Component$$1) {
  function Blocker () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Blocker.__proto__ = Component$$1;
  Blocker.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Blocker.prototype.constructor = Blocker;

  Blocker.prototype.render = function render ($$) {
    return $$('div').addClass('sc-isolated-node-blocker')
      .attr('draggable', true)
      .attr('contenteditable', false)
      .on('click', this.onClick)
      .on('dblclick', this.onDblClick)
  };

  Blocker.prototype.onClick = function onClick (event) {
    if (event.target !== this.getNativeElement()) { return }
    
    event.stopPropagation();
    var comp = this._getIsolatedNodeComponent();
    comp.extendState({ mode: 'selected', unblocked: true });
    comp.selectNode();
  };

  Blocker.prototype.onDblClick = function onDblClick (event) {
    
    event.stopPropagation();
  };

  Blocker.prototype._getIsolatedNodeComponent = function _getIsolatedNodeComponent () {
    return this.context.isolatedNodeComponent
  };

  return Blocker;
}(Component));

var DEBUG$1 = false;


var DOMSelection = function DOMSelection(editor) {
  this.editor = editor;
  if (platform.inBrowser) {
    this.wRange = window.document.createRange();
  }
  
  
  this.state = { dom: null, model: null };
};


DOMSelection.prototype.getSelection = function getSelection (options) {
  
  if (!platform.inBrowser) { return }
  var range = this.mapDOMSelection(options);
  var doc = this.editor.getDocument();
  
  return doc._createSelectionFromRange(range)
};

DOMSelection.prototype.getSelectionForDOMRange = function getSelectionForDOMRange (wrange) {
  var range = this.mapDOMRange(wrange);
  var doc = this.editor.getDocument();
  return doc._createSelectionFromRange(range)
};


DOMSelection.prototype.mapDOMSelection = function mapDOMSelection (options) {
  var wSel = window.getSelection();
  var state = this.state;
  var range;
  
  
  if (DEBUG$1) { console.info('DOM->Model: ', wSel.anchorNode, wSel.anchorOffset, wSel.focusNode, wSel.focusOffset); }
  if (wSel.rangeCount === 0) { return _null() }
  var anchorNode = DefaultDOMElement.wrapNativeElement(wSel.anchorNode);
  if (wSel.isCollapsed) {
    var coor = this._getCoordinate(anchorNode, wSel.anchorOffset, options);
    if (!coor) { return _null() }
    range = _createRange({
      start: coor,
      end: coor
    });
  }
  else {
    var focusNode = DefaultDOMElement.wrapNativeElement(wSel.focusNode);
    range = this._getRange(anchorNode, wSel.anchorOffset, focusNode, wSel.focusOffset, options);
  }
  if (DEBUG$1) { console.info('DOM->Model: range ', range ? range.toString() : null); }
  state.model = range;
  return range

  function _null() {
    state.dom = null;
    state.model = null;
    return null
  }
};


DOMSelection.prototype.setSelection = function setSelection (sel) {
  
  if (!platform.inBrowser) { return }
  var state = this.state;
  var wSel = window.getSelection();
  var wRange = this.wRange;
  if (!sel || sel.isNull()) { return this.clear() }
  
  var ref = this.mapModelToDOMCoordinates(sel);
    var start = ref.start;
    var end = ref.end;
  if (!start) { return this.clear() }
  if (sel.isReverse()) {
    var assign;
      (assign = [end, start], start = assign[0], end = assign[1]);
  }
  state.dom = {
    anchorNode: start.container,
    anchorOffset: start.offset,
    focusNode: end.container,
    focusOffset: end.offset
  };
  _set(state.dom);

  function _set(ref) {
      var anchorNode = ref.anchorNode;
      var anchorOffset = ref.anchorOffset;
      var focusNode = ref.focusNode;
      var focusOffset = ref.focusOffset;

    wSel.removeAllRanges();
    wRange.setStart(anchorNode, anchorOffset);
    wRange.setEnd(anchorNode, anchorOffset);
    wSel.addRange(wRange);
    if (focusNode !== anchorOffset || focusOffset !== anchorOffset) {
      wSel.extend(focusNode, focusOffset);
    }
  }
};

DOMSelection.prototype.mapModelToDOMCoordinates = function mapModelToDOMCoordinates (sel) {
  if (DEBUG$1) { console.info('Model->DOM: sel =', sel.toString()); }
  var rootEl;
  var surface = this.editor.surfaceManager.getSurface(sel.surfaceId);
  if (!surface) {
    console.warn('Selection should have "surfaceId" set.');
    rootEl = this.editor.el;
  } else {
    rootEl = surface.el;
  }
  if (sel.isNull() || sel.isCustomSelection()) {
    return {}
  }

  var start, end;
  if (sel.isPropertySelection() || sel.isContainerSelection()) {
    start = this._getDOMCoordinate(rootEl, sel.start);
    if (!start) {
      console.warn('FIXME: selection seems to be invalid.');
      return {}
    }
    if (sel.isCollapsed()) {
      end = start;
    } else {
      end = this._getDOMCoordinate(rootEl, sel.end);
      if (!end) {
        console.warn('FIXME: selection seems to be invalid.');
        return {}
      }
    }
  } else if (sel.isNodeSelection()) {
    var comp = Component.unwrap(rootEl.find('*[data-id="'+sel.getNodeId()+'"]'));
    if (!comp) {
      console.error('Could not find component with id', sel.getNodeId());
      return {}
    }
    if (comp._isIsolatedNodeComponent) {
      var coors = IsolatedNodeComponent.getDOMCoordinates(comp, sel);
      start = coors.start;
      end = coors.end;
      
      
      
    } else {
      var _nodeEl = comp.el;
      start = {
        container: _nodeEl.getNativeElement(),
        offset: 0
      };
      end = {
        container: _nodeEl.getNativeElement(),
        offset: _nodeEl.getChildCount()
      };
    }
  }
  if (DEBUG$1) { console.info('Model->DOM:', start.container, start.offset, end.container, end.offset, 'isReverse?', sel.isReverse()); }
  return {start: start,end: end}
};

DOMSelection.prototype._getDOMCoordinate = function _getDOMCoordinate (rootEl, coor) {
  var comp, domCoor = null;
  if (coor.isNodeCoordinate()) {
    comp = Component.unwrap(rootEl.find('*[data-id="'+coor.getNodeId()+'"]'));
    if (comp) {
      if (comp._isIsolatedNodeComponent) {
        domCoor = IsolatedNodeComponent.getDOMCoordinate(comp, coor);
      } else {
        var domOffset = 0;
        if (coor.offset > 0) {
          domOffset = comp.getChildCount();
        }
        domCoor = {
          container: comp.getNativeElement(),
          offset: domOffset
        };
      }
    }
  } else {
    comp = Component.unwrap(rootEl.find('.sc-text-property[data-path="'+coor.path.join('.')+'"]'));
    if (comp) {
      domCoor = comp.getDOMCoordinate(coor.offset);
    }
  }
  return domCoor
};


DOMSelection.prototype.mapDOMRange = function mapDOMRange (wRange, options) {
  return this._getRange(
    DefaultDOMElement.wrapNativeElement(wRange.startContainer),
    wRange.startOffset,
    DefaultDOMElement.wrapNativeElement(wRange.endContainer),
    wRange.endOffset, options)
};


DOMSelection.prototype.clear = function clear () {
  window.getSelection().removeAllRanges();
  this.state.dom = null;
  this.state.model = null;
};

DOMSelection.prototype.collapse = function collapse (dir) {
  var wSel = window.getSelection();
  var wRange;
  if (wSel.rangeCount > 0) {
    wRange = wSel.getRangeAt(0);
    wRange.collapse(dir === 'left');
    wSel.removeAllRanges();
    wSel.addRange(wRange);
  }
};

DOMSelection.prototype.select = function select (el) {
  var wSel = window.getSelection();
  var wRange = window.document.createRange();
  wRange.selectNode(el.getNativeElement());
  wSel.removeAllRanges();
  wSel.addRange(wRange);
};

DOMSelection.prototype.extend = function extend$$1 (el, offset) {
  var wSel = window.getSelection();
  wSel.extend(el.getNativeElement(), offset);
};

DOMSelection.prototype.setCursor = function setCursor (el, offset) {
  var wSel = window.getSelection();
  var wRange = window.document.createRange();
  wRange.setStart(el.getNativeElement(), offset);
  wSel.removeAllRanges();
  wSel.addRange(wRange);
};


DOMSelection.prototype._getRange = function _getRange (anchorNode, anchorOffset, focusNode, focusOffset, options) {
    if ( options === void 0 ) options = {};

  var isReverse = DefaultDOMElement.isReverse(anchorNode, anchorOffset, focusNode, focusOffset);
  var isCollapsed = (anchorNode === focusNode && anchorOffset === focusOffset);
  var start, end;
  if (isCollapsed) {
    start = end = this._getCoordinate(anchorNode, anchorOffset, options);
  } else {
    start = this._getCoordinate(anchorNode, anchorOffset, { direction: isReverse ? 'right' : 'left' });
    end = this._getCoordinate(focusNode, focusOffset, options);
  }
  if (start && end) {
    return _createRange({ start: start, end: end, isReverse: isReverse })
  } else {
    return null
  }
};


DOMSelection.prototype._getCoordinate = function _getCoordinate (nodeEl, offset, options) {
    if ( options === void 0 ) options={};

  var coor = null;
  
  if (!coor) {
    coor = TextPropertyComponent.getCoordinate(this.editor.el, nodeEl, offset);
  }
  var comp = Component.unwrap(nodeEl);
  if (!coor && comp) {
    
    if (comp.context.isolatedNodeComponent) {
      coor = IsolatedNodeComponent.getCoordinate(nodeEl, options);
    }
  }
  
  
  if (!coor) {
    
    if (comp && comp._isContainerEditor) {
      var childIdx = (offset === 0) ? 0 : offset-1;
      var isBefore = (offset === 0);
      var container = comp.getContainer();
      var childNode = container.getNodeAt(childIdx);
      var childComp = comp.getChildAt(childIdx);
      coor = new Coordinate([childNode.id], isBefore?0:1 );
      coor._comp = childComp;
    }
    
    else if (nodeEl.isElementNode() && nodeEl.getChildCount() > 0) {
      var child = (offset > 0) ? nodeEl.getChildAt(offset-1) : nodeEl.firstChild;
      var prop;
      var childComp$1 = Component.unwrap(child);
      if (childComp$1 && childComp$1._isTextPropertyComponent) {
        prop = child;
      }
      
      if (prop) {
        coor = TextPropertyComponent.getCoordinate(nodeEl, prop, (offset > 0) ? prop.getChildCount() : 0);
      }
    }
  }
  return coor
};


function _createRange(ref) {
  var start = ref.start;
  var end = ref.end;
  var isReverse = ref.isReverse;

  if (isReverse) {
    var assign;
    (assign = [end, start], start = assign[0], end = assign[1]);
  }
  if (!start._comp || !end._comp) {
    console.error('FIXME: getCoordinate() should provide a component instance');
    return null
  }
  var surface = start._comp.context.surface;
  if (!surface) {
    console.error('FIXME: Editable components should have their surface in the context');
    return null
  }
  if (surface !== end._comp.context.surface) {
    console.error('Coordinates are within two different surfaces. Can not create a selection.');
    return null
  }
  return new Range(start, end, isReverse, surface.getContainerId(), surface.id)
}

var AbstractEditor = (function (Component$$1) {
  function AbstractEditor() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Component$$1.apply(this, args);
    this._initialize(this.props);
  }

  if ( Component$$1 ) AbstractEditor.__proto__ = Component$$1;
  AbstractEditor.prototype = Object.create( Component$$1 && Component$$1.prototype );
  AbstractEditor.prototype.constructor = AbstractEditor;

  AbstractEditor.prototype._initialize = function _initialize (props) {
    if (!props.editorSession) {
      throw new Error('EditorSession instance required');
    }
    this.editorSession = props.editorSession;
    this.doc = this.editorSession.getDocument();

    var configurator = this.editorSession.getConfigurator();
    this.componentRegistry = configurator.getComponentRegistry();
    this.toolGroups = configurator.getToolGroups();
    this.labelProvider = configurator.getLabelProvider();
    this.iconProvider = configurator.getIconProvider();

    
    this.surfaceManager = this.editorSession.surfaceManager;
    this.commandManager = this.editorSession.commandManager;
    this.dragManager = this.editorSession.dragManager;
    this.macroManager = this.editorSession.macroManager;
    this.converterRegistry = this.editorSession.converterRegistry;
    this.globalEventHandler = this.editorSession.globalEventHandler;
    this.editingBehavior = this.editorSession.editingBehavior;
    this.markersManager = this.editorSession.markersManager;

    this.resourceManager = new ResourceManager(this.editorSession, this.getChildContext());

    this.domSelection = new DOMSelection(this);
  };

  AbstractEditor.prototype.willReceiveProps = function willReceiveProps (nextProps) {
    var newSession = nextProps.editorSession;
    var shouldDispose = newSession && newSession !== this.editorSession;
    if (shouldDispose) {
      this._dispose();
      this._initialize(nextProps);
    }
  };

  AbstractEditor.prototype.dispose = function dispose () {
    this._dispose();
  };

  AbstractEditor.prototype._dispose = function _dispose () {
    
    
    this.empty();
    
    
    this.resourceManager.dispose();
  };

  AbstractEditor.prototype.getChildContext = function getChildContext () {
    return {
      editor: this,
      editorSession: this.editorSession,
      doc: this.doc, 
      componentRegistry: this.componentRegistry,
      surfaceManager: this.surfaceManager,
      domSelection: this.domSelection,
      commandManager: this.commandManager,
      markersManager: this.markersManager,
      converterRegistry: this.converterRegistry,
      dragManager: this.dragManager,
      editingBehavior: this.editingBehavior,
      globalEventHandler: this.globalEventHandler,
      iconProvider: this.iconProvider,
      labelProvider: this.labelProvider,
      resourceManager: this.resourceManager,
      
      
      toolGroups: this.toolGroups,
    }
  };

  AbstractEditor.prototype.getDocument = function getDocument () {
    return this.editorSession.getDocument()
  };

  AbstractEditor.prototype.getConfigurator = function getConfigurator () {
    return this.editorSession.getConfigurator()
  };

  AbstractEditor.prototype.getEditorSession = function getEditorSession () {
    return this.editorSession
  };

  AbstractEditor.prototype.getComponentRegistry = function getComponentRegistry () {
    return this.componentRegistry
  };

  return AbstractEditor;
}(Component));

var AbstractScrollPane$$1 = (function (Component$$1) {
  function AbstractScrollPane$$1 () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) AbstractScrollPane$$1.__proto__ = Component$$1;
  AbstractScrollPane$$1.prototype = Object.create( Component$$1 && Component$$1.prototype );
  AbstractScrollPane$$1.prototype.constructor = AbstractScrollPane$$1;

  AbstractScrollPane$$1.prototype.getChildContext = function getChildContext () {
    return {
      scrollPane: this
    }
  };

  AbstractScrollPane$$1.prototype.didMount = function didMount () {
    if (platform.inBrowser) {
      this.windowEl = DefaultDOMElement.wrapNativeElement(window);
      this.windowEl.on('resize', this.onSelectionPositioned, this);
    }
  };

  AbstractScrollPane$$1.prototype.dispose = function dispose () {
    if (this.windowEl) {
      this.windowEl.off(this);
    }
  };

  AbstractScrollPane$$1.prototype.getName = function getName () {
    return this.props.name
  };

  
  AbstractScrollPane$$1.prototype.onSelectionPositioned = function onSelectionPositioned () {
    var contentRect = this._getContentRect();
    var selectionRect = this._getSelectionRect();
    if (!selectionRect) { return }
    var hints = {
      contentRect: contentRect,
      selectionRect: selectionRect
    };
    this._emitSelectionPositioned(hints);
    this._scrollSelectionIntoView(selectionRect);
  };

  AbstractScrollPane$$1.prototype._emitSelectionPositioned = function _emitSelectionPositioned (hints) {
    
    
    this.emit('selection:positioned', hints);
    
    this.emit('dom-selection:rendered', hints);
  };

  
  AbstractScrollPane$$1.prototype._onContextMenu = function _onContextMenu (e) {
    e.preventDefault();
    var mouseBounds = this._getMouseBounds(e);
    this.emit('context-menu:opened', {
      mouseBounds: mouseBounds
    });
  };

  AbstractScrollPane$$1.prototype._scrollSelectionIntoView = function _scrollSelectionIntoView (selectionRect) {
    var upperBound = this.getScrollPosition();
    var lowerBound = upperBound + this.getHeight();
    var selTop = selectionRect.top;
    var selBottom = selectionRect.top + selectionRect.height;
    if ((selTop < upperBound && selBottom < upperBound) ||
        (selTop > lowerBound && selBottom > lowerBound)) {
      this.setScrollPosition(selTop);
    }
  };

  
  AbstractScrollPane$$1.prototype.getHeight = function getHeight () {
    throw new Error('Abstract method')
  };

  
  AbstractScrollPane$$1.prototype.getContentHeight = function getContentHeight () {
    throw new Error('Abstract method')
  };

  AbstractScrollPane$$1.prototype.getContentElement = function getContentElement () {
    
    throw new Error('Abstract method')
  };

  
  
  
  AbstractScrollPane$$1.prototype.getScrollableElement = function getScrollableElement () {
    throw new Error('Abstract method')
  };

  
  AbstractScrollPane$$1.prototype.getScrollPosition = function getScrollPosition () {
    throw new Error('Abstract method')
  };

  AbstractScrollPane$$1.prototype.setScrollPosition = function setScrollPosition () {
    throw new Error('Abstract method')
  };

  
  AbstractScrollPane$$1.prototype.getPanelOffsetForElement = function getPanelOffsetForElement (el) { 
    throw new Error('Abstract method')
  };

  
  AbstractScrollPane$$1.prototype.scrollTo = function scrollTo (componentId, onlyIfNotVisible) { 
    throw new Error('Abstract method')
  };

  AbstractScrollPane$$1.prototype._getContentRect = function _getContentRect () {
    return this.getContentElement().getNativeElement().getBoundingClientRect()
  };

  
  AbstractScrollPane$$1.prototype._getSelectionRect = function _getSelectionRect () {
    return getSelectionRect(this._getContentRect())
  };

  AbstractScrollPane$$1.prototype._getMouseBounds = function _getMouseBounds (e) {
    return getRelativeMouseBounds(e, this.getContentElement().getNativeElement())
  };

  return AbstractScrollPane$$1;
}(Component));

var Command = function Command(config) {
  this.config = config || {};
  this.name = this.config.name;
  if (!this.name) {
    throw new Error("'name' is required");
  }
};

var prototypeAccessors$7 = { isAsync: {} };

prototypeAccessors$7.isAsync.get = function () {
  return false
};


Command.prototype.getName = function getName () {
  return this.name
};


Command.prototype.getCommandState = function getCommandState (params, context) { 
  throw new Error('Command.getCommandState() is abstract.')
};


Command.prototype.execute = function execute (params, context) { 
  throw new Error('Command.execute() is abstract.')
};

Command.prototype._getEditorSession = function _getEditorSession (params, context) {
  var editorSession = params.editorSession || context.editorSession;
  if (!editorSession) {
    throw new Error("'editorSession' is required.")
  }
  return editorSession
};

Command.prototype._getSelection = function _getSelection (params) {
  var sel = params.selection || params.selectionState.getSelection();
  if (!sel) {
    throw new Error("'selection' is required.")
  }
  return sel
};

Object.defineProperties( Command.prototype, prototypeAccessors$7 );

Command.prototype._isCommand = true;

var AnnotationCommand = (function (Command$$1) {
  function AnnotationCommand() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Command$$1.apply(this, args);

    if (!this.config.nodeType) {
      throw new Error("'nodeType' is required")
    }
  }

  if ( Command$$1 ) AnnotationCommand.__proto__ = Command$$1;
  AnnotationCommand.prototype = Object.create( Command$$1 && Command$$1.prototype );
  AnnotationCommand.prototype.constructor = AnnotationCommand;

  
  AnnotationCommand.prototype.getAnnotationType = function getAnnotationType () {
    return this.config.nodeType
  };

  
  AnnotationCommand.prototype.getAnnotationData = function getAnnotationData () {
    return {}
  };

  
  AnnotationCommand.prototype.isDisabled = function isDisabled (sel, params) {
    var selectionState = params.selectionState;
    
    
    if (!sel || sel.isNull() || !sel.isAttached() || sel.isCustomSelection()||
        sel.isNodeSelection() || sel.isContainerSelection() || selectionState.isInlineNodeSelection()) {
      return true
    }

    if (this.config.disableCollapsedCursor && sel.isCollapsed()) {
      return true
    }

    return false
  };

  
  
  AnnotationCommand.prototype.canCreate = function canCreate (annos, sel) {
    return (annos.length === 0 && !sel.isCollapsed())
  };

  
  AnnotationCommand.prototype.canFuse = function canFuse (annos, sel) {
    
    return (annos.length >= 2 && !sel.isCollapsed())
  };

  
  AnnotationCommand.prototype.canDelete = function canDelete (annos, sel) {
    
    if (annos.length !== 1) { return false }
    var annoSel = annos[0].getSelection();
    return sel.isInsideOf(annoSel)
  };

  
  AnnotationCommand.prototype.canExpand = function canExpand (annos, sel) {
    
    if (annos.length !== 1) { return false }
    var annoSel = annos[0].getSelection();
    return sel.overlaps(annoSel) && !sel.isInsideOf(annoSel)
  };

  
  AnnotationCommand.prototype.canTruncate = function canTruncate (annos, sel) {
    if (annos.length !== 1) { return false }
    var annoSel = annos[0].getSelection();

    return (sel.isLeftAlignedWith(annoSel) || sel.isRightAlignedWith(annoSel)) &&
           !sel.contains(annoSel) &&
           !sel.isCollapsed()
  };

  
  AnnotationCommand.prototype.getCommandState = function getCommandState (params) { 

    var sel = this._getSelection(params);
    
    
    
    if (this.isDisabled(sel, params)) {
      return {
        disabled: true
      }
    }
    var annos = this._getAnnotationsForSelection(params);
    var newState = {
      disabled: false,
      active: false,
      mode: null
    };
    if (this.canCreate(annos, sel)) {
      newState.mode = 'create';
    } else if (this.canFuse(annos, sel)) {
      newState.mode = 'fuse';
    } else if (this.canTruncate(annos, sel)) {
      newState.active = true;
      newState.mode = 'truncate';
    } else if (this.canExpand(annos, sel)) {
      newState.mode = 'expand';
    } else if (this.canDelete(annos, sel)) {
      newState.active = true;
      newState.mode = 'delete';
    } else {
      newState.disabled = true;
    }
    return newState
  };

  
  
  AnnotationCommand.prototype.execute = function execute (params) {
    
    
    
    var commandState = params.commandState;

    if (commandState.disabled) { return false }
    switch(commandState.mode) {
      case 'create':
        return this.executeCreate(params)
      case 'fuse':
        return this.executeFuse(params)
      case 'truncate':
        return this.executeTruncate(params)
      case 'expand':
        return this.executeExpand(params)
      case 'delete':
        return this.executeDelete(params)
      default:
        console.warn('Command.execute(): unknown mode', commandState.mode);
        return false
    }
  };

  AnnotationCommand.prototype.executeCreate = function executeCreate (params) {
    var annos = this._getAnnotationsForSelection(params);
    this._checkPrecondition(params, annos, this.canCreate);
    var editorSession = this._getEditorSession(params);
    var annoData = this.getAnnotationData();
    annoData.type = this.getAnnotationType();
    var anno;
    editorSession.transaction(function (tx) {
      anno = tx.annotate(annoData);
    });
    return {
      mode: 'create',
      anno: anno
    }
  };

  AnnotationCommand.prototype.executeFuse = function executeFuse (params) {
    var annos = this._getAnnotationsForSelection(params);
    this._checkPrecondition(params, annos, this.canFuse);
    this._applyTransform(params, function(tx) {
      annotationHelpers.fuseAnnotation(tx, annos);
    });
    return {
      mode: 'fuse',
      anno: annos[0]
    }
  };

  AnnotationCommand.prototype.executeTruncate = function executeTruncate (params) {
    var annos = this._getAnnotationsForSelection(params);
    var anno = annos[0];
    this._checkPrecondition(params, annos, this.canTruncate);
    this._applyTransform(params, function(tx) {
      annotationHelpers.truncateAnnotation(tx, anno, params.selection);
    });
    return {
      mode: 'truncate',
      anno: anno
    }
  };

  AnnotationCommand.prototype.executeExpand = function executeExpand (params) {
    var annos = this._getAnnotationsForSelection(params);
    var anno = annos[0];
    this._checkPrecondition(params, annos, this.canExpand);
    this._applyTransform(params, function(tx) {
      annotationHelpers.expandAnnotation(tx, anno, params.selection);
    });
    return {
      mode: 'expand',
      anno: anno
    }
  };

  AnnotationCommand.prototype.executeDelete = function executeDelete (params) {
    var annos = this._getAnnotationsForSelection(params);
    var anno = annos[0];
    this._checkPrecondition(params, annos, this.canDelete);
    this._applyTransform(params, function(tx) {
      return tx.delete(anno.id)
    });
    return {
      mode: 'delete',
      annoId: anno.id
    }
  };

  AnnotationCommand.prototype._checkPrecondition = function _checkPrecondition (params, annos, checker) {
    var sel = this._getSelection(params);
    if (!checker.call(this, annos, sel)) {
      throw new Error("AnnotationCommand: can't execute command for selection " + sel.toString())
    }
  };

  AnnotationCommand.prototype._getAnnotationsForSelection = function _getAnnotationsForSelection (params) {
    return params.selectionState.getAnnotationsForType(this.getAnnotationType())
  };

  
  AnnotationCommand.prototype._applyTransform = function _applyTransform (params, transformFn) {
    var sel = this._getSelection(params);
    if (sel.isNull()) { return }

    var editorSession = this._getEditorSession(params);
    var result; 
    editorSession.setSelection(sel);
    editorSession.transaction(function(tx) {
      var out = transformFn(tx, params);
      if (out) { result = out.result; }
    });
    return result
  };

  return AnnotationCommand;
}(Command));

var Tool = (function (Component$$1) {
  function Tool () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Tool.__proto__ = Component$$1;
  Tool.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Tool.prototype.constructor = Tool;

  var prototypeAccessors = { _isTool: {} };

  prototypeAccessors._isTool.get = function () {
    return true
  };

  
  Tool.prototype.render = function render ($$) {
    var el = $$('div')
      .addClass('se-tool');

    var customClassNames = this.getClassNames();
    if (customClassNames) {
      el.addClass(customClassNames);
    }

    var title = this.getTitle();
    if (title) {
      el.attr('title', title);
      el.attr('aria-label', title);
    }

    el.append(
      this.renderButton($$)
    );
    return el
  };

  Tool.prototype.renderButton = function renderButton ($$) {
    var Button = this.getComponent('button');
    var btn = $$(Button, {
      icon: this.props.showIcon ? this.props.name : null,
      label: this.props.showLabel ? this.props.name : null,
      hint: this.props.showHint ? this.props.name : null,
      active: this.props.active,
      disabled: this.props.disabled,
      style: this.props.style
    }).on('click', this.onClick);
    return btn
  };

  Tool.prototype.getClassNames = function getClassNames () {
    return ''
  };

  Tool.prototype.getTitle = function getTitle () {
    var labelProvider = this.context.labelProvider;
    var title = this.props.title || labelProvider.getLabel(this.getName());
    
    if (this.props.mode) {
      title = [capitalize(this.props.mode), title].join(' ');
    }
    return title
  };

  
  Tool.prototype.getCommandName = function getCommandName () {
    return this.getName()
  };

  Tool.prototype.getName = function getName () {
    return this.props.name
  };

  Tool.prototype.onClick = function onClick (e) {
    e.preventDefault();
    e.stopPropagation();
    if (!this.props.disabled) { this.executeCommand(); }
  };

  
  Tool.prototype.executeCommand = function executeCommand (props) {
    props = Object.assign({ mode: this.props.mode }, props);
    this.context.commandManager.executeCommand(this.getCommandName(), props);
  };

  Object.defineProperties( Tool.prototype, prototypeAccessors );

  return Tool;
}(Component));

var AnnotationTool = (function (Tool$$1) {
  function AnnotationTool () {
    Tool$$1.apply(this, arguments);
  }

  if ( Tool$$1 ) AnnotationTool.__proto__ = Tool$$1;
  AnnotationTool.prototype = Object.create( Tool$$1 && Tool$$1.prototype );
  AnnotationTool.prototype.constructor = AnnotationTool;

  AnnotationTool.prototype.render = function render ($$) {
    var el = Tool$$1.prototype.render.call(this, $$);
    el.addClass('sm-annotation-tool');
    return el
  };

  AnnotationTool.prototype.renderButton = function renderButton ($$) {
    var el = Tool$$1.prototype.renderButton.call(this, $$);
    el.append(this.renderMode($$));
    return el
  };

  
  AnnotationTool.prototype.renderMode = function renderMode ($$) {
    var mode = this.props.mode;
    var el = $$('div').addClass('se-mode');

    var iconEl = this.context.iconProvider.renderIcon($$, mode);
    if (iconEl) {
      el.append(iconEl);
    }
    return el
  };

  return AnnotationTool;
}(Tool));

var NodeComponent = (function (Component$$1) {
  function NodeComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) NodeComponent.__proto__ = Component$$1;
  NodeComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  NodeComponent.prototype.constructor = NodeComponent;

  NodeComponent.prototype.render = function render ($$) {
    var tagName = this.getTagName();
    var el = $$(tagName)
      .attr('data-id', this.props.node.id)
      .addClass(this.getClassNames());
    return el
  };

  NodeComponent.prototype.getTagName = function getTagName () {
    return 'div'
  };

  NodeComponent.prototype.getClassNames = function getClassNames () {
    return ''
  };

  return NodeComponent;
}(Component));

var BlockNodeComponent = (function (NodeComponent$$1) {
  function BlockNodeComponent () {
    NodeComponent$$1.apply(this, arguments);
  }if ( NodeComponent$$1 ) BlockNodeComponent.__proto__ = NodeComponent$$1;
  BlockNodeComponent.prototype = Object.create( NodeComponent$$1 && NodeComponent$$1.prototype );
  BlockNodeComponent.prototype.constructor = BlockNodeComponent;

  

  return BlockNodeComponent;
}(NodeComponent));

var INLINENODES = ['a','b','big','i','small','tt','abbr','acronym','cite','code','dfn','em','kbd','strong','samp','time','var','bdo','br','img','map','object','q','script','span','sub','sup','button','input','label','select','textarea'].reduce(function (m,n){m[n]=true;return m}, {});


var ClipboardImporter = (function (HTMLImporter$$1) {
  function ClipboardImporter(config) {
    HTMLImporter$$1.call(this, _withCatchAllConverter(config));
    
    this.IGNORE_DEFAULT_WARNINGS = true;

    Object.assign(config, {
      trimWhitespaces: true,
      REMOVE_INNER_WS: true
    });

    
    
    this._isWindows = platform.isWindows;
    this.editorOptions = config.editorOptions;
  }

  if ( HTMLImporter$$1 ) ClipboardImporter.__proto__ = HTMLImporter$$1;
  ClipboardImporter.prototype = Object.create( HTMLImporter$$1 && HTMLImporter$$1.prototype );
  ClipboardImporter.prototype.constructor = ClipboardImporter;

  
  ClipboardImporter.prototype.importDocument = function importDocument (html) {
    if (this._isWindows) {
      
      
      var match = /<!--StartFragment-->(.*)<!--EndFragment-->/.exec(html);
      if (match) {
        html = match[1];
      }
    }

    
    
    
    if (html.search(/script id=.substance-clipboard./)>=0) {
      var htmlDoc$1 = DefaultDOMElement.parseHTML(html);
      var substanceData = htmlDoc$1.find('#substance-clipboard');
      if (substanceData) {
        var jsonStr = substanceData.textContent;
        try {
          return this.importFromJSON(jsonStr)
        } finally {
          
        }
      }
    }

    if (this.editorOptions && this.editorOptions['forcePlainTextPaste']) {
      return null;
    }

    var htmlDoc = DefaultDOMElement.parseHTML(html);
    var body = htmlDoc.find('body');
    body = this._sanitizeBody(body);
    if (!body) {
      console.warn('Invalid HTML.');
      return null
    }
    this._wrapIntoParagraph(body);
    this.reset();
    this.convertBody(body);
    var doc = this.state.doc;
    return doc
  };

  ClipboardImporter.prototype._sanitizeBody = function _sanitizeBody (body) {
    body = this._fixupGoogleDocsBody(body);
    
    body.findAll('meta').forEach(function (el) { return el.remove(); });
    return body
  };

  ClipboardImporter.prototype._fixupGoogleDocsBody = function _fixupGoogleDocsBody (body) {
    if (!body) { return }
    
    
    
    
    var bold = body.find('b');
    if (bold && /^docs-internal/.exec(bold.id)) {
      return bold
    }
    return body
  };

  ClipboardImporter.prototype._wrapIntoParagraph = function _wrapIntoParagraph (body) {
    var childNodes = body.getChildNodes();
    var shouldWrap = false;
    for (var i = 0; i < childNodes.length; i++) {
      var c = childNodes[i];
      if (c.isTextNode()) {
        if (!(/^\s+$/.exec(c.textContent))) {
          shouldWrap = true;
          break
        }
      } else if (INLINENODES[c.tagName]) {
        shouldWrap = true;
        break
      }
    }
    if (shouldWrap) {
      var p = body.createElement('p');
      p.append(childNodes);
      body.append(p);
    }
  };

  ClipboardImporter.prototype.importFromJSON = function importFromJSON (jsonStr) {
    this.reset();
    var doc = this.getDocument();
    var jsonData = JSON.parse(jsonStr);
    var converter = new JSONConverter();
    converter.importDocument(doc, jsonData);
    return doc
  };

  
  ClipboardImporter.prototype.convertBody = function convertBody (body) {
    this.convertContainer(body.childNodes, Document.SNIPPET_ID);
  };

  
  ClipboardImporter.prototype._createDocument = function _createDocument () {
    var emptyDoc = HTMLImporter$$1.prototype._createDocument.call(this);
    return emptyDoc.createSnippet()
  };

  return ClipboardImporter;
}(HTMLImporter));

function _withCatchAllConverter(config) {
  var defaultTextType = config.schema.getDefaultTextType();
  config.converters = config.converters.concat([{
    type: defaultTextType,
    matchElement: function(el) { return el.is('div') },
    import: function(el, node, converter) {
      node.content = converter.annotatedText(el, [node.id, 'content']);
    }
  }]);
  return config
}

var ClipboardExporter = (function (HTMLExporter$$1) {
  function ClipboardExporter () {
    HTMLExporter$$1.apply(this, arguments);
  }

  if ( HTMLExporter$$1 ) ClipboardExporter.__proto__ = HTMLExporter$$1;
  ClipboardExporter.prototype = Object.create( HTMLExporter$$1 && HTMLExporter$$1.prototype );
  ClipboardExporter.prototype.constructor = ClipboardExporter;

  ClipboardExporter.prototype.exportDocument = function exportDocument (doc) {
    this.state.doc = doc;
    var html;
    var elements = this.convertDocument(doc);
    
    if (elements.length === 1 && elements[0].attr('data-id') === Document.TEXT_SNIPPET_ID) {
      html = elements[0].innerHTML;
    } else {
      html = elements.map(function(el) {
        return el.outerHTML
      }).join('');
    }
    var jsonConverter = new JSONConverter();
    var jsonStr = JSON.stringify(jsonConverter.exportDocument(doc));
    var substanceContent = "<script id=\"substance-clipboard\" type=\"application/json\">" + jsonStr + "</script>";
    return '<html><head>' +substanceContent+ '</head><body>' + html + '</body></html>'
  };

  
  ClipboardExporter.prototype.convertDocument = function convertDocument (doc) {
    var content = doc.get(Document.SNIPPET_ID);
    if (!content) {
      throw new Error('Illegal clipboard document: could not find container "' + Document.SNIPPET_ID + '"')
    }
    return this.convertContainer(content)
  };

  return ClipboardExporter;
}(HTMLExporter));

var Clipboard = function Clipboard(editorSession, config) {
  this.editorSession = editorSession;
  var doc = editorSession.getDocument();
  var schema = doc.getSchema();

  var htmlConverters = [];
  if (config.converterRegistry) {
    htmlConverters = config.converterRegistry.get('html').values() || [];
  }
  var _config = {
    schema: schema,
    DocumentClass: doc.constructor,
    converters: htmlConverters,
    editorOptions: config.editorOptions
  };

  this.htmlImporter = new ClipboardImporter(_config);
  this.htmlExporter = new ClipboardExporter(_config);
};

Clipboard.prototype.dispose = function dispose () {
  this.htmlImporter.dispose();
  
  
};

Clipboard.prototype.getEditorSession = function getEditorSession () {
  return this.editorSession
};


Clipboard.prototype.attach = function attach (el) {
  el.on('copy', this.onCopy, this);
  el.on('cut', this.onCut, this);
  el.on('paste', this.onPaste, this);
};


Clipboard.prototype.detach = function detach (el) {
  el.off(this);
};


Clipboard.prototype.onCopy = function onCopy (event) {
  
  var clipboardData = this._copy();
  substanceGlobals._clipboardData = event.clipboardData;

  if (event.clipboardData && clipboardData.doc) {
    event.preventDefault();
    
    event.clipboardData.setData('text/plain', clipboardData.text);
    
    if (!platform.isIE && !platform.isEdge) {
      event.clipboardData.setData('text/html', clipboardData.html);
    }
  }
};


Clipboard.prototype.onCut = function onCut (event) {
  
  
  event.preventDefault();
  
  this.onCopy(event);
  var editorSession = this.getEditorSession();
  editorSession.transaction(function (tx){
    tx.deleteSelection();
  });
};



Clipboard.prototype.onPaste = function onPaste (event) {
  var clipboardData = event.clipboardData;

  var types = {};
  for (var i = 0; i < clipboardData.types.length; i++) {
    types[clipboardData.types[i]] = true;
  }
  

  event.preventDefault();
  event.stopPropagation();

  var plainText;
  var html;
  if (types['text/plain']) {
    plainText = clipboardData.getData('text/plain');
  }
  if (types['text/html']) {
    html = clipboardData.getData('text/html');
  }

  
  
  if (platform.isEdge &&
      substanceGlobals.clipboardData &&
      substanceGlobals.clipboardData.text === plainText) {
    html = substanceGlobals.clipboardData.html;
  } else {
    substanceGlobals.clipboardData = {
      text: plainText,
      html: html
    };
  }

  

  
  
  if (platform.isFF && !html) {
    this._pastePlainText(plainText);
    return
  }

  
  
  if (html) {
    if (!this._pasteHtml(html, plainText)) {
      this._pastePlainText(plainText);
    }
  } else {
    this._pastePlainText(plainText);
  }
};


Clipboard.prototype._pastePlainText = function _pastePlainText (plainText) {
  var editorSession = this.getEditorSession();
  editorSession.transaction(function(tx) {
    tx.paste(plainText);
  }, { action: 'paste' });
};


Clipboard.prototype._copy = function _copy () {
  var editorSession = this.getEditorSession();
  var sel = editorSession.getSelection();
  var doc = editorSession.getDocument();
  var clipboardDoc = null;
  var clipboardText = "";
  var clipboardHtml = "";
  if (!sel.isCollapsed()) {
    clipboardText = documentHelpers.getTextForSelection(doc, sel) || "";
    clipboardDoc = copySelection(doc, sel);
    clipboardHtml = this.htmlExporter.exportDocument(clipboardDoc);
  }
  return {
    doc: clipboardDoc,
    html: clipboardHtml,
    text: clipboardText
  }
};


Clipboard.prototype._pasteHtml = function _pasteHtml (html, text) {
  var content = this.htmlImporter.importDocument(html);
  this.paste(content, text);
  return true
};


Clipboard.prototype.paste = function paste$$1 (doc, text) {
  var content = doc || text;
  var editorSession = this.getEditorSession();
  if (content) {
    editorSession.transaction(function (tx) {
      tx.paste(content);
    }, { action: 'paste' });
  }
};

var CommandManager = function CommandManager(context, commands) {
  if (!context.editorSession) {
    throw new Error('EditorSession required.')
  }

  this.editorSession = context.editorSession;
  this.doc = this.editorSession.getDocument();
  this.context = Object.assign({}, context, {
    
    doc: this.doc
  });
  
  this.commandRegistry = new Registry();
  forEach(commands, function(command) {
    if(!command._isCommand) {
      throw new Error("Expecting instances of ui/Command.")
    }
    this.commandRegistry.add(command.name, command);
  }.bind(this));

  this.editorSession.onUpdate(this.onSessionUpdate, this);
  this.updateCommandStates(this.editorSession);
};

CommandManager.prototype.dispose = function dispose () {
  this.editorSession.off(this);
};

CommandManager.prototype.onSessionUpdate = function onSessionUpdate (editorSession) {
  if (editorSession.hasChanged('change') || editorSession.hasChanged('selection')) {
    this.updateCommandStates(editorSession);
  }
};


CommandManager.prototype.updateCommandStates = function updateCommandStates (editorSession) {
  var commandContext = this.getCommandContext();
  var params = this._getCommandParams();
  var surface = params.surface;
  var commandRegistry = this.commandRegistry;

  
  
  
  
  
  
  var commandNames = commandRegistry.names.slice();
  if (surface) {
    var included = surface.props.commands;
    var excluded = surface.props.excludedCommands;
    if (included) {
      commandNames = included;
    } else if (excluded) {
      excluded = excluded.slice(0);
      for (var i = commandNames.length - 1; i >= 0; i--) {
        var idx = excluded.indexOf(commandNames[i]);
        if (idx >= 0) {
          excluded.splice(idx, 1);
          commandNames.splice(i, 1);
        }
      }
    }
  }
  var commands = commandNames.map(function (name) { return commandRegistry.get(name); });
  var commandStates = {};
  commands.forEach(function (cmd) {
    if (cmd) {
      commandStates[cmd.getName()] = cmd.getCommandState(params, commandContext);
    }
  });
  
  
  
  
  this.commandStates = commandStates;
  editorSession.setCommandStates(commandStates);
};


CommandManager.prototype.executeCommand = function executeCommand (commandName, userParams, cb) {
    var this$1 = this;

  var cmd = this.commandRegistry.get(commandName);
  if (!cmd) {
    console.warn('command', commandName, 'not registered');
    return
  }
  var commandState = this.commandStates[commandName];
  var params = Object.assign(this._getCommandParams(), userParams, {
    commandState: commandState
  });

  if (cmd.isAsync) {
    
    this.editorSession.lock();
    cmd.execute(params, this.getCommandContext(), function (err, info) {
      if (err) {
        if (cb) {
          cb(err);
        } else {
          console.error(err);
        }
      } else {
        if (cb) { cb(null, info); }
      }
      this$1.editorSession.unlock();
    });
  } else {
    var info = cmd.execute(params, this.getCommandContext());
    return info
  }
};


CommandManager.prototype.getCommandStates = function getCommandStates () {
  return this.commandStates
};

CommandManager.prototype.getCommandContext = function getCommandContext () {
  return this.context
};


CommandManager.prototype._getCommandParams = function _getCommandParams () {
  var editorSession = this.context.editorSession;
  var selectionState = editorSession.getSelectionState();
  var sel = selectionState.getSelection();
  var surface = this.context.surfaceManager.getFocusedSurface();
  return {
    editorSession: editorSession,
    selectionState: selectionState,
    surface: surface,
    selection: sel,
  }
};

var ComponentRegistry = (function (Registry$$1) {
  function ComponentRegistry(entries) {
    Registry$$1.call(this, entries, function(ComponentClass) {
      if (!ComponentClass.prototype._isComponent) {
        throw new Error('Component registry: wrong type. Expected a ComponentClass. Was: ' + String(ComponentClass))
      }
    });
  }

  if ( Registry$$1 ) ComponentRegistry.__proto__ = Registry$$1;
  ComponentRegistry.prototype = Object.create( Registry$$1 && Registry$$1.prototype );
  ComponentRegistry.prototype.constructor = ComponentRegistry;

  return ComponentRegistry;
}(Registry));

var FontAwesomeIcon = (function (Component$$1) {
  function FontAwesomeIcon() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Component$$1.apply(this, args);
  }

  if ( Component$$1 ) FontAwesomeIcon.__proto__ = Component$$1;
  FontAwesomeIcon.prototype = Object.create( Component$$1 && Component$$1.prototype );
  FontAwesomeIcon.prototype.constructor = FontAwesomeIcon;

  FontAwesomeIcon.prototype.render = function render ($$) {
    return $$('i').addClass('fa ' + this.props.icon)
  };

  return FontAwesomeIcon;
}(Component));

var FontAwesomeIconProvider = function FontAwesomeIconProvider(icons) {
  this.faMap = {};
  this.textMap = {};
  forEach(icons, function(config, name) {
    var faClass = config['fontawesome'];
    if (faClass) {
      this.addFAIcon(name, faClass);
    }
    var text = config['text'];
    if (text) {
      this.addTextIcon(name, text);
    }
  }.bind(this));
};

FontAwesomeIconProvider.prototype.renderIcon = function renderIcon ($$, name) {
  var faClass = this.faMap[name];
  var text = this.textMap[name];
  if (faClass) {
    return $$(FontAwesomeIcon, { icon: faClass })
  } else if (text) {
    return text
  }
};

FontAwesomeIconProvider.prototype.addFAIcon = function addFAIcon (name, faClass) {
  this.faMap[name] = faClass;
};

FontAwesomeIconProvider.prototype.addTextIcon = function addTextIcon (name, text) {
  this.textMap[name] = text;
};

var DefaultLabelProvider = function DefaultLabelProvider(labels, lang) {
  this.lang = lang || 'en';
  this.labels = labels;
};

DefaultLabelProvider.prototype.getLabel = function getLabel (name) {
  var labels = this.labels[this.lang];
  if (!labels) { return name }
  return labels[name] || name
};

var ToolGroup = (function (Component$$1) {
  function ToolGroup () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) ToolGroup.__proto__ = Component$$1;
  ToolGroup.prototype = Object.create( Component$$1 && Component$$1.prototype );
  ToolGroup.prototype.constructor = ToolGroup;

  ToolGroup.prototype.render = function render ($$) {
    var this$1 = this;


    var tools = this.props.tools;
    var el = $$('div').addClass('sc-tool-group');
    el.addClass('sm-target-'+this.props.name);
    if (this.props.layout) {
      el.addClass('sm-layout-'+this.props.layout);
    }

    tools.forEach(function (tool) {
      var toolProps = Object.assign({}, tool.toolProps, {
        showIcon: this$1.props.showIcons,
        showLabel: this$1.props.showLabels,
        style: this$1.props.toolStyle
      });

      el.append(
        $$(tool.Class, toolProps).ref(tool.name)
      );
    });
    return el
  };

  return ToolGroup;
}(Component));

var SaveHandlerStub = function SaveHandlerStub () {};

SaveHandlerStub.prototype.saveDocument = function saveDocument (ref) {
    var fileManager = ref.fileManager;

  console.info('Simulating save ...');

  return fileManager.sync()
  .then(function () {
    
    
    console.info('Creating document snapshot...');
  })

};

var Configurator = function Configurator() {
  this.config = {
    schema: {},
    nodes: {},
    components: {},
    converters: {},
    importers: {},
    exporters: {},
    fileProxies: [],
    commands: {},
    tools: new Map(),
    toolGroups: new Map(),
    textTypes: [],
    editingBehaviors: [],
    macros: [],
    dropHandlers: [],
    keyboardShortcuts: [],
    icons: {},
    labels: {},
    lang: 'en_US',
    SaveHandlerClass: null,
    editorOptions: []
  };
};





Configurator.prototype.defineSchema = function defineSchema (schema) {
  if (schema.ArticleClass) {
    console.warn('DEPRECATED: schema.ArticleClass is now called schema.DocumentClass');
    schema.DocumentClass = schema.ArticleClass;
  }
  if (!schema.DocumentClass) {
    throw new Error('schema.DocumentClass is mandatory')
  }
  this.config.schema = schema;
};

Configurator.prototype.addEditorOption = function addEditorOption (option) {
  if (!option.key) {
    throw new Error('An option key must be defined')
  }

  if (!option.value) {
    throw new Error('An option value must be defined')
  }

  this.config.editorOptions[option.key] = option.value;
};

Configurator.prototype.getEditorOptions = function getEditorOptions () {
  return this.config.editorOptions;
};

  
Configurator.prototype.addNode = function addNode (NodeClass) {
  var type = NodeClass.type;
  if (!type) {
    throw new Error('A NodeClass must have a type.')
  }
  if (this.config.nodes[type]) {
    throw new Error('NodeClass with this type name is already registered: ' + type)
  }
  this.config.nodes[type] = NodeClass;
};


Configurator.prototype.addConverter = function addConverter (type, converter) {
  var converters = this.config.converters[type];
  if (!converters) {
    converters = {};
    this.config.converters[type] = converters;
  }
  if (!converter.type) {
    throw new Error('A converter needs an associated type.')
  }
  converters[converter.type] = converter;
};


Configurator.prototype.addImporter = function addImporter (type, ImporterClass) {
  this.config.importers[type] = ImporterClass;
};


Configurator.prototype.addExporter = function addExporter (type, ExporterClass) {
  this.config.exporters[type] = ExporterClass;
};


Configurator.prototype.addComponent = function addComponent (nodeType, ComponentClass, force) {
  if (!force && this.config.components[nodeType]) {
    throw new Error(nodeType+' already registered')
  }
  if (!ComponentClass) {
    throw new Error('Provided nil for component '+nodeType)
  }
  if (!ComponentClass.prototype._isComponent) {
    throw new Error('ComponentClass must be a subclass of ui/Component.')
  }
  this.config.components[nodeType] = ComponentClass;
};

Configurator.prototype.addCommand = function addCommand (name, CommandClass, options) {
  if (!isString$1(name)) {
    throw new Error("Expecting 'name' to be a String")
  }
  if (!CommandClass) {
    throw new Error('Provided nil for command '+name)
  }
  if (!CommandClass.prototype._isCommand) {
    throw new Error("Expecting 'CommandClass' to be of type ui/Command.")
  }
  this.config.commands[name] = {
    name: name,
    CommandClass: CommandClass,
    options: options || {}
  };
};

Configurator.prototype.addToolGroup = function addToolGroup (name, ToolGroupClass, options) {
  options = options || {};
  ToolGroupClass = ToolGroupClass || ToolGroup;

  this.config.toolGroups.set(name, {
    name: name,
    tools: new Map(),
    Class: ToolGroupClass,
    options: options
  });
};

Configurator.prototype.addTool = function addTool (name, ToolClass, options) {
    var this$1 = this;

  options = options || {};

  if (options.target) {
    console.warn('DEPRECATED: please use `toolGroup` instead of `target`', name);
  }
  var toolGroupNames = options.toolGroup || options.target;
  if (isString$1(toolGroupNames)) {
    toolGroupNames = [ toolGroupNames ];
  }

  if (!toolGroupNames && options.overlay) {
    toolGroupNames = [ 'overlay' ];
  } else if (!toolGroupNames) {
    toolGroupNames = [ 'default' ];
  }

  if (!isString$1(name)) {
    throw new Error("Expecting 'name' to be a String")
  }
  if (!ToolClass) {
    throw new Error('Provided nil for tool '+name)
  }
  if (!ToolClass || !ToolClass.prototype._isTool) {
    throw new Error("Expecting 'ToolClass' to be of type ui/Tool. name:")
  }

  toolGroupNames.forEach(function (toolGroupName) {
    var toolGroup = this$1.config.toolGroups.get(toolGroupName);
    if (!toolGroup) {
      console.error(("No toolGroup registered with name: " + toolGroupName));
      return
    }
    toolGroup.tools.set(name, {
      name: name,
      Class: ToolClass,
      options: options || {}
    });
  });
};


Configurator.prototype.addIcon = function addIcon (iconName, options) {
  var iconConfig = this.config.icons[iconName];
  if (!iconConfig) {
    iconConfig = {};
    this.config.icons[iconName] = iconConfig;
  }
  Object.assign(iconConfig, options);
};


Configurator.prototype.addLabel = function addLabel (labelName, label) {
  if (isString$1(label)) {
    if(!this.config.labels['en']) {
      this.config.labels['en'] = {};
    }
    this.config.labels['en'][labelName] = label;
  } else {
    forEach(label, function(label, lang) {
      if (!this.config.labels[lang]) {
        this.config.labels[lang] = {};
      }
      this.config.labels[lang][labelName] = label;
    }.bind(this));
  }
};


Configurator.prototype.addSeed = function addSeed (seed) {
  this.config.seed = seed;
};

Configurator.prototype.addTextType = function addTextType (textType, options) {
  this.config.textTypes.push({
    spec: textType,
    options: options || {}
  });
};


Configurator.prototype.addEditingBehavior = function addEditingBehavior (editingBehavior) {
  this.config.editingBehaviors.push(editingBehavior);
};

Configurator.prototype.addMacro = function addMacro (macro) {
  this.config.macros.push(macro);
};

Configurator.prototype.addDragAndDrop = function addDragAndDrop (DragAndDropHandlerClass) {
  
  
  console.warn('DEPRECATED: Use addDropHandler() instead');
  if (!DragAndDropHandlerClass.prototype._isDragAndDropHandler) {
    throw new Error('Only instances of DragAndDropHandler are allowed.')
  }
  this.addDropHandler(new DragAndDropHandlerClass());
};

Configurator.prototype.addDropHandler = function addDropHandler (dropHandler) {
  
  if (dropHandler._isDragAndDropHandler) {
    dropHandler.type = dropHandler.type || 'drop-asset';
  }
  this.config.dropHandlers.push(dropHandler);
};

Configurator.prototype.addKeyboardShortcut = function addKeyboardShortcut (combo, spec) {
  var entry = {
    key: combo,
    spec: spec
  };
  this.config.keyboardShortcuts.push(entry);
};

Configurator.prototype.addFileProxy = function addFileProxy (FileProxyClass) {
  this.config.fileProxies.push(FileProxyClass);
};

Configurator.prototype.getFileAdapters = function getFileAdapters () {
  return this.config.fileProxies.slice(0)
};


Configurator.prototype.import = function import$1 (pkg, options) {
  pkg.configure(this, options || {});
  return this
};




Configurator.prototype.getConfig = function getConfig () {
  return this.config
};

Configurator.prototype.getStyles = function getStyles () {
  return this.config.styles
};

Configurator.prototype.getSchema = function getSchema () {
  if (!this.schema) {
    this.schema = new DocumentSchema(this.config.schema);
    this.schema.addNodes(this.config.nodes);
  }
  return this.schema
};

Configurator.prototype.getDocumentClass = function getDocumentClass () {
  return this.config.schema.DocumentClass
};

Configurator.prototype.createArticle = function createArticle (seed) {
  var schema = this.getSchema();
  var DocumentClass = schema.getDocumentClass();
  var doc = new DocumentClass(schema);
  if (seed) {
    seed(doc);
  }
  return doc
};

Configurator.prototype.createImporter = function createImporter (type, context, options) {
    if ( options === void 0 ) options = {};

  var ImporterClass = this.config.importers[type];
  var config = Object.assign({
    schema: this.getSchema(),
    converters: this.getConverterRegistry().get(type).values(),
  }, options);
  return new ImporterClass(config, context)
};

Configurator.prototype.createExporter = function createExporter (type, context, options) {
    if ( options === void 0 ) options = {};

  var ExporterClass = this.config.exporters[type];
  var config = Object.assign({
    schema: this.getSchema(),
    converters: this.getConverterRegistry().get(type).values()
  }, options);
  return new ExporterClass(config, context)
};

Configurator.prototype.getToolGroups = function getToolGroups () {
  return this.config.toolGroups
};

Configurator.prototype.getTools = function getTools (toolGroupName) {
  return this.config.toolGroups.get(toolGroupName).tools
};

Configurator.prototype.getComponentRegistry = function getComponentRegistry () {
  var componentRegistry = new ComponentRegistry();
  forEach(this.config.components, function(ComponentClass, name) {
    componentRegistry.add(name, ComponentClass);
  });
  return componentRegistry
};

Configurator.prototype.getCommands = function getCommands () {
  return map(this.config.commands, function(item, name) {
    return new item.CommandClass(Object.assign({name: name}, item.options))
  })
};

Configurator.prototype.getSurfaceCommandNames = function getSurfaceCommandNames () {
  var commands = this.getCommands();
  var commandNames = commands.map(function(C) {
    return C.name
  });
  return commandNames
};


Configurator.prototype.getConverterRegistry = function getConverterRegistry () {
  if (!this.converterRegistry) {
    var converterRegistry = new Registry();
    forEach(this.config.converters, function(converters, name) {
      converterRegistry.add(name, new Registry(converters));
    });
    this.converterRegistry = converterRegistry;
  }
  return this.converterRegistry
};

Configurator.prototype.getDropHandlers = function getDropHandlers () {
  return this.config.dropHandlers.slice(0)
};

Configurator.prototype.getSeed = function getSeed () {
  return this.config.seed
};

Configurator.prototype.getTextTypes = function getTextTypes () {
  return this.config.textTypes.map(function(t) {
    return t.spec
  })
};

Configurator.prototype.getIconProvider = function getIconProvider () {
  return new FontAwesomeIconProvider(this.config.icons)
};

Configurator.prototype.getLabelProvider = function getLabelProvider () {
  return new DefaultLabelProvider(this.config.labels)
};

Configurator.prototype.getEditingBehavior = function getEditingBehavior () {
  var editingBehavior = new EditingBehavior();
  this.config.editingBehaviors.forEach(function(behavior) {
    behavior.register(editingBehavior);
  });
  return editingBehavior
};

Configurator.prototype.getMacros = function getMacros () {
  return this.config.macros
};

Configurator.prototype.getKeyboardShortcuts = function getKeyboardShortcuts () {
  return this.config.keyboardShortcuts
};

Configurator.prototype.setDefaultLanguage = function setDefaultLanguage (lang) {
  this.config.lang = lang;
};

Configurator.prototype.getDefaultLanguage = function getDefaultLanguage () {
  return this.config.lang || 'en_US'
};

Configurator.prototype.setSaveHandlerClass = function setSaveHandlerClass (SaveHandlerClass) {
  this.config.SaveHandlerClass = SaveHandlerClass;
};

Configurator.prototype.getSaveHandler = function getSaveHandler () {
  var SaveHandler = this.config.SaveHandlerClass || SaveHandlerStub;
  return new SaveHandler()
};

var UnsupportedNodeComponent = (function (Component$$1) {
  function UnsupportedNodeComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) UnsupportedNodeComponent.__proto__ = Component$$1;
  UnsupportedNodeComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  UnsupportedNodeComponent.prototype.constructor = UnsupportedNodeComponent;

  UnsupportedNodeComponent.prototype.render = function render ($$) {
    return $$('pre')
      .addClass('content-node unsupported')
      .attr({
        'data-id': this.props.node.id,
        contentEditable: false
      })
      .append(
        JSON.stringify(this.props.node.properties, null, 2)
      )
  };

  return UnsupportedNodeComponent;
}(Component));

var Surface = (function (Component$$1) {
  function Surface() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Component$$1.apply(this, args);

    
    
    this.editorSession = this.props.editorSession || this.context.editorSession;
    if (!this.editorSession) {
      throw new Error('No EditorSession provided')
    }
    this.name = this.props.name;
    if (!this.name) {
      throw new Error('Surface must have a name.')
    }
    if (this.name.indexOf('/') > -1) {
      
      throw new Error("Surface.name must not contain '/'")
    }
    
    
    this._surfaceId = createSurfaceId(this);

    this.clipboard = new Clipboard(this.editorSession, {
      converterRegistry: this.context.converterRegistry,
      editorOptions: this.editorSession.getConfigurator().getEditorOptions()
    });

    this.domSelection = this.context.domSelection;
    if (!this.domSelection) { throw new Error('DOMSelection instance must be provided via context.') }

    this.domObserver = null;

    
    
    if (platform.inBrowser) {
      this.documentEl = DefaultDOMElement.wrapNativeElement(window.document);
    }

    
    this.undoEnabled = true;

    
    this._textProperties = {};

    this._state = {
      
      skipNextFocusEvent: false
    };
  }

  if ( Component$$1 ) Surface.__proto__ = Component$$1;
  Surface.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Surface.prototype.constructor = Surface;

  var prototypeAccessors = { id: {} };

  Surface.prototype.getChildContext = function getChildContext () {
    return {
      surface: this,
      doc: this.getDocument(),
      
      
      isolatedNodeComponent: null
    }
  };

  Surface.prototype.didMount = function didMount () {
    if (this.context.surfaceManager) {
      this.context.surfaceManager.registerSurface(this);
    }
    this.editorSession.onRender('selection', this._onSelectionChanged, this);
  };


  Surface.prototype.dispose = function dispose () {
    this.editorSession.off(this);
    this.clipboard.dispose();
    if (this.domObserver) {
      this.domObserver.disconnect();
    }
    if (this.context.surfaceManager) {
      this.context.surfaceManager.unregisterSurface(this);
    }
  };

  Surface.prototype.didUpdate = function didUpdate () {
    this._updateContentEditableState();
  };

  Surface.prototype.render = function render ($$) {
    var tagName = this.props.tagName || 'div';
    var el = $$(tagName)
      .addClass('sc-surface')
      .attr('tabindex', 2)
      .attr('data-surface-id', this.id);

    if (!this.isDisabled()) {
      if (this.isEditable()) {
        
        el.on('keydown', this.onKeyDown);
        
        if (!platform.isIE) {
          el.on('compositionstart', this.onCompositionStart);
        }
        
        
        
        
        if (platform.inBrowser && window.TextEvent && !platform.isIE) {
          el.on('textInput', this.onTextInput);
        } else {
          el.on('keypress', this.onTextInputShim);
        }
      }
      if (!this.isReadonly()) {
        
        el.on('mousedown', this.onMouseDown);
        el.on('contextmenu', this.onContextMenu);
        
        
        el.on('focus', this.onNativeFocus);
        el.on('blur', this.onNativeBlur);
        
        this.clipboard.attach(el);
      }

    }
    return el
  };

  Surface.prototype.renderNode = function renderNode ($$, node) {
    var doc = this.getDocument();
    var componentRegistry = this.getComponentRegistry();
    var ComponentClass = componentRegistry.get(node.type);
    if (!ComponentClass) {
      console.error('Could not resolve a component for type: ' + node.type);
      ComponentClass = UnsupportedNodeComponent;
    }
    return $$(ComponentClass, {
      doc: doc,
      node: node
    }).ref(node.id)
  };

  Surface.prototype.getComponentRegistry = function getComponentRegistry () {
    return this.context.componentRegistry || this.props.componentRegistry
  };

  Surface.prototype.getName = function getName () {
    return this.name
  };

  Surface.prototype.getId = function getId () {
    return this._surfaceId
  };

  Surface.prototype.isDisabled = function isDisabled () {
    return this.props.disabled
  };

  Surface.prototype.isEditable = function isEditable () {
    return (this.props.editing === "full" || this.props.editing === undefined)
  };

  Surface.prototype.isSelectable = function isSelectable () {
    return (this.props.editing === "selection" || this.props.editing === "full")
  };

  Surface.prototype.isReadonly = function isReadonly () {
    return this.props.editing === "readonly"
  };

  Surface.prototype.getElement = function getElement () {
    return this.el
  };

  Surface.prototype.getDocument = function getDocument () {
    return this.editorSession.getDocument()
  };

  Surface.prototype.getEditorSession = function getEditorSession () {
    return this.editorSession
  };

  Surface.prototype.isEnabled = function isEnabled () {
    return !this.state.disabled
  };

  Surface.prototype.isContainerEditor = function isContainerEditor () {
    return false
  };

  Surface.prototype.hasNativeSpellcheck = function hasNativeSpellcheck () {
    return this.props.spellcheck === 'native'
  };

  Surface.prototype.getContainerId = function getContainerId () {
    return null
  };

  Surface.prototype.blur = function blur () {
    if (this.el) {
      this.el.blur();
    }
  };

  Surface.prototype.focus = function focus () {
    if (this.isDisabled()) { return }
    
    
    
    if (platform.isFF) {
      this.domSelection.clear();
      this.el.getNativeElement().blur();
    }
    this._focus();
  };

  
  Surface.prototype.rerenderDOMSelection = function rerenderDOMSelection () {
    if (this.isDisabled()) { return }
    if (platform.inBrowser) {
      
      var sel = this.editorSession.getSelection();
      if (sel.surfaceId === this.getId()) {
        this.domSelection.setSelection(sel);
        
        
        
        var scrollPane = this.context.scrollPane;
        if (scrollPane) {
          this.context.scrollPane.onSelectionPositioned();
        }
      }
    }
  };

  Surface.prototype.getDomNodeForId = function getDomNodeForId (nodeId) {
    return this.el.getNativeElement().querySelector('*[data-id="'+nodeId+'"]')
  };

  

  
  Surface.prototype.onKeyDown = function onKeyDown (event) {
    if (!this._shouldConsumeEvent(event)) { return }
    

    
    if ( event.key === 'Dead' ) { return }

    
    var custom = this.editorSession.keyboardManager.onKeydown(event);
    if (!custom) {
      
      switch ( event.keyCode ) {
        
        case keys$1.LEFT:
        case keys$1.RIGHT:
          return this._handleLeftOrRightArrowKey(event)
        case keys$1.UP:
        case keys$1.DOWN:
          return this._handleUpOrDownArrowKey(event)
        case keys$1.HOME:
        case keys$1.END:
          return this._handleHomeOrEndKey(event)
        case keys$1.PAGEUP:
        case keys$1.PAGEDOWN:
          return this._handlePageUpOrDownKey(event)
        
        case keys$1.ENTER:
          return this._handleEnterKey(event)
        case keys$1.TAB:
          return this._handleTabKey(event)
        case keys$1.BACKSPACE:
        case keys$1.DELETE:
          return this._handleDeleteKey(event)
        default:
          break
      }
    }
  };

  Surface.prototype.onTextInput = function onTextInput (event) {
    if (!this._shouldConsumeEvent(event)) { return }
    
    event.preventDefault();
    event.stopPropagation();
    if (!event.data) { return }

    var text = event.data;
    if (!this.editorSession.keyboardManager.onTextInput(text)) {
      this.editorSession.transaction(function (tx) {
        tx.insertText(text);
      }, { action: 'type' });
    }
  };

  
  Surface.prototype.onCompositionStart = function onCompositionStart (event) {
    if (!this._shouldConsumeEvent(event)) { return }
  };

  
  Surface.prototype.onTextInputShim = function onTextInputShim (event) {
    if (!this._shouldConsumeEvent(event)) { return }
    
    if (
      
      event.which === 0 || event.charCode === 0 ||
      
      event.keyCode === keys$1.TAB || event.keyCode === keys$1.ESCAPE ||
      
      Boolean(event.metaKey) || (Boolean(event.ctrlKey)^Boolean(event.altKey))
    ) {
      return
    }
    var character = String.fromCharCode(event.which);
    if (!event.shiftKey) {
      character = character.toLowerCase();
    }
    event.preventDefault();
    event.stopPropagation();
    if (!this.editorSession.keyboardManager.onTextInput(character)) {
      if (character.length>0) {
        this.editorSession.transaction(function (tx) {
          tx.insertText(character);
        }, { action: 'type' });
      }
    }
  };

  
  
  
  
  
  Surface.prototype.onMouseDown = function onMouseDown (event) {
    if (!this._shouldConsumeEvent(event)) {
      
      return
    }

    
    
    
    
    
    if (event.__reserved__) {
      
      return
    } else {
      
      event.__reserved__ = this;
    }

    
    
    
    if (this.isEditable()) {
      this.el.setAttribute('contenteditable', true);
    }

    
    if ( event.button !== 0 ) {
      return
    }

    
    if (!(platform.isIE && platform.version<12) && event.detail >= 3) {
      var sel = this.getEditorSession().getSelection();
      if (sel.isPropertySelection()) {
        this._selectProperty(sel.path);
        event.preventDefault();
        event.stopPropagation();
        return
      } else if (sel.isContainerSelection()) {
        this._selectProperty(sel.startPath);
        event.preventDefault();
        event.stopPropagation();
        return
      }
    }
    
    
    
    
    this._state.skipNextFocusEvent = true;

    
    if (this.documentEl) {
      
      this.documentEl.on('mouseup', this.onMouseUp, this, { once: true });
    }
  };

  Surface.prototype.onMouseUp = function onMouseUp (e) {
    
    
    
    
    
    e.stopPropagation();
    
    
    
    
    setTimeout(function() {
      var sel = this.domSelection.getSelection();
      this._setSelection(sel);
    }.bind(this));
  };

  
  
  
  Surface.prototype.onContextMenu = function onContextMenu (event) {
    if (!this._shouldConsumeEvent(event)) { return }
    var sel = this.domSelection.getSelection();
    this._setSelection(sel);
  };

  Surface.prototype.onNativeBlur = function onNativeBlur () {
    
    var _state = this._state;
    _state.hasNativeFocus = false;
  };

  Surface.prototype.onNativeFocus = function onNativeFocus () {
    
    var _state = this._state;
    _state.hasNativeFocus = true;
  };

  


  Surface.prototype._onSelectionChanged = function _onSelectionChanged (selection) {
    var newMode = this._deriveModeFromSelection(selection);
    if (this.state.mode !== newMode) {
      this.extendState({
        mode: newMode
      });
    }
  };

  
  Surface.prototype._deriveModeFromSelection = function _deriveModeFromSelection (sel) {
    if (!sel) { return null }
    var surfaceId = sel.surfaceId;
    var id = this.getId();
    var mode;
    if (startsWith(surfaceId, id)) {
      if (surfaceId.length === id.length) {
        mode = 'focused';
      } else {
        mode = 'co-focused';
      }
    }
    return mode
  };

  Surface.prototype._updateContentEditableState = function _updateContentEditableState () {
    
    
    
    
    
    var enableContenteditable = false;
    if (this.isEditable() && !this.props.disabled) {
      enableContenteditable = true;
      if (this.state.mode === 'co-focused') {
        var selState = this.context.editorSession.getSelectionState();
        var sel = selState.getSelection();
        var surface = this.context.surfaceManager.getSurface(sel.surfaceId);
        if (surface) {
          var isolatedNodeComponent = surface.context.isolatedNodeComponent;
          if (isolatedNodeComponent) {
            enableContenteditable = isolatedNodeComponent.isOpen();
          }
        }
      }
    }
    if (enableContenteditable) {
      this.el.setAttribute('contenteditable', true);
    } else {
      
      this.el.removeAttribute('contenteditable');
    }
  };

  Surface.prototype._focus = function _focus () {
    this._state.hasNativeFocus = true;
    
    
    
    
    if (this.el && !platform.isWebkit) {
      this._state.skipNextFocusEvent = true;
      
      
      this.el.focus();
      this._state.skipNextFocusEvent = false;
    }
  };

  Surface.prototype._handleLeftOrRightArrowKey = function _handleLeftOrRightArrowKey (event) {
    event.stopPropagation();
    var direction = (event.keyCode === keys$1.LEFT) ? 'left' : 'right';
    
    
    window.setTimeout(function() {
      this._updateModelSelection({direction: direction});
    }.bind(this));
  };

  Surface.prototype._handleUpOrDownArrowKey = function _handleUpOrDownArrowKey (event) {
    event.stopPropagation();
    
    
    window.setTimeout(function() {
      var options = {
        direction: (event.keyCode === keys$1.UP) ? 'left' : 'right'
      };
      this._updateModelSelection(options);
    }.bind(this));
  };

  Surface.prototype._handleHomeOrEndKey = function _handleHomeOrEndKey (event) {
    event.stopPropagation();
    
    
    window.setTimeout(function() {
      var options = {
        direction: (event.keyCode === keys$1.HOME) ? 'left' : 'right'
      };
      this._updateModelSelection(options);
    }.bind(this));
  };

  Surface.prototype._handlePageUpOrDownKey = function _handlePageUpOrDownKey (event) {
    event.stopPropagation();
    
    
    window.setTimeout(function() {
      var options = {
        direction: (event.keyCode === keys$1.PAGEUP) ? 'left' : 'right'
      };
      this._updateModelSelection(options);
    }.bind(this));
  };

  Surface.prototype._handleTabKey = function _handleTabKey (event) {
    var this$1 = this;

    event.stopPropagation();
    if (this.props.handleTab === false) {
      event.preventDefault();
      this.el.emit('tab', {
        altKey: event.altKey,
        ctrlKey: event.ctrlKey,
        metaKey: event.metaKey,
        shiftKey: event.shiftKey,
        code: event.code
      });
    } else {
      window.setTimeout(function (){
        this$1._updateModelSelection();
      });
    }
  };

  Surface.prototype._handleEnterKey = function _handleEnterKey (event) {
    event.preventDefault();
    event.stopPropagation();
    this.editorSession.transaction(function (tx) {
      tx.break();
    }, { action: 'break' });
  };

  Surface.prototype._handleDeleteKey = function _handleDeleteKey (event) {
    event.preventDefault();
    event.stopPropagation();
    var direction = (event.keyCode === keys$1.BACKSPACE) ? 'left' : 'right';
    this.editorSession.transaction(function (tx) {
      tx.deleteCharacter(direction);
    }, { action: 'delete' });
  };

  Surface.prototype._hasNativeFocus = function _hasNativeFocus () {
    return Boolean(this._state.hasNativeFocus)
  };

  Surface.prototype._setSelection = function _setSelection (sel) {
    
    
    
    
    
    
    
    
    if (!sel.isNull() && sel.surfaceId === this.id && platform.isFF) {
      this._focus();
    }
    this.editorSession.setSelection(sel);
  };

  Surface.prototype._updateModelSelection = function _updateModelSelection (options) {
    var sel = this.domSelection.getSelection(options);
    
    
    
    this._setSelection(sel);
  };

  Surface.prototype._selectProperty = function _selectProperty (path) {
    var doc = this.getDocument();
    var text = doc.get(path);
    this._setSelection(doc.createSelection({
      type: 'property',
      path: path,
      startOffset: 0,
      endOffset: text.length
    }));
  };

  
  
  Surface.prototype._registerTextProperty = function _registerTextProperty (textPropertyComponent) {
    var path = textPropertyComponent.getPath();
    this._textProperties[path] = textPropertyComponent;
  };

  Surface.prototype._unregisterTextProperty = function _unregisterTextProperty (textPropertyComponent) {
    var path = textPropertyComponent.getPath();
    if (this._textProperties[path] === textPropertyComponent) {
      delete this._textProperties[path];
    }
  };

  Surface.prototype._getTextPropertyComponent = function _getTextPropertyComponent (path) {
    return this._textProperties[path]
  };

  
  
  Surface.prototype._renderNode = function _renderNode ($$, nodeId) {
    var doc = this.getDocument();
    var node = doc.get(nodeId);
    var componentRegistry = this.context.componentRegistry || this.props.componentRegistry;
    var ComponentClass = componentRegistry.get(node.type);
    if (!ComponentClass) {
      console.error('Could not resolve a component for type: ' + node.type);
      ComponentClass = UnsupportedNodeComponent;
    }
    return $$(ComponentClass, {
      doc: doc,
      node: node
    })
  };

  
  Surface.prototype._shouldConsumeEvent = function _shouldConsumeEvent (event) {
    
    var comp = Component$$1.unwrap(event.target);
    return (comp && (comp === this || comp.context.surface === this))
  };

  
  Surface.prototype.getSelectionFromEvent = function getSelectionFromEvent (event) {
    var domRange = getDOMRangeFromEvent(event);
    var sel = this.domSelection.getSelectionForDOMRange(domRange);
    sel.surfaceId = this.getId();
    return sel;
  };

  Surface.prototype.setSelectionFromEvent = function setSelectionFromEvent (event) {
    var sel = this.getSelectionFromEvent(event);
    if (sel) {
      this._state.skipNextFocusEvent = true;
      this._setSelection(sel);
    } else {
      console.error('Could not create a selection from event.');
    }
  };

  prototypeAccessors.id.get = function () {
    return this._surfaceId
  };

  Object.defineProperties( Surface.prototype, prototypeAccessors );

  return Surface;
}(Component));

Surface.prototype._isSurface = true;


function createSurfaceId(surface) {
  var isolatedNodeComponent = surface.context.isolatedNodeComponent;
  if (isolatedNodeComponent) {
    var parentSurface = isolatedNodeComponent.context.surface;
    
    if (surface.isContainerEditor()) {
      if (isolatedNodeComponent._isInlineNodeComponent) {
        return parentSurface.id + '/' + isolatedNodeComponent.props.node.id + '/' + surface.name
      } else {
        return parentSurface.id + '/' + surface.name
      }
    }
    
    else {
      return parentSurface.id + '/' + isolatedNodeComponent.props.node.id + '/' + surface.name
    }
  } else {
    return surface.name
  }
}

var ContainerEditor = (function (Surface$$1) {
  function ContainerEditor(parent, props, el) {
    
    props.containerId = props.containerId || props.node.id;
    props.name = props.name || props.containerId || props.node.id;

    Surface$$1.call(this, parent, props, el);

    this.containerId = this.props.containerId;
    if (!isString$1(this.containerId)) {
      throw new Error("Property 'containerId' is mandatory.")
    }
    var doc = this.getDocument();
    this.container = doc.get(this.containerId);
    if (!this.container) {
      throw new Error('Container with id ' + this.containerId + ' does not exist.')
    }

    this.textTypes = this.props.textTypes || [];

    this.editingBehavior = this.context.editingBehavior || new EditingBehavior();

    this._deriveInternalState(this.props);
  }

  if ( Surface$$1 ) ContainerEditor.__proto__ = Surface$$1;
  ContainerEditor.prototype = Object.create( Surface$$1 && Surface$$1.prototype );
  ContainerEditor.prototype.constructor = ContainerEditor;

  
  ContainerEditor.prototype.shouldRerender = function shouldRerender (newProps) {
    if (newProps.disabled !== this.props.disabled) { return true }
    
    
    return false
  };

  ContainerEditor.prototype.willReceiveProps = function willReceiveProps (newProps) {
    Surface$$1.prototype.willReceiveProps.apply(this, arguments);
    this._deriveInternalState(newProps);
  };

  ContainerEditor.prototype.didMount = function didMount () {
    Surface$$1.prototype.didMount.apply(this, arguments);
    var editorSession = this.getEditorSession();
    editorSession.onUpdate('document', this._onContainerChanged, this, {
      path: [this.getContainerId(), 'nodes']
    });

  };

  ContainerEditor.prototype.dispose = function dispose () {
    Surface$$1.prototype.dispose.apply(this, arguments);
    var editorSession = this.getEditorSession();
    editorSession.off(this);
  };

  ContainerEditor.prototype.render = function render ($$) {
    var el = Surface$$1.prototype.render.call(this, $$);

    var doc = this.getDocument();
    var containerId = this.getContainerId();
    var containerNode = doc.get(containerId);
    if (!containerNode) {
      console.warn('No container node found for ', containerId);
    }
    el.addClass('sc-container-editor container-node ' + containerId)
      .attr("data-id", containerId);

    
    el.attr('spellcheck', this.props.spellcheck === 'native');

    containerNode.getNodes().forEach(function(node) {
      el.append(this._renderNode($$, node));
    }.bind(this));

    
    if (!this.props.disabled && !this.isEmpty()) {
      el.addClass('sm-enabled');
      el.setAttribute('contenteditable', true);
    }

    return el
  };

  ContainerEditor.prototype._renderNode = function _renderNode ($$, node) {
    if (!node) { throw new Error('Illegal argument') }
    if (node.isText()) {
      return Surface$$1.prototype.renderNode.call(this, $$, node)
    } else {
      var componentRegistry = this.context.componentRegistry;
      var ComponentClass = componentRegistry.get(node.type);
      if (ComponentClass.prototype._isCustomNodeComponent || ComponentClass.prototype._isIsolatedNodeComponent) {
        return $$(ComponentClass, { node: node }).ref(node.id)
      } else {
        return $$(IsolatedNodeComponent, { node: node }).ref(node.id)
      }
    }
  };

  ContainerEditor.prototype._deriveInternalState = function _deriveInternalState (props) {
    var _state = this._state;
    if (!props.hasOwnProperty('enabled') || props.enabled) {
      _state.enabled = true;
    } else {
      _state.enabled = false;
    }
  };

  ContainerEditor.prototype._selectNextIsolatedNode = function _selectNextIsolatedNode (direction) {
    var selState = this.getEditorSession().getSelectionState();
    var node = (direction === 'left') ? selState.getPreviousNode() : selState.getNextNode();
    if (!node || !node.isIsolatedNode()) { return false }
    if (
      (direction === 'left' && selState.isFirst()) ||
      (direction === 'right' && selState.isLast())
    ) {
      this.getEditorSession().setSelection({
        type: 'node',
        nodeId: node.id,
        containerId: selState.getContainer().id,
        surfaceId: this.id
      });
      return true
    }
    return false
  };

  ContainerEditor.prototype._handleLeftOrRightArrowKey = function _handleLeftOrRightArrowKey (event) {
    var this$1 = this;

    event.stopPropagation();
    var doc = this.getDocument();
    var sel = this.getEditorSession().getSelection();
    var left = (event.keyCode === keys$1.LEFT);
    var right = !left;
    var direction = left ? 'left' : 'right';

    if (sel && !sel.isNull()) {
      var container = doc.get(sel.containerId, 'strict');

      
      if (sel.isNodeSelection()) {
        var nodePos = container.getPosition(doc.get(sel.getNodeId()));
        if ((left && nodePos === 0) || (right && nodePos === container.length-1)) {
          event.preventDefault();
          return
        }
      }

      if (sel.isNodeSelection() && !event.shiftKey) {
        this.domSelection.collapse(direction);
      }
    }

    window.setTimeout(function () {
      this$1._updateModelSelection({ direction: direction });
    });
  };

  ContainerEditor.prototype._handleUpOrDownArrowKey = function _handleUpOrDownArrowKey (event) {
    var this$1 = this;

    event.stopPropagation();
    var doc = this.getDocument();
    var sel = this.getEditorSession().getSelection();
    var up = (event.keyCode === keys$1.UP);
    var down = !up;
    var direction = up ? 'left' : 'right';

    if (sel && !sel.isNull()) {
      var container = doc.get(sel.containerId, 'strict');
      
      if (sel.isNodeSelection()) {
        var nodePos = container.getPosition(doc.get(sel.getNodeId()));
        if ((up && nodePos === 0) || (down && nodePos === container.length-1)) {
          event.preventDefault();
          return
        }
        
        
        var editorSession = this.getEditorSession();
        
        
        
        if (!event.shiftKey) {
          event.preventDefault();
          if (up) {
            var prev = container.getChildAt(nodePos-1);
            setCursor(editorSession, prev, sel.containerId, 'after');
            return
          } else {
            var next = container.getChildAt(nodePos+1);
            setCursor(editorSession, next, sel.containerId, 'before');
            return
          }
        }
      }
    }

    window.setTimeout(function () {
      this$1._updateModelSelection({ direction: direction });
    });
  };

  ContainerEditor.prototype._handleTabKey = function _handleTabKey (event) {
    var editorSession = this.getEditorSession();
    var sel = editorSession.getSelection();
    if (sel.isNodeSelection() && sel.isFull()) {
      var comp = this.refs[sel.getNodeId()];
      if (comp && stepIntoIsolatedNode(editorSession, comp)) {
        event.preventDefault();
        event.stopPropagation();
        return
      }
    }
    Surface$$1.prototype._handleTabKey.call(this, event);
  };

  
  ContainerEditor.prototype.isContainerEditor = function isContainerEditor () {
    return true
  };

  
  ContainerEditor.prototype.getContainerId = function getContainerId () {
    return this.containerId
  };

  ContainerEditor.prototype.getContainer = function getContainer () {
    return this.getDocument().get(this.getContainerId())
  };

  ContainerEditor.prototype.isEmpty = function isEmpty () {
    var containerNode = this.getContainer();
    return (containerNode && containerNode.nodes.length === 0)
  };

  ContainerEditor.prototype.isEditable = function isEditable () {
    return Surface$$1.prototype.isEditable.call(this) && !this.isEmpty()
  };

  ContainerEditor.prototype.getTextTypes = function getTextTypes () {
    return this.textTypes || []
  };

  
  
  
  ContainerEditor.prototype.getTextCommands = function getTextCommands () {
    var textCommands = {};
    this.commandRegistry.each(function(cmd) {
      if (cmd.constructor.textTypeName) {
        textCommands[cmd.getName()] = cmd;
      }
    });
    return textCommands
  };

  
  ContainerEditor.prototype._onContainerChanged = function _onContainerChanged (change) {
    var this$1 = this;

    var doc = this.getDocument();
    
    var renderContext = RenderingEngine.createContext(this);
    var $$ = renderContext.$$;
    var container = this.getContainer();
    var path = container.getContentPath();
    for (var i = 0; i < change.ops.length; i++) {
      var op = change.ops[i];
      if (op.type === "update" && op.path[0] === path[0]) {
        var diff$$1 = op.diff;
        if (diff$$1.type === "insert") {
          var nodeId = diff$$1.getValue();
          var node = doc.get(nodeId);
          var nodeEl = (void 0);
          if (node) {
            nodeEl = this$1._renderNode($$, node);
          } else {
            
            
            
            nodeEl = $$('div');
          }
          this$1.insertAt(diff$$1.getOffset(), nodeEl);
        } else if (diff$$1.type === "delete") {
          this$1.removeAt(diff$$1.getOffset());
        }
      }
    }
  };

  return ContainerEditor;
}(Surface));

ContainerEditor.prototype._isContainerEditor = true;

function findParentComponent(el) {
  while (el) {
    var comp = Component.unwrap(el);
    if (comp) { return comp }
    el = el.parentNode;
  }
}

function setDOMSelection(startNode, startOffset, endNode, endOffset) {
  var wsel = window.getSelection();
  var wrange = window.document.createRange();
  if (startNode._isDOMElement) {
    startNode = startNode.getNativeElement();
  }
  if (!endNode) {
    endNode = startNode;
    endOffset = startOffset;
  }
  if (endNode._isDOMElement) {
    endNode = endNode.getNativeElement();
  }
  wrange.setStart(startNode, startOffset);
  wrange.setEnd(endNode, endOffset);
  wsel.removeAllRanges();
  wsel.addRange(wrange);
}

var DragAndDropHandler = function DragAndDropHandler () {};

var prototypeAccessors$8 = { _isDragAndDropHandler: {} };

DragAndDropHandler.prototype.match = function match (dragState, context) { 
  return false
};

DragAndDropHandler.prototype.drop = function drop (dragState, context) { 
  
};

prototypeAccessors$8._isDragAndDropHandler.get = function () {
  return true
};

Object.defineProperties( DragAndDropHandler.prototype, prototypeAccessors$8 );

var DragManager = (function (EventEmitter$$1) {
  function DragManager(customDropHandlers, context) {
    EventEmitter$$1.call(this);

    this.context = context;

    var dropAssetHandlers = [];
    var moveInlineHandlers = [];
    customDropHandlers.forEach(function (h) {
      
      var type = h.type || 'drop-asset';
      switch (type) {
        case 'drop-asset': {
          dropAssetHandlers.push(h);
          break
        }
        case 'move-inline': {
          moveInlineHandlers.push(h);
          break
        }
        default:
          console.warn('Unknown type of drop handler.', h);
      }
    });

    
    this.dropHandlers = [
      
      new MoveInline(moveInlineHandlers),
      
      new MoveBlockNode(),
      
      new InsertNodes(dropAssetHandlers, this.context),
      
      
      new CustomHandler() ];
    if (platform.inBrowser) {
      this.el = DefaultDOMElement.wrapNativeElement(document);
      this.el.on('dragstart', this.onDragStart, this);
      
      this.el.on('drop', this.onDragEnd, this);
      this.el.on('dragenter', this.onDragEnter, this);
      this.el.on('dragexit', this.onDragExit, this);
      this.el.on('mousedown', this.onMousedown, this);
    }
  }

  if ( EventEmitter$$1 ) DragManager.__proto__ = EventEmitter$$1;
  DragManager.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  DragManager.prototype.constructor = DragManager;

  DragManager.prototype.dispose = function dispose () {
    if (this.el) {
      this.el.off(this);
    }
  };

  DragManager.prototype.onDragStart = function onDragStart (e) {
    
    this._initDrag(e, { external: false });
    
    
    var img = document.createElement("img");
    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
    e.dataTransfer.setDragImage(img, 0, 0);
    
    
    
    
    
    
    if (this.dragState.mode === 'inline') {
      e.dataTransfer.setData('text/html', img.outerHTML);
    } else {
      
      
      e.dataTransfer.setData('text/html', '<div></div>');
    }
    
  };

  
  DragManager.prototype.onDragEnter = function onDragEnter (e) {
    if (!this.dragState) {
      
      this._initDrag(e, {external: true});
    }
  };

  DragManager.prototype.onDragEnd = function onDragEnd (event) {
    if (event.__reserved__) { return }
    
    if (this.dragState) {
      event.stopPropagation();
      event.preventDefault();
      
      
      this._onDragEnd(event);
    }
  };

  DragManager.prototype.onDragExit = function onDragExit (e) {
    if (platform.isFF) {
      
    } else {
      
      
      
      this._onDragEnd(e);
    }
  };

  DragManager.prototype.extendDragState = function extendDragState (extState) {
    Object.assign(this.dragState, extState);
  };

  
  
  DragManager.prototype.onMousedown = function onMousedown (event) {
    if (this.dragState) {
      this.dragState = null;
      this._onDragEnd(event);
    }
  };

  DragManager.prototype._onDragEnd = function _onDragEnd (event) {
    if (!this.dragState) {
      
      
      
      console.warn('Not in a valid drag state.');
    } else {
      this._handleDrop(event);
    }
    this.emit('drag:finished');
    this.dragState = null;
  };

  
  DragManager.prototype._handleDrop = function _handleDrop (e) {
    var this$1 = this;

    var dragState = this.dragState;
    var i, handler;
    var match = false;
    dragState.event = e;
    dragState.data = this._getData(e);
    
    for (i = 0; i < this.dropHandlers.length && !match; i++) {
      handler = this$1.dropHandlers[i];
      match = handler.match(dragState);
    }
    if (match) {
      var editorSession = this.context.editorSession;
      editorSession.transaction(function (tx) {
        handler.drop(tx, dragState);
      });
    } else {
      console.error('No drop handler could be found.');
    }
  };

  
  DragManager.prototype._initDrag = function _initDrag (event, options) {
    
    
    
    

    
    var sel = this._getSelection();
    var dragState = Object.assign({ startEvent: event }, options);
    this.dragState = dragState;

    
    
    if (dragState.external) {
      dragState.selectionDrag = false;
      dragState.sourceSelection = null;
      dragState.scrollPanes = this._getSurfacesGroupedByScrollPane();
      this.emit('drag:started', dragState);
      return
    }

    
    
    var isSelectionDrag = (
      (sel.isPropertySelection() || sel.isContainerSelection()) &&
      isMouseInsideDOMSelection(event)
    );
    if (isSelectionDrag) {
      
      if (sel.isContainerSelection()) {
        console.warn('Dragging of ContainerSelection is not supported yet.');
        return _stop()
      }
      
      dragState.inline = true;
      dragState.selectionDrag = true;
      dragState.sourceSelection = sel;
      
      return
    }
    var comp = Component.unwrap(event.target);
    if (!comp) { return _stop() }
    var isolatedNodeComponent;
    if (comp._isInlineNodeComponent) {
      isolatedNodeComponent = comp;
      dragState.inline = true;
      dragState.sourceNode = comp.props.node;
    } else {
      isolatedNodeComponent = comp.context.isolatedNodeComponent;
    }
    if (!isolatedNodeComponent) { return _stop() }
    var surface = isolatedNodeComponent.context.surface;
    
    if(isolatedNodeComponent._isInlineNodeComponent) {
      var inlineNode = isolatedNodeComponent.props.node;
      dragState.inline = true;
      dragState.selectionDrag = true;
      dragState.sourceSelection = {
        type: 'property',
        path: inlineNode.start.path,
        startOffset: inlineNode.start.offset,
        endOffset: inlineNode.end.offset,
        containerId: surface.getContainerId(),
        surfaceId: surface.id
      };
      return
    }
    
    
    dragState.selectionDrag = false;
    dragState.nodeDrag = true;
    dragState.sourceSelection = {
      type: 'node',
      nodeId: isolatedNodeComponent.props.node.id,
      containerId: surface.getContainerId(),
      surfaceId: surface.id
    };
    
    
    
    dragState.scrollPanes = this._getSurfacesGroupedByScrollPane();
    
    this.emit('drag:started', dragState);

    function _stop() {
      
      event.preventDefault();
      event.stopPropagation();
    }
  };

  DragManager.prototype._getSurfacesGroupedByScrollPane = function _getSurfacesGroupedByScrollPane () {
    
    
    var surfaces = this.context.surfaceManager.getSurfaces();
    var scrollPanes = {};
    surfaces.forEach(function (surface) {
      
      if (!surface.isContainerEditor()) { return }
      var scrollPane = surface.context.scrollPane;
      var scrollPaneName = scrollPane.getName();
      var surfaceName = surface.getName();
      if (!scrollPanes[scrollPaneName]) {
        var surfaces = {};
        surfaces[surfaceName] = surface;
        scrollPanes[scrollPaneName] = { scrollPane: scrollPane, surfaces: surfaces };
      } else {
        scrollPanes[scrollPaneName].surfaces[surfaceName] = surface;
      }
    });
    return scrollPanes
  };

  DragManager.prototype._getSelection = function _getSelection () {
    return this.context.editorSession.getSelection()
  };

  DragManager.prototype._getComponents = function _getComponents (targetEl) {
    var res = [];
    var curr = targetEl;
    while (curr) {
      var comp = Component.getComponentForDOMElement(curr);
      if (comp) {
        res.unshift(comp);
        if(comp._isSurface) {
          return res
        }
      }
      curr = curr.parentNode;
    }
    return null
  };

  DragManager.prototype._getIsolatedNodeOrContainerChild = function _getIsolatedNodeOrContainerChild (targetEl) {
    var parent, current;
    current = targetEl;
    parent = current.parentNode;
    while(parent) {
      if (parent._comp && parent._comp._isContainerEditor) {
        return current._comp
      } else if (current._comp && current._comp._isIsolatedNode) {
        return current._comp
      }
      current = parent;
      parent = current.parentNode;
    }
  };

  
  DragManager.prototype._extractUris = function _extractUris (dataTransfer) {
    var uris = [];
    var rawUriList = dataTransfer.getData('text/uri-list');
    if (rawUriList) {
      uris = rawUriList.split('\n').filter(function(item) {
        return !item.startsWith('#')
      });
    }
    return uris
  };

  
  DragManager.prototype._getData = function _getData (e) {
    var dataTransfer = e.dataTransfer;
    if (dataTransfer) {
      return {
        files: Array.prototype.slice.call(dataTransfer.files),
        uris: this._extractUris(dataTransfer),
        text: dataTransfer.getData('text/plain'),
        html: dataTransfer.getData('text/html')
      }
    }
  };

  return DragManager;
}(EventEmitter));


var MoveBlockNode = (function (DragAndDropHandler$$1) {
  function MoveBlockNode () {
    DragAndDropHandler$$1.apply(this, arguments);
  }

  if ( DragAndDropHandler$$1 ) MoveBlockNode.__proto__ = DragAndDropHandler$$1;
  MoveBlockNode.prototype = Object.create( DragAndDropHandler$$1 && DragAndDropHandler$$1.prototype );
  MoveBlockNode.prototype.constructor = MoveBlockNode;

  MoveBlockNode.prototype.match = function match (dragState) {
    var ref = dragState.dropParams;
    var insertPos = ref.insertPos;
    
    return (!dragState.external && dragState.nodeDrag &&
      dragState.dropType === 'place' && insertPos >= 0
    )
  };

  MoveBlockNode.prototype.drop = function drop (tx, dragState) {
    
    
    
    
    var ref = dragState.dropParams;
    var insertPos = ref.insertPos;
    tx.setSelection(dragState.sourceSelection);
    var copy = tx.copySelection();
    
    tx.deleteSelection({ clear: true });
    var containerId = dragState.targetSurface.getContainerId();
    var surfaceId = dragState.targetSurface.getName();
    var container = tx.get(containerId);
    var targetNode = container.nodes[insertPos];
    var insertMode = 'before';
    if (!targetNode) {
      targetNode = container.nodes[insertPos-1];
      insertMode = 'after';
    }
    tx.setSelection({
      type: 'node',
      nodeId: targetNode,
      mode: insertMode,
      containerId: containerId,
      surfaceId: surfaceId
    });
    tx.paste(copy);
  };

  return MoveBlockNode;
}(DragAndDropHandler));

var MoveInline = (function (DragAndDropHandler$$1) {
  function MoveInline () {
    DragAndDropHandler$$1.apply(this, arguments);
  }

  if ( DragAndDropHandler$$1 ) MoveInline.__proto__ = DragAndDropHandler$$1;
  MoveInline.prototype = Object.create( DragAndDropHandler$$1 && DragAndDropHandler$$1.prototype );
  MoveInline.prototype.constructor = MoveInline;

  MoveInline.prototype.match = function match (dragState) {
    return !dragState.external && dragState.inline
  };

  MoveInline.prototype.drop = function drop (tx, dragState) {
    var event = dragState.event;
    var sourceSel = dragState.sourceSelection;
    var wrange = getDOMRangeFromEvent(event);
    if (!wrange) { return }
    var comp = Component.unwrap(event.target);
    if (!comp) { return }
    var domSelection = comp.context.domSelection;
    if (!domSelection) { return }
    var range = domSelection.mapDOMRange(wrange);
    if (!range) { return }
    var targetSel = tx.getDocument()._createSelectionFromRange(range);

    
    tx.selection = sourceSel;
    var snippet = tx.copySelection();
    tx.deleteSelection();
    tx.selection = transformSelection(targetSel, tx);
    tx.paste(snippet);
  };

  return MoveInline;
}(DragAndDropHandler));

var InsertNodes = (function (DragAndDropHandler$$1) {
  function InsertNodes(assetHandlers, context) {
    DragAndDropHandler$$1.call(this);
    this.assetHandlers = assetHandlers;
    this.context = context;
  }

  if ( DragAndDropHandler$$1 ) InsertNodes.__proto__ = DragAndDropHandler$$1;
  InsertNodes.prototype = Object.create( DragAndDropHandler$$1 && DragAndDropHandler$$1.prototype );
  InsertNodes.prototype.constructor = InsertNodes;

  InsertNodes.prototype.match = function match (dragState) {
    return dragState.dropType === 'place' && dragState.external
  };

  InsertNodes.prototype.drop = function drop (tx, dragState) {
    var this$1 = this;

    var ref = dragState.dropParams;
    var insertPos = ref.insertPos;
    var files = dragState.data.files;
    var uris = dragState.data.uris;
    var containerId = dragState.targetSurface.getContainerId();
    var surfaceId = dragState.targetSurface.id;
    var container = tx.get(containerId);
    var targetNode = container.nodes[insertPos];
    var insertMode = 'before';
    if (!targetNode) {
      targetNode = container.nodes[insertPos-1];
      insertMode = 'after';
    }
    tx.setSelection({
      type: 'node',
      nodeId: targetNode,
      mode: insertMode,
      containerId: containerId,
      surfaceId: surfaceId
    });
    if (files.length > 0) {
      files.forEach(function (file) {
        this$1._callHandlers(tx, {
          file: file,
          type: 'file'
        });
      });
    } else if (uris.length > 0) {
      uris.forEach(function (uri) {
        this$1._callHandlers(tx, {
          uri: uri,
          type: 'uri'
        });
      });
    } else {
      console.info('TODO: implement html/text drop here');
    }
  };

  InsertNodes.prototype._callHandlers = function _callHandlers (tx, params) {
    var this$1 = this;

    var i, handler;
    for (i = 0; i < this.assetHandlers.length; i++) {
      handler = this$1.assetHandlers[i];

      var match = handler.match(params, this$1.context);
      if (match) {
        handler.drop(tx, params, this$1.context);
        break
      }
    }
  };

  return InsertNodes;
}(DragAndDropHandler));


var CustomHandler = (function (DragAndDropHandler$$1) {
  function CustomHandler () {
    DragAndDropHandler$$1.apply(this, arguments);
  }

  if ( DragAndDropHandler$$1 ) CustomHandler.__proto__ = DragAndDropHandler$$1;
  CustomHandler.prototype = Object.create( DragAndDropHandler$$1 && DragAndDropHandler$$1.prototype );
  CustomHandler.prototype.constructor = CustomHandler;

  CustomHandler.prototype.match = function match (dragState) {
    return dragState.dropType === 'custom'
  };

  CustomHandler.prototype.drop = function drop (tx, dragState) {
    
    dragState.component.handleDrop(tx, dragState);
  };

  return CustomHandler;
}(DragAndDropHandler));

var EditAnnotationCommand = (function (Command$$1) {
  function EditAnnotationCommand() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Command$$1.apply(this, args);

    if (!this.config.nodeType) {
      throw new Error("'nodeType' is required")
    }
  }

  if ( Command$$1 ) EditAnnotationCommand.__proto__ = Command$$1;
  EditAnnotationCommand.prototype = Object.create( Command$$1 && Command$$1.prototype );
  EditAnnotationCommand.prototype.constructor = EditAnnotationCommand;

  
  EditAnnotationCommand.prototype.getCommandState = function getCommandState (params) {
    var sel = this._getSelection(params);
    var annos = this._getAnnotationsForSelection(params);
    var newState = {
      disabled: true,
    };
    if (annos.length === 1 && sel.isPropertySelection() && sel.isCollapsed()) {
      newState.disabled = false;
      newState.node = annos[0];
    }
    return newState
  };

  EditAnnotationCommand.prototype.execute = function execute (params) { }; 

  EditAnnotationCommand.prototype._getAnnotationsForSelection = function _getAnnotationsForSelection (params) {
    return params.selectionState.getAnnotationsForType(this.config.nodeType)
  };

  return EditAnnotationCommand;
}(Command));

var EditInlineNodeCommand = (function (Command$$1) {
  function EditInlineNodeCommand() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Command$$1.apply(this, args);
    if (!this.config.nodeType) {
      throw new Error('Every AnnotationCommand must have a nodeType')
    }
  }

  if ( Command$$1 ) EditInlineNodeCommand.__proto__ = Command$$1;
  EditInlineNodeCommand.prototype = Object.create( Command$$1 && Command$$1.prototype );
  EditInlineNodeCommand.prototype.constructor = EditInlineNodeCommand;

  EditInlineNodeCommand.prototype.getCommandState = function getCommandState (params) {
    var sel = params.selection;
    var newState = {
      disabled: true,
      active: false
    };
    var annos = this._getAnnotationsForSelection(params);
    if (annos.length === 1 && annos[0].getSelection().equals(sel)) {
      newState.disabled = false;
      newState.node = annos[0];
    }
    return newState
  };

  EditInlineNodeCommand.prototype.execute = function execute (params) { 

  };

  EditInlineNodeCommand.prototype._getAnnotationsForSelection = function _getAnnotationsForSelection (params) {
    return params.selectionState.getAnnotationsForType(this.config.nodeType)
  };

  return EditInlineNodeCommand;
}(Command));

var FileManager = function FileManager(editorSession, extensions, context) {
  var this$1 = this;

  this.editorSession = editorSession;
  this.extensions = extensions;
  this.proxies = {};
  this.context = context;

  
  forEach(editorSession.getDocument().getNodes(), function (node) {
    if (node._isFileNode) { this$1.storeFile(node); }
  });

  this.editorSession.onUpdate('document', this._onDocumentChange, this);
};

FileManager.prototype.dispose = function dispose () {
  this.editorSession.off(this);
};

FileManager.prototype.storeFile = function storeFile (fileNode) {
  var proxy = this.proxies[fileNode.id];
  
  if (!proxy) {
    proxy = this.createFileProxy(fileNode);
    if (proxy) {
      this.proxies[fileNode.id] = proxy;
    }
  }
  fileNode.proxy = proxy;
  return proxy
};

FileManager.prototype.createFileProxy = function createFileProxy (fileNode) {
    var this$1 = this;
 
  var context = this.context;
  for (var i = 0; i < this.extensions.length; i++) {
    var ExtClass = this$1.extensions[i];
    if (ExtClass.match(fileNode, context)) {
      return new ExtClass(fileNode, context)
    }
  }
  console.error('No file adapter found for ', fileNode);
};

FileManager.prototype.getProxy = function getProxy (fileNode) {
  return this.proxies[fileNode.id]
};

FileManager.prototype.sync = function sync () {
  
  
  var promises = map(this.proxies, function (proxy) {
    return proxy.sync()
  });
  return Promise.all(promises)
};

FileManager.prototype._onDocumentChange = function _onDocumentChange (change) {
    var this$1 = this;

  var doc = this.editorSession.getDocument();
  forEach(change.created, function (nodeData) {
    
    var node = doc.get(nodeData.id);
    if (node._isFileNode) {
      this$1.storeFile(node);
    }
  });
};

var events = [ 'keydown', 'keyup', 'keypress', 'mousedown', 'mouseup' , 'copy' ];

var GlobalEventHandler = function GlobalEventHandler(editorSession, surfaceManager) {
  this.editorSession = editorSession;
  this.surfaceManager = surfaceManager;
  this.listeners = [];
  this.initialize();
};

GlobalEventHandler.prototype.initialize = function initialize () {
  if (platform.inBrowser) {
    var document = DefaultDOMElement.wrapNativeElement(window.document);
    events.forEach(function(name) {
      document.on(name, this._dispatch.bind(this, name), this);
    }.bind(this));
  }
};

GlobalEventHandler.prototype.dispose = function dispose () {
  if (platform.inBrowser) {
    var document = DefaultDOMElement.wrapNativeElement(window.document);
    document.off(this);
  }
};

GlobalEventHandler.prototype.addEventListener = function addEventListener (eventName, handler, options) {
  if (!options.id) {
    throw new Error("GlobalEventHandler can only be used with option 'id'")
  }
  var listener = new DOMEventListener(eventName, handler, options);
  this.listeners.push(listener);
};

GlobalEventHandler.prototype.removeEventListener = function removeEventListener (listener) {
  var idx = this.listeners.indexOf(listener);
  if (idx > -1) {
    this.listeners.splice(idx, 1);
  }
};

GlobalEventHandler.prototype.getEventListeners = function getEventListeners () {
  return this.listeners
};

GlobalEventHandler.prototype._getActiveListener = function _getActiveListener (eventName) {
    var this$1 = this;

  var editorSession = this.editorSession;
  var sel = editorSession.getSelection();
  if (sel) {
    var surfaceId = sel.surfaceId;
    for (var i = 0; i < this.listeners.length; i++) {
      var listener = this$1.listeners[i];
      if (listener.eventName === eventName && listener.options.id === surfaceId) {
        return listener
      }
    }
  }
};

GlobalEventHandler.prototype._dispatch = function _dispatch (eventName, e) {
  var listener = this._getActiveListener(eventName);
  if (listener) {
    listener.handler(e);
  }
};

GlobalEventHandler.prototype.on = DOMElement.prototype.on;
GlobalEventHandler.prototype.off = DOMElement.prototype.off;

var ExecuteCommandHandler = function ExecuteCommandHandler(editorSession, commandName) {
  this.editorSession = editorSession;
  this.commandName = commandName;
};
ExecuteCommandHandler.prototype.execute = function execute (params) {
  var commandState = params.editorSession.getCommandStates()[this.commandName];
  if (!commandState || commandState.disabled) { return false }
  this.editorSession.executeCommand(this.commandName, params);
  return true
};

var KeyboardManager = function KeyboardManager(editorSession, bindings, options) {
  var this$1 = this;

  this.editorSession = editorSession;

  this.context = options.context || {};

  this.keydownBindings = {};
  this.textinputBindings = {};

  bindings.forEach(function (ref) {
    var key = ref.key;
    var spec = ref.spec;

    
    var type = spec.type || 'keydown';
    if(spec.command) {
      var handler = new ExecuteCommandHandler(editorSession, spec.command);
      var hook = handler.execute.bind(handler);
      if (type === 'keydown') {
        this$1.keydownBindings[parseCombo(key)] = hook;
      } else if (type === 'textinput') {
        this$1.textinputBindings[key] = hook;
      }
    } else {
      throw new Error('Keyboard binding not supported', spec)
    }
  });
};

KeyboardManager.prototype.onKeydown = function onKeydown (event) {
  var key = parseKeyEvent(event);
  var hook = this.keydownBindings[key];
  if (hook) {
    event.preventDefault();
    event.stopPropagation();
    var params = this._getParams();
    hook(params, this.context);
    return true
  }
};

KeyboardManager.prototype.onTextInput = function onTextInput (text) {
  var hook = this.textinputBindings[text];
  if (hook) {
    var params = this._getParams();
    return hook(params, this.context)
  }
};

KeyboardManager.prototype._getParams = function _getParams () {
  var editorSession = this.editorSession;
  var selectionState = editorSession.getSelectionState();
  var sel = selectionState.getSelection();
  var surface = this.context.surfaceManager.getFocusedSurface();
  return {
    editorSession: editorSession,
    selectionState: selectionState,
    surface: surface,
    selection: sel,
  }
};

function parseCombo(combo) {
  var frags = combo.split('+');
  var data = {
    keyCode: -1
  };
  for (var i = 0; i < frags.length; i++) {
    var frag = frags[i].toUpperCase();
    switch(frag) {
      case 'ALT': {
        data.altKey = true;
        break
      }
      case 'ALTGR': {
        data.altKey = true;
        data.code = 'AltRight';
        break
      }
      case 'CMD': {
        data.metaKey = true;
        break
      }
      case 'CTRL': {
        data.ctrlKey = true;
        break
      }
      case 'SHIFT': {
        data.shiftKey = true;
        break
      }
      default:
        if (frag.length === 1) {
          data.keyCode = frag.charCodeAt(0);
        } else if (keys$1.hasOwnProperty(frag)) {
          data.keyCode = keys$1[frag];
        } else {
          throw new Error('Unsupported keyboard command: '+ combo)
        }
    }
  }
  return parseKeyEvent(data)
}

KeyboardManager.parseCombo = parseCombo;

var MacroManager = function MacroManager(context, macros) {
  this.context = context;
  this.macros = macros;
  this.context.editorSession.onFinalize('document', this.onDocumentChanged, this);
};

MacroManager.prototype.dispose = function dispose () {
  this.context.editorSession.off(this);
};

MacroManager.prototype.onDocumentChanged = function onDocumentChanged (change, info) {
  this.executeMacros(change, info);
};

MacroManager.prototype.executeMacros = function executeMacros (change, info) {
    var this$1 = this;

  var doc = this.context.editorSession.getDocument();
  var nodeId, node, text, start, end;
  var path;
  
  
  switch(info.action) {
    case 'type': {
      var op = change.ops[0];
      if (op.type === 'update' && op.diff._isTextOperation) {
        path = op.path;
        nodeId = path[0];
        node = doc.get(nodeId);
        text = doc.get(path);
        start = op.diff.pos;
        end = start+op.diff.getLength();
      }
      break
    }
    case 'break': {
      
      
      

      
      
      
      
      var sel = change.before.selection;
      if (!sel.isPropertySelection()) { return }
      path = sel.path;
      nodeId = path[0];
      node = doc.get(nodeId);
      
      if (!node || !node.isText()) { return }
      text = node.getText();
      start = sel.start.offset;
      end = start;
      break
    }
    case 'paste': {
      
      if (change.ops.length === 1) {
        var op$1 = change.ops[0];
        if (op$1.type === 'update' && op$1.propertyType === 'string') {
          path = op$1.path;
          nodeId = path[0];
          node = doc.get(nodeId);
          if (!node.isText()) { return }
          text = node.getText();
          start = op$1.diff.pos;
          end = start+op$1.diff.getLength();
        }
      }
      break
    }
    default:
      return
  }

  var props = {
    action: info.action,
    node: node,
    path: path,
    text: text,
    start: start,
    end: end,
    editorSession: this.context.editorSession,
    selection: this.context.editorSession.getSelection()
  };

  setTimeout(function () {
    for (var i = 0; i < this$1.macros.length; i++) {
      var macro = this$1.macros[i];
      var executed = macro.execute(props, this$1.context);
      if (executed) {
        break
      }
    }
  });

};

var MarkersManager = function MarkersManager(editorSession) {
  this.editorSession = editorSession;

  
  this._textProperties = {};
  this._dirtyProps = {};

  this._markers = new MarkersIndex(editorSession);

  editorSession.onUpdate(this._onChange, this);
  editorSession.onRender(this._updateProperties, this);
};

MarkersManager.prototype.dispose = function dispose () {
  this.editorSession.off(this);
  this._markers.dispose();
};

MarkersManager.prototype.register = function register (textProperyComponent) {
  var path = String(textProperyComponent.getPath());
  
  var textProperties = this._textProperties[path];
  if (!textProperties) {
    textProperties = this._textProperties[path] = [];
  }
  textProperties.push(textProperyComponent);
};

MarkersManager.prototype.deregister = function deregister (textProperyComponent) {
  var path = String(textProperyComponent.getPath());
  
  var textProperties = this._textProperties[path];
  if (!textProperties) {
    
    return
  }
  deleteFromArray(this._textProperties[path], textProperyComponent);
  if (textProperties.length === 0) {
    delete this._textProperties[path];
  }
};

MarkersManager.prototype.getMarkers = function getMarkers (path, opts) {
  opts = opts || {};
  var doc = this.editorSession.getDocument();
  var annos = doc.getAnnotations(path) || [];
  var markers = this._markers.get(path, opts.surfaceId, opts.containerId);
  return annos.concat(markers)
};

MarkersManager.prototype._onChange = function _onChange (editorSession) {
    var this$1 = this;

  if (editorSession.hasDocumentChanged()) {
    
    if (editorSession.hasDocumentChanged()) {
      var change = editorSession.getChange();
      forEach(change.updated, function (val, id) {
        this$1._dirtyProps[id] = true;
      });
    }
    Object.assign(this._dirtyProps, this._markers._collectDirtyProps());
  }
};

MarkersManager.prototype._updateProperties = function _updateProperties () {
    var this$1 = this;

  Object.keys(this._dirtyProps).forEach(function (path) {
    var textProperties = this$1._textProperties[path];
    if (textProperties) {
      textProperties.forEach(this$1._updateTextProperty.bind(this$1));
    }
  });
  this._dirtyProps = {};
};

MarkersManager.prototype._updateTextProperty = function _updateTextProperty (textPropertyComponent) {
  var path = textPropertyComponent.getPath();
  var markers = this.getMarkers(path, {
    surfaceId: textPropertyComponent.getSurfaceId(),
    containerId: textPropertyComponent.getContainerId()
  });
  
  textPropertyComponent.setState({
    markers: markers
  });
};


var MarkersIndex = function MarkersIndex(editorSession) {
  this.editorSession = editorSession;
  this.document = editorSession.getDocument();
  this._documentMarkers = new ArrayTree();
  this._surfaceMarkers = {};
  this._containerMarkers = {};

  this._dirtyProps = {};

  this.document.addIndex('markers', this);
  editorSession.onUpdate('document', this._onDocumentChange, this);
};

MarkersIndex.prototype.dispose = function dispose () {
  
  
  delete this.document.data.indexes['markers'];
  this.editorSession.off(this);
};

MarkersIndex.prototype.reset = function reset () {
    var this$1 = this;

  this._documentMarkers = new ArrayTree();
  this._surfaceMarkers = {};
  this._containerMarkers = {};
  var doc = this.document;
  forEach(doc.getNodes(), function (node) {
    if (this$1.select(node)) {
      this$1.create(node);
    }
  });
};

MarkersIndex.prototype.select = function select (node) {
  return node._isMarker
};

MarkersIndex.prototype.create = function create (marker) {
  
  switch (marker.constructor.scope) {
    case 'document': {
      this._dirtyProps[marker.path] = true;
      this._documentMarkers.add(marker.path, marker);
      break
    }
    case 'surface': {
      if (!this._surfaceMarkers[marker.surfaceId]) {
        this._surfaceMarkers[marker.surfaceId] = new ArrayTree();
      }
      this._dirtyProps[marker.path] = true;
      this._surfaceMarkers[marker.surfaceId].add(marker.path, marker);
      break
    }
    case 'container': {
      console.warn('Container scoped markers are not supported yet');
      break
    }
    default:
      console.error('Invalid marker scope.');
  }
};

MarkersIndex.prototype.delete = function delete$1 (marker) {
  switch (marker.constructor.scope) {
    case 'document': {
      this._dirtyProps[marker.path] = true;
      this._documentMarkers.remove(marker.path, marker);
      break
    }
    case 'surface': {
      if (!this._surfaceMarkers[marker.surfaceId]) {
        this._surfaceMarkers[marker.surfaceId] = new ArrayTree();
      }
      this._dirtyProps[marker.path] = true;
      this._surfaceMarkers[marker.surfaceId].remove(marker.path, marker);
      break
    }
    case 'container': {
      console.warn('Container scoped markers are not supported yet');
      break
    }
    default:
      console.error('Invalid marker scope.');
  }
};

MarkersIndex.prototype.get = function get (path, surfaceId) {
  var markers = this._documentMarkers[path] || [];
  if (surfaceId && this._surfaceMarkers[surfaceId]) {
    var surfaceMarkers = this._surfaceMarkers[surfaceId][path];
    if (surfaceMarkers) { markers = markers.concat(surfaceMarkers); }
  }
  
  return markers
};

MarkersIndex.prototype._collectDirtyProps = function _collectDirtyProps () {
  var dirtyProps = this._dirtyProps;
  this._dirtyProps = {};
  return dirtyProps
};


MarkersIndex.prototype._getAllCustomMarkers = function _getAllCustomMarkers (path) {
    var this$1 = this;

  var markers = this._documentMarkers[path] || [];
  for(var surfaceId in this$1._surfaceMarkers) {
    if (!this$1._surfaceMarkers.hasOwnProperty(surfaceId)) { continue }
    var surfaceMarkers = this$1._surfaceMarkers[surfaceId][path];
    if (surfaceMarkers) { markers = markers.concat(surfaceMarkers); }
  }
  
  return markers
};

MarkersIndex.prototype._onDocumentChange = function _onDocumentChange (change) {
    var this$1 = this;

  var doc = this.doc;
  change.ops.forEach(function (op) {
    var markers = this$1._getAllCustomMarkers(op.path);
    if (op.type === 'update' && op.diff._isTextOperation) {
      var diff$$1 = op.diff;
      switch (diff$$1.type) {
        case 'insert':
          this$1._transformInsert(doc, markers, diff$$1);
          break
        case 'delete':
          this$1._transformDelete(doc, markers, diff$$1);
          break
        default:
          
      }
    }
  });
};

MarkersIndex.prototype._transformInsert = function _transformInsert (doc, markers, op) {
  var pos = op.pos;
  var length = op.str.length;
  if (length === 0) { return }
  markers.forEach(function(marker) {
    
    var start = marker.start.offset;
    var end = marker.end.offset;
    var newStart = start;
    var newEnd = end;
    if (pos >= end) { return }
    if (pos <= start) {
      newStart += length;
      newEnd += length;
      marker.start.offset = newStart;
      marker.end.offset = newEnd;
      return
    }
    if (pos < end) {
      newEnd += length;
      marker.end.offset = newEnd;
      if (marker.invalidate) { marker.invalidate(); }
    }
  });
};

MarkersIndex.prototype._transformDelete = function _transformDelete (doc, markers, op) {
  var pos1 = op.pos;
  var length = op.str.length;
  var pos2 = pos1 + length;
  if (pos1 === pos2) { return }
  markers.forEach(function (marker) {
    var start = marker.start.offset;
    var end = marker.end.offset;
    var newStart = start;
    var newEnd = end;
    if (pos2 <= start) {
      newStart -= length;
      newEnd -= length;
      marker.start.offset = newStart;
      marker.end.offset = newEnd;
    } else if (pos1 >= end) {
      
    }
    
    
    else {
      if (pos1 <= start) {
        newStart = start - Math.min(pos2-pos1, start-pos1);
      }
      if (pos1 <= end) {
        newEnd = end - Math.min(pos2-pos1, end-pos1);
      }
      
      if (start !== end && newStart === newEnd) {
        marker.remove();
        return
      }
      if (start !== newStart) {
        marker.start.offset = newStart;
      }
      if (end !== newEnd) {
        marker.end.offset = newEnd;
      }
      if (marker.invalidate) { marker.invalidate(); }
    }
  });
};

var SurfaceManager = function SurfaceManager(editorSession) {
  this.editorSession = editorSession;
  this.surfaces = {};
  this._state = {
    focusedSurfaceId: null,
    selection: null,
  };
  editorSession.onUpdate('selection', this._onSelectionChanged, this);
  editorSession.onPostRender(this._recoverDOMSelection, this);
};

SurfaceManager.prototype.dispose = function dispose () {
  this.editorSession.off(this);
};


SurfaceManager.prototype.getSurface = function getSurface (name) {
  if (name) {
    return this.surfaces[name]
  }
};


SurfaceManager.prototype.getFocusedSurface = function getFocusedSurface () {
  if (this._state.focusedSurfaceId) {
    return this.getSurface(this._state.focusedSurfaceId)
  }
};

SurfaceManager.prototype.getSurfaces = function getSurfaces () {
    var this$1 = this;

  
  
  return Object.keys(this.surfaces).map(function (key) { return this$1.surfaces[key]; })
};


SurfaceManager.prototype.registerSurface = function registerSurface (surface) {
  this.surfaces[surface.getId()] = surface;
};


SurfaceManager.prototype.unregisterSurface = function unregisterSurface (surface) {
  surface.off(this);
  var surfaceId = surface.getId();
  
  
  
  
  
  var registeredSurface = this.surfaces[surfaceId];
  if (registeredSurface === surface) {
    var focusedSurface = this.getFocusedSurface();
    delete this.surfaces[surfaceId];
    if (surface && focusedSurface === surface) {
      this._state.focusedSurfaceId = null;
    }
  }
};

SurfaceManager.prototype._onSelectionChanged = function _onSelectionChanged (selection) {
  var state = this._state;
  state.selection = selection;
  state.focusedSurfaceId = selection.surfaceId;
  
  
  
  if (selection && selection.isCustomSelection() && platform.inBrowser) {
    window.getSelection().removeAllRanges();
    window.document.activeElement.blur();
  }
};

SurfaceManager.prototype._recoverDOMSelection = function _recoverDOMSelection () {
  
  
  var info = this.editorSession.getChangeInfo() || {};
  if (info.skipSelectionRerender) { return }

  var focusedSurface = this.getFocusedSurface();
  if (focusedSurface && !focusedSurface.isDisabled()) {
    
    focusedSurface.focus();
    focusedSurface.rerenderDOMSelection();
  }
};

var EditorSession = (function (EventEmitter$$1) {
  function EditorSession(doc, options) {
    EventEmitter$$1.call(this);

    options = options || {};

    this.document = doc;
    if (!options.configurator) {
      throw new Error('No configurator provided.')
    }
    this.configurator = options.configurator;

    this._transaction = new Transaction(doc, this);

    this._history = new ChangeHistory();
    
    this._currentChange = null;

    
    
    
    
    this._selectionState = new SelectionState(doc);

    this._commandStates = [];

    
    this._resources = ['document', 'selection', 'commandStates'];
    
    this._dirtyFlags = {};
    
    this._change = null;
    this._info = null;

    this._flowStages = ['update', 'pre-render', 'render', 'post-render', 'position', 'finalize'];
    
    this._postponed = [];

    this._observers = {};

    this._lang = options.lang || this.configurator.getDefaultLanguage();
    this._dir = options.dir || 'ltr';

    
    

    
    
    this.surfaceManager = new SurfaceManager(this);
    
    this._context = {
      editorSession: this,
      
      surfaceManager: this.surfaceManager,
    };
    
    if (options.context) {
      Object.assign(this._context, options.context);
    }

    var configurator = this.configurator;
    var commands = configurator.getCommands();
    var dropHandlers = configurator.getDropHandlers();
    var macros = configurator.getMacros();
    var converterRegistry = configurator.getConverterRegistry();
    var editingBehavior = configurator.getEditingBehavior();

    this.fileManager = options.fileManager || new FileManager(this, configurator.getFileAdapters(), this._context);

    
    this._hasUnsavedChanges = false;
    this._isSaving = false;

    if (options.saveHandler) {
      this.saveHandler = options.saveHandler;
    } else {
      this.saveHandler = configurator.getSaveHandler();
    }

    
    this.commandManager = new CommandManager(this._context, commands);
    
    
    this.dragManager = new DragManager(dropHandlers, Object.assign({}, this._context, {
      commandManager: this.commandManager
    }));
    
    this.macroManager = new MacroManager(this._context, macros);
    this.globalEventHandler = new GlobalEventHandler(this, this.surfaceManager);
    this.markersManager = new MarkersManager(this);
    this.keyboardManager = new KeyboardManager(this, configurator.getKeyboardShortcuts(), {
      context: this._context
    });

    
    this.converterRegistry = converterRegistry;
    this.editingBehavior = editingBehavior;
  }

  if ( EventEmitter$$1 ) EditorSession.__proto__ = EventEmitter$$1;
  EditorSession.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  EditorSession.prototype.constructor = EditorSession;

  EditorSession.prototype.dispose = function dispose () {
    this._transaction.dispose();
    this.surfaceManager.dispose();
    this.fileManager.dispose();
    this.commandManager.dispose();
    this.dragManager.dispose();
    this.macroManager.dispose();
    this.globalEventHandler.dispose();
    this.markersManager.dispose();
  };

  EditorSession.prototype.hasChanged = function hasChanged (resource) {
    return this._dirtyFlags[resource]
  };

  EditorSession.prototype.hasDocumentChanged = function hasDocumentChanged () {
    return this.hasChanged('document')
  };

  EditorSession.prototype.hasSelectionChanged = function hasSelectionChanged () {
    return this.hasChanged('selection')
  };

  EditorSession.prototype.hasCommandStatesChanged = function hasCommandStatesChanged () {
    return this.hasChanged('commandStates')
  };

  EditorSession.prototype.hasLanguageChanged = function hasLanguageChanged () {
    return this.hasChanged('lang')
  };

  EditorSession.prototype.hasTextDirectionChanged = function hasTextDirectionChanged () {
    return this.hasChanged('dir')
  };

  EditorSession.prototype.get = function get (resourceName) {
    switch(resourceName) {
      case 'document':
        return this.getDocument()
      case 'selection':
        return this.getSelection()
      case 'commandStates':
        return this.getCommandStates()
      case 'change':
        return this.getChange()
      default:
        throw new Error('Unknown resource: ' + resourceName)
    }
  };

  EditorSession.prototype.getConfigurator = function getConfigurator () {
    return this.configurator
  };

  EditorSession.prototype.getContext = function getContext () {
    return this._context
  };

  EditorSession.prototype.getDocument = function getDocument () {
    return this.document
  };

  EditorSession.prototype.getSelection = function getSelection () {
    return this.getSelectionState().getSelection()
  };

  EditorSession.prototype.getSelectionState = function getSelectionState () {
    return this._selectionState
  };

  EditorSession.prototype.getCommandStates = function getCommandStates () {
    return this._commandStates
  };

  EditorSession.prototype.getChange = function getChange () {
    return this._change
  };

  EditorSession.prototype.getChangeInfo = function getChangeInfo () {
    return this._info
  };

  EditorSession.prototype.getFocusedSurface = function getFocusedSurface () {
    return this.surfaceManager.getFocusedSurface()
  };

  EditorSession.prototype.getSurface = function getSurface (surfaceId) {
    return this.surfaceManager.getSurface(surfaceId)
  };

  EditorSession.prototype.getLanguage = function getLanguage () {
    return this._lang
  };

  EditorSession.prototype.getTextDirection = function getTextDirection () {
    return this._dir
  };

  EditorSession.prototype.canUndo = function canUndo () {
    return this._history.canUndo()
  };

  EditorSession.prototype.canRedo = function canRedo () {
    return this._history.canRedo()
  };

  EditorSession.prototype.executeCommand = function executeCommand () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    (ref = this.commandManager).executeCommand.apply(ref, args);
    var ref;
  };

  EditorSession.prototype.setSelection = function setSelection (sel) {
    
    if (sel && isPlainObject$1(sel)) {
      sel = this.getDocument().createSelection(sel);
    }
    if (sel && !sel.isNull() && !sel.surfaceId) {
      var fs = this.getFocusedSurface();
      if (fs) {
        sel.surfaceId = fs.id;
      }
    }
    if (this._setSelection(sel)) {
      this.startFlow();
    }
    return sel
  };

  EditorSession.prototype.selectNode = function selectNode (nodeId) {
    var surface = this.getFocusedSurface();
    this.setSelection({
      type: 'node',
      nodeId: nodeId,
      containerId: surface.getContainerId(),
      surfaceId: surface.id
    });
  };

  EditorSession.prototype.setCommandStates = function setCommandStates (commandStates) {
    this._commandStates = commandStates;
    this._setDirty('commandStates');
  };

  EditorSession.prototype.setLanguage = function setLanguage (lang) {
    if (this._lang !== lang) {
      this._lang = lang;
      this._setDirty('lang');
      this.startFlow();
    }
  };

  EditorSession.prototype.setTextDirection = function setTextDirection (dir) {
    if (this._dir !== dir) {
      this._dir = dir;
      this._setDirty('dir');
      this.startFlow();
    }
  };

  EditorSession.prototype.createSelection = function createSelection () {
    var doc = this.getDocument();
    return doc.createSelection.apply(doc, arguments)
  };

  EditorSession.prototype.getCollaborators = function getCollaborators () {
    return null
  };

  
  EditorSession.prototype.setSaveHandler = function setSaveHandler (saveHandler) {
    this.saveHandler = saveHandler;
  };

  
  EditorSession.prototype.transaction = function transaction (transformation, info) {
    info = info || {};
    var change = this._transaction._recordChange(transformation, this.getSelection(), this.getFocusedSurface());
    if (change) {
      this._commit(change, info);
    } else {
      
      this._setSelection(this._transaction.getSelection());
      this.startFlow();
    }
    return change
  };

  EditorSession.prototype.undo = function undo () {
    this._undoRedo('undo');
  };

  EditorSession.prototype.redo = function redo () {
    this._undoRedo('redo');
  };



  EditorSession.prototype.on = function on () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var name = args[0];
    if (this._flowStages.indexOf(name) >= 0) {
      
      args.shift();
      var options = args[2] || {};
      var resource = options.resource;
      if (resource) {
        delete options.resource;
        args.unshift(resource);
      }
      this._registerObserver(name, args);
    } else {
      EventEmitter$$1.prototype.on.apply(this, args);
    }
  };

  EditorSession.prototype.off = function off () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    if (args.length === 1) {
      EventEmitter$$1.prototype.off.apply(this, args);
    } else {
      var stage = args[0];
      var method = args[1];
      var observer = args[2];
      this._deregisterObserver(stage, method, observer);
    }
  };

  
  EditorSession.prototype.onUpdate = function onUpdate () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return this._registerObserver('update', args)
  };

  EditorSession.prototype.onPreRender = function onPreRender () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return this._registerObserver('pre-render', args)
  };

  
  EditorSession.prototype.onRender = function onRender () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return this._registerObserver('render', args)
  };

  
  EditorSession.prototype.onPostRender = function onPostRender () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return this._registerObserver('post-render', args)
  };

  
  EditorSession.prototype.onPosition = function onPosition () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return this._registerObserver('position', args)
  };

  EditorSession.prototype.onFinalize = function onFinalize () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return this._registerObserver('finalize', args)
  };

  EditorSession.prototype._setSelection = function _setSelection (sel) {
    var hasChanged = this.getSelectionState().setSelection(sel);
    if (hasChanged) { this._setDirty('selection'); }
    return hasChanged
  };

  EditorSession.prototype._undoRedo = function _undoRedo (which) {
    var doc = this.getDocument();
    var from, to;
    if (which === 'redo') {
      from = this._history.undoneChanges;
      to = this._history.doneChanges;
    } else {
      from = this._history.doneChanges;
      to = this._history.undoneChanges;
    }
    var change = from.pop();
    if (change) {
      this._applyChange(change, {});
      
      to.push(change.invert());
      
      var sel = change.after.selection;
      if (sel) { sel.attach(doc); }
      this._setSelection(sel);
      
      this.startFlow();
    } else {
      console.warn('No change can be %s.', (which === 'undo'? 'undone':'redone'));
    }
  };

  EditorSession.prototype._transformLocalChangeHistory = function _transformLocalChangeHistory (externalChange) {
    
    
    
    
    var clone$$1 = {
      ops: externalChange.ops.map(function(op) { return op.clone(); })
    };
    transformDocumentChange(clone$$1, this._history.doneChanges);
    transformDocumentChange(clone$$1, this._history.undoneChanges);
  };

  EditorSession.prototype._transformSelection = function _transformSelection (change) {
    var oldSelection = this.getSelection();
    var newSelection = transformSelection(oldSelection, change);
    
    return newSelection
  };

  EditorSession.prototype._commit = function _commit (change, info) {
    this._commitChange(change, info);
    
    this._hasUnsavedChanges = true;
    this.startFlow();
  };

  EditorSession.prototype._commitChange = function _commitChange (change, info) {
    change.timestamp = Date.now();
    this._transaction._document._skipNextDocumentChange = true;
    this._applyChange(change, info);
    if (info['history'] !== false && !info['hidden']) {
      this._history.push(change.invert());
    }
    var newSelection = change.after.selection || Selection.nullSelection;
    
    
    if (!newSelection.isNull() && !newSelection.surfaceId) {
      newSelection.surfaceId = change.after.surfaceId;
    }
    this._setSelection(newSelection);
  };

  EditorSession.prototype._applyChange = function _applyChange (change, info) {
    if (!change) {
      console.error('FIXME: change is null.');
      return
    }
    var doc = this.getDocument();
    doc._apply(change);
    doc._notifyChangeListeners(change, info);
    this._setDirty('document');
    this._change = change;
    this._info = info;
  };

  
  EditorSession.prototype.hasUnsavedChanges = function hasUnsavedChanges () {
    return this._hasUnsavedChanges
  };

  
  EditorSession.prototype.save = function save () {
    var this$1 = this;

    var saveHandler = this.saveHandler;

    if (this._hasUnsavedChanges && !this._isSaving) {
      this._isSaving = true;
      
      if (saveHandler) {
        var saveParams = {
          editorSession: this,
          fileManager: this.fileManager
        };
        return saveHandler.saveDocument(saveParams)
        .then(function () {
          this$1._hasUnsavedChanges = false;
          
          
          
          
          this$1.setSelection(this$1.getSelection());
        })
        .catch(function (err) {
          console.error('Error during save', err);
        }).then(function () { 
          this$1._isSaving = false;
        })
      } else {
        console.error('Document saving is not handled at the moment. Make sure saveHandler instance provided to editorSession');
        return Promise.reject()
      }
    }
  };

  
  EditorSession.prototype.startFlow = function startFlow () {
    if (this._flowing) {
      throw new Error('Already in a flow. You need to postpone the update.')
    }
    this._flowing = true;
    try {
      this.performFlow();
    } finally {
      this._resetFlow();
      this._flowing = false;
    }
    
    
    
    var postponed = this._postponed;
    var self = this;
    this._postponed = [];
    setTimeout(function() {
      postponed.forEach(function(fn) {
        fn(self);
      });
    }, 0);
  };

  
  EditorSession.prototype.performFlow = function performFlow () {
    var this$1 = this;

    this._flowStages.forEach(function (stage) {
      this$1._notifyObservers(stage);
    });
  };

  EditorSession.prototype.postpone = function postpone (fn) {
    this._postponed.push(fn);
  };

  EditorSession.prototype._parseObserverArgs = function _parseObserverArgs (args) {
    var params = { resource: null, handler: null, context: null, options: {} };
    
    var idx = 0;
    var arg = args[idx];
    if (isString$1(arg)) {
      params.resource = arg;
      idx++;
      arg = args[idx];
    }
    if (!arg) {
      throw new Error('Provided handler function was nil.')
    }
    if (!isFunction$1(arg)) {
      throw new Error('Expecting a handler Function.')
    }
    params.handler = arg;
    idx++;
    arg = args[idx];
    if (arg) {
      params.context = arg;
      idx++;
      arg = args[idx];
    }
    if (arg) {
      params.options = arg;
    }
    return params
  };

  EditorSession.prototype._registerObserver = function _registerObserver (stage, args) {
    var observer = this._parseObserverArgs(args);
    var observers = this._observers[stage];
    if (!observers) {
      observers = this._observers[stage] = [];
    }
    observers.push(observer);
  };

  EditorSession.prototype._deregisterObserver = function _deregisterObserver (stage, method, observer) {
    var self = this; 
    if (arguments.length === 1) {
      
      
      forEach(self._observers, function (observers) {
        for (var i = observers.length-1; i >=0 ; i--) {
          var o = observers[i];
          if (o.context === observer) {
            observers.splice(i, 1);
            o._deregistered = true;
          }
        }
      });
    } else {
      var observers = self._observers[stage];
      
      
      if (!observers) {
        EventEmitter$$1.prototype.off.apply(self, arguments);
      } else {
        for (var i = observers.length-1; i >= 0; i--) {
          var o = observers[i];
          if (o.handler === method && o.context === observer) {
            observers.splice(i, 1);
            o._deregistered = true;
          }
        }
      }
    }
  };

  EditorSession.prototype._notifyObservers = function _notifyObservers (stage) {
    var this$1 = this;

    
    
    
    
    
    
    var _observers = this._observers[stage];
    if (!_observers) { return }
    
    
    
    var observers = _observers.slice();
    for (var i = 0; i < observers.length; i++) {
      var o = observers[i];
      
      if (o._deregistered) { continue }
      if (!o.resource) {
        o.handler.call(o.context, this$1);
      } else if (o.resource === 'document') {
        if (!this$1.hasDocumentChanged()) { continue }
        var change = this$1.getChange();
        var info = this$1.getChangeInfo();
        var path = o.options.path;
        if (!path) {
          o.handler.call(o.context, change, info, this$1);
        } else if (change.isAffected(path)) {
          o.handler.call(o.context, change, info, this$1);
        }
      } else {
        if (!this$1.hasChanged(o.resource)) { continue }
        var resource = this$1.get(o.resource);
        o.handler.call(o.context, resource, this$1);
      }
    }
  };

  EditorSession.prototype._setDirty = function _setDirty (resource) {
    this._dirtyFlags[resource] = true;
  };

  EditorSession.prototype._resetFlow = function _resetFlow () {
    var this$1 = this;

    Object.keys(this._dirtyFlags).forEach(function (resource) {
      this$1._dirtyFlags[resource] = false;
    });
    this._change = null;
    this._info = null;
  };

  return EditorSession;
}(EventEmitter));

var Highlights = (function (EventEmitter$$1) {
  function Highlights(doc) {
    EventEmitter$$1.call(this);

    this.doc = doc;
    this._highlights = {};
  }

  if ( EventEmitter$$1 ) Highlights.__proto__ = EventEmitter$$1;
  Highlights.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  Highlights.prototype.constructor = Highlights;

  
  Highlights.prototype.get = function get () {
    return this._highlights
  };

  
  Highlights.prototype.set = function set (highlights) {
    var oldHighlights = this._highlights;
    var doc = this.doc;
    
    forEach(highlights, function(newScopedHighlights, scope) {
      var oldScopedHighlights = oldHighlights[scope] || [];

      
      
      
      var toBeDeleted = without(oldScopedHighlights, newScopedHighlights);
      var toBeAdded = without(newScopedHighlights, oldScopedHighlights);

      
      forEach(toBeDeleted, function(nodeId) {
        var node = doc.get(nodeId);
        
        if (node) {
          node.setHighlighted(false, scope);
        }
      });

      forEach(toBeAdded, function(nodeId) {
        var node = doc.get(nodeId);
        if (node) {
          node.setHighlighted(true, scope);
        }
      });
    });

    this._highlights = highlights;

    
    this.emit('highlights:updated', highlights);
  };

  return Highlights;
}(EventEmitter));

var InsertInlineNodeCommand = (function (Command$$1) {
  function InsertInlineNodeCommand() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Command$$1.apply(this, args);

    if (!this.config.nodeType) {
      throw new Error('Every InlineInlineNodeCommand must have a nodeType')
    }
  }

  if ( Command$$1 ) InsertInlineNodeCommand.__proto__ = Command$$1;
  InsertInlineNodeCommand.prototype = Object.create( Command$$1 && Command$$1.prototype );
  InsertInlineNodeCommand.prototype.constructor = InsertInlineNodeCommand;

  
  InsertInlineNodeCommand.prototype.getCommandState = function getCommandState (params) {
    var newState = {
      disabled: this.isDisabled(params),
      active: false
    };
    return newState
  };

  InsertInlineNodeCommand.prototype.isDisabled = function isDisabled (params) {
    var sel = params.selection;
    var selectionState = params.editorSession.getSelectionState();
    if (!sel.isPropertySelection()) {
      return true
    }
    if (this.config.disableCollapsedCursor && sel.isCollapsed()) {
      return true
    }

    
    
    if (selectionState.isInlineNodeSelection()) {
      return true
    }
    return false
  };

  
  InsertInlineNodeCommand.prototype.execute = function execute (params) {
    var this$1 = this;

    var state = this.getCommandState(params);
    if (state.disabled) { return }
    var editorSession = this._getEditorSession(params);
    editorSession.transaction(function (tx) {
      var nodeData = this$1.createNodeData(tx, params);
      tx.insertInlineNode(nodeData);
    });
  };

  InsertInlineNodeCommand.prototype.createNodeData = function createNodeData (tx) { 
    return {
      type: this.config.nodeType
    }
  };

  return InsertInlineNodeCommand;
}(Command));

var InsertNodeCommand = (function (Command$$1) {
  function InsertNodeCommand () {
    Command$$1.apply(this, arguments);
  }

  if ( Command$$1 ) InsertNodeCommand.__proto__ = Command$$1;
  InsertNodeCommand.prototype = Object.create( Command$$1 && Command$$1.prototype );
  InsertNodeCommand.prototype.constructor = InsertNodeCommand;

  InsertNodeCommand.prototype.getCommandState = function getCommandState (params) {
    var sel = params.selection;
    var newState = {
      disabled: true,
      active: false
    };
    if (sel && !sel.isNull() && !sel.isCustomSelection() && sel.containerId) {
      newState.disabled = false;
    }
    return newState
  };

  InsertNodeCommand.prototype.execute = function execute (params, context) {
    var this$1 = this;

    var state = params.commandState;
    if (state.disabled) { return }
    var editorSession = this._getEditorSession(params, context);
    editorSession.transaction(function (tx) {
      var nodeData = this$1.createNodeData(tx, params, context);
      var node = tx.insertBlockNode(nodeData);
      this$1.setSelection(tx, node);
    });
  };

  InsertNodeCommand.prototype.createNodeData = function createNodeData (tx, params, context) {
    var type = params.type;
    if (!type) { throw new Error("'type' is mandatory") }
    var doc = context.editorSession.getDocument();
    var nodeSchema = doc.getSchema().getNodeSchema(type);
    var nodeData = {type: type};
    forEach(nodeSchema, function (key) {
      if (params.hasOwnProperty(key)) {
        nodeData[key] = params[key];
      }
    });
    return nodeData
  };

  InsertNodeCommand.prototype.setSelection = function setSelection (tx, node) {
    if (node.isText()) {
      tx.selection = {
        type: 'property',
        path: node.getPath(),
        startOffset: 0
      };
    }
  };

  return InsertNodeCommand;
}(Command));

var Toolbox = (function (Component$$1) {
  function Toolbox () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Toolbox.__proto__ = Component$$1;
  Toolbox.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Toolbox.prototype.constructor = Toolbox;

  Toolbox.prototype.getInitialState = function getInitialState () {
    return {
      activeToolGroups: this.getActiveToolGroups()
    }
  };

  
  
  
  
  
  
  
  
  
  
  
  
  

  Toolbox.prototype.didMount = function didMount () {
    
    this.context.editorSession.onRender(this._onCommandStatesChanged, this);
  };

  Toolbox.prototype.dispose = function dispose () {
    this.context.editorSession.off(this);
  };

  Toolbox.prototype._onCommandStatesChanged = function _onCommandStatesChanged (editorSession) {
    if (editorSession.hasChanged('commandStates')) {
      this.setState({
        activeToolGroups: this.getActiveToolGroups()
      });
    }
  };

  
  Toolbox.prototype.getActiveToolGroups = function getActiveToolGroups () {
    var this$1 = this;

    this._hasActiveTools = false;

    var toolGroups = this.context.toolGroups;
    var activeToolGroupNames = this.getActiveToolGroupNames();
    var activeToolGroups = new Map();

    activeToolGroupNames.forEach(function (toolGroupName) {
      var toolGroup = toolGroups.get(toolGroupName);
      if (!toolGroup) { return }
      var tools = toolGroup.tools;
      var activeTools = this$1.getActiveTools(tools, toolGroupName);
      activeToolGroups.set(toolGroupName, {
        name: toolGroupName,
        Class: toolGroup.Class,
        tools: activeTools
      });
    });
    return activeToolGroups
  };

  
  Toolbox.prototype.getActiveTools = function getActiveTools (tools, toolGroupName) {
    var this$1 = this;
 
    var activeTools = new Map();
    var commandStates = this._getCommandStates();

    tools.forEach(function (tool, toolName) {
      var toolProps = Object.assign(
        { disabled: true },
        commandStates[toolName],
        {
          name: toolName,
          label: toolName,
          
          style: this$1.getToolStyle(toolName)
        }
      );

      if (!toolProps.disabled || this$1.showDisabled()) {
        activeTools.set(tool.name, {
          name: tool.name,
          Class: tool.Class,
          toolProps: toolProps
        });
        this$1._hasActiveTools = true;
      }
    });

    return activeTools
  };

  Toolbox.prototype.hasActiveTools = function hasActiveTools () {
    return Boolean(this._hasActiveTools)
  };

  Toolbox.prototype.getActiveToolGroupNames = function getActiveToolGroupNames () {
    throw new Error('Abstract method')
  };

  Toolbox.prototype.showDisabled = function showDisabled () {
    return false
  };

  Toolbox.prototype.hide = function hide () {
    
  };

  
  Toolbox.prototype.getToolStyle = function getToolStyle () {
    throw new Error('Abstract method')
  };

  Toolbox.prototype._getCommandStates = function _getCommandStates () {
    return this.context.commandManager.getCommandStates()
  };

  return Toolbox;
}(Component));

var Overlay = (function (Toolbox$$1) {
  function Overlay () {
    Toolbox$$1.apply(this, arguments);
  }

  if ( Toolbox$$1 ) Overlay.__proto__ = Toolbox$$1;
  Overlay.prototype = Object.create( Toolbox$$1 && Toolbox$$1.prototype );
  Overlay.prototype.constructor = Overlay;

  Overlay.prototype.didMount = function didMount () {
    Toolbox$$1.prototype.didMount.call(this);
    if (!this.context.scrollPane) {
      throw new Error('Requires scrollPane context')
    }
    this.context.scrollPane.on('selection:positioned', this._onSelectionPositioned, this);
  };

  Overlay.prototype.dispose = function dispose () {
    Toolbox$$1.prototype.dispose.call(this);
    this.context.scrollPane.off(this);
  };

  Overlay.prototype.render = function render ($$) {
    var this$1 = this;

    var el = $$('div').addClass(this.getClassNames());
    el.addClass('sm-hidden');
    el.addClass('sm-theme-'+this.getTheme());
    var activeToolGroups = this.state.activeToolGroups;
    var activeToolsEl = $$('div').addClass('se-active-tools');

    activeToolGroups.forEach(function (toolGroup) {
      var toolGroupProps = Object.assign({}, toolGroup, {
        toolStyle: this$1.getToolStyle(),
        showIcons: true
      });
      activeToolsEl.append(
        $$(toolGroup.Class, toolGroupProps).ref(toolGroup.name)
      );
    });

    el.append(activeToolsEl);
    return el
  };

  Overlay.prototype.getToolStyle = function getToolStyle () {
    return this.props.theme || 'plain-dark'
  };

  Overlay.prototype.show = function show (hints) {
    this.el.removeClass('sm-hidden');
    this._position(hints);
  };

  Overlay.prototype.hide = function hide () {
    this.el.addClass('sm-hidden');
  };

  Overlay.prototype._onSelectionPositioned = function _onSelectionPositioned (hints) {
    if (this.hasActiveTools()) {
      this.el.removeClass('sm-hidden');
      var overlayWidth = this.el.htmlProp('offsetWidth');
      var selRect = hints.selectionRect;
      var selectionMaxWidth = selRect.width;
      
      this.el.css('top', selRect.top + selRect.height);
      var leftPos = selRect.left + selectionMaxWidth/2 - overlayWidth/2;
      
      leftPos = Math.max(leftPos, 0);
      
      var maxLeftPos = selRect.left + selectionMaxWidth + selRect.right - overlayWidth;
      leftPos = Math.min(leftPos, maxLeftPos);
      this.el.css('left', leftPos);
    } else {
      this.el.addClass('sm-hidden');
    }
  };

  Overlay.prototype.getClassNames = function getClassNames () {
    return 'sc-overlay'
  };

  Overlay.prototype.getTheme = function getTheme () {
    return 'dark'
  };

  Overlay.prototype.getActiveToolGroupNames = function getActiveToolGroupNames () {
    return this.props.toolGroups || ['overlay']
  };

  return Overlay;
}(Toolbox));

var ResponsiveApplication = (function (Component$$1) {
  function ResponsiveApplication() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Component$$1.apply(this, args);

    this.pages = {};

    this.handleActions({
      'navigate': this.navigate
    });
  }

  if ( Component$$1 ) ResponsiveApplication.__proto__ = Component$$1;
  ResponsiveApplication.prototype = Object.create( Component$$1 && Component$$1.prototype );
  ResponsiveApplication.prototype.constructor = ResponsiveApplication;

  ResponsiveApplication.prototype.getInitialState = function getInitialState () {
    return {
      route: undefined,
      mobile: this._isMobile()
    }
  };

  ResponsiveApplication.prototype.didMount = function didMount () {
    if (platform.inBrowser) {
      var _window = DefaultDOMElement.getBrowserWindow();
      _window.on('resize', this._onResize, this);
    }
    this.router = this.getRouter();
    this.router.on('route:changed', this._onRouteChanged, this);
    var route = this.router.readRoute();
    
    
    this.navigate(route, {replace: true});
  };

  ResponsiveApplication.prototype.dispose = function dispose () {
    this.router.off(this);
    this.router.dispose();
  };

  
  ResponsiveApplication.prototype.navigate = function navigate (route, opts) {
    this.extendState({
      route: route
    });
    this.router.writeRoute(route, opts);
  };

  ResponsiveApplication.prototype._onRouteChanged = function _onRouteChanged (route) {
    
    this.navigate(route, {replace: true});
  };

  ResponsiveApplication.prototype._isMobile = function _isMobile () {
    if (platform.inBrowser) {
      return window.innerWidth < 700
    }
  };

  ResponsiveApplication.prototype._onResize = function _onResize () {
    if (this._isMobile()) {
      
      if (!this.state.mobile) {
        this.extendState({
          mobile: true
        });
      }
    } else {
      if (this.state.mobile) {
        this.extendState({
          mobile: false
        });
      }
    }
  };

  ResponsiveApplication.prototype._getPage = function _getPage () {
    return this.state.route.page || this.getDefaultPage()
  };

  ResponsiveApplication.prototype._getPageClass = function _getPageClass () {
    var page = this._getPage();
    return this.pages[page]
  };

  ResponsiveApplication.prototype._getPageProps = function _getPageProps () {
    var props = cloneDeep(this.state.route);
    delete props.page;
    props.mobile = this.state.mobile;
    return props
  };

  ResponsiveApplication.prototype.addPage = function addPage (pageName, PageClass) {
    this.pages[pageName] = PageClass;
  };

  ResponsiveApplication.prototype.renderPage = function renderPage ($$) {
    var PageClass = this._getPageClass();
    var pageName = this._getPage();
    return $$(PageClass, this._getPageProps()).ref(pageName)
  };

  ResponsiveApplication.prototype.render = function render ($$) {
    var el = $$('div').addClass('sc-responsive-application');

    if (this.state.route === undefined) {
      
      return el
    }

    el.append(
      this.renderPage($$)
    );

    return el
  };

  return ResponsiveApplication;
}(Component));

var Router = (function (EventEmitter$$1) {
  function Router() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    EventEmitter$$1.apply(this, args);
    this.__isStarted__ = false;
  }

  if ( EventEmitter$$1 ) Router.__proto__ = EventEmitter$$1;
  Router.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  Router.prototype.constructor = Router;

  
  Router.prototype.start = function start () {
    var window = DefaultDOMElement.getBrowserWindow();
    window.on('hashchange', this._onHashChange, this);
    this.__isStarted__ = true;
  };

  
  Router.prototype.readRoute = function readRoute () {
    if (!this.__isStarted__) { this.start(); }
    return this.parseRoute(this.getRouteString())
  };

  
  Router.prototype.writeRoute = function writeRoute (route, opts) {
    opts = opts || {};
    var routeString = this.stringifyRoute(route);
    if (!routeString) {
      this.clearRoute(opts);
    } else {
      this._writeRoute(routeString, opts);
    }
  };

  Router.prototype.dispose = function dispose () {
    var window = DefaultDOMElement.getBrowserWindow();
    window.off(this);
  };

  
  Router.prototype.parseRoute = function parseRoute (routeString) {
    return Router.routeStringToObject(routeString)
  };

  
  Router.prototype.stringifyRoute = function stringifyRoute (route) {
    return Router.objectToRouteString(route)
  };

  Router.prototype.getRouteString = function getRouteString () {
    return window.location.hash.slice(1)
  };

  Router.prototype._writeRoute = function _writeRoute (route, opts) {
    this.__isSaving__ = true;
    try {
      if (opts.replace) {
        window.history.replaceState({} , '', '#'+route);
      } else {
        window.history.pushState({} , '', '#'+route);
      }
    } finally {
      this.__isSaving__ = false;
    }
  };

  Router.prototype.clearRoute = function clearRoute (opts) {
    this._writeRoute('', opts);
  };

  Router.prototype._onHashChange = function _onHashChange () {
    
    if (this.__isSaving__) {
      return
    }
    if (this.__isLoading__) {
      console.error('FIXME: router is currently applying a route.');
      return
    }
    this.__isLoading__ = true;
    try {
      var routeString = this.getRouteString();
      var route = this.parseRoute(routeString);
      this.emit('route:changed', route);
    } finally {
      this.__isLoading__ = false;
    }
  };

  return Router;
}(EventEmitter));

Router.objectToRouteString = function(obj) {
  var route = [];
  forEach(obj, function(val, key) {
    route.push(key+'='+val);
  });
  return route.join(',')
};

Router.routeStringToObject = function(routeStr) {
  var obj = {};
  
  if (!routeStr) { return obj }
  var params = routeStr.split(',');
  params.forEach(function(param) {
    var tuple = param.split('=');
    if (tuple.length !== 2) {
      throw new Error('Illegal route.')
    }
    obj[tuple[0].trim()] = tuple[1].trim();
  });
  return obj
};

var TextBlockComponent = (function (NodeComponent$$1) {
  function TextBlockComponent () {
    NodeComponent$$1.apply(this, arguments);
  }

  if ( NodeComponent$$1 ) TextBlockComponent.__proto__ = NodeComponent$$1;
  TextBlockComponent.prototype = Object.create( NodeComponent$$1 && NodeComponent$$1.prototype );
  TextBlockComponent.prototype.constructor = TextBlockComponent;

  TextBlockComponent.prototype.didMount = function didMount () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    NodeComponent$$1.prototype.didMount.apply(this, args);

    var node = this.props.node;
    this.context.editorSession.onRender('document', this.rerender, this, {
      path: [node.id, 'textAlign']
    });
  };

  TextBlockComponent.prototype.dispose = function dispose () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    NodeComponent$$1.prototype.dispose.apply(this, args);
    this.context.editorSession.off(this);
  };

  TextBlockComponent.prototype.render = function render ($$) {
    var el = NodeComponent$$1.prototype.render.call(this, $$);
    el.addClass('sc-text-block');

    var node = this.props.node;
    
    
    if (node.direction) {
      
      el.attr('dir', node.direction);
    }
    if (node.textAlign) {
      el.addClass('sm-align-'+node.textAlign);
    }
    el.append($$(TextPropertyComponent, {
      path: node.getTextPath(),
      direction: node.direction
    }));
    return el
  };

  return TextBlockComponent;
}(NodeComponent));

var TextPropertyEditor = (function (Surface$$1) {
  function TextPropertyEditor(parent, props) {
    
    props.name = props.name || props.path.join('.');
    Surface$$1.call(this, parent, props);

    if (!props.path) {
      throw new Error("Property 'path' is mandatory.")
    }
  }

  if ( Surface$$1 ) TextPropertyEditor.__proto__ = Surface$$1;
  TextPropertyEditor.prototype = Object.create( Surface$$1 && Surface$$1.prototype );
  TextPropertyEditor.prototype.constructor = TextPropertyEditor;

  TextPropertyEditor.prototype.render = function render ($$) {
    var el = Surface$$1.prototype.render.apply(this, arguments);
    el.addClass("sc-text-property-editor");

    if (!this.props.disabled) {
      el.addClass('sm-enabled');
      el.attr('contenteditable', true);
      
      el.attr('spellcheck', this.props.spellcheck === 'native');
    }

    el.append(
      $$(TextPropertyComponent, {
        tagName: this.props.tagName || "div",
        path: this.props.path,
        markers: this.props.markers,
        withoutBreak: this.props.withoutBreak
      })
    );

    return el
  };

  TextPropertyEditor.prototype._handleEnterKey = function _handleEnterKey (event) {
    event.preventDefault();
    event.stopPropagation();
    if (this.props.multiLine) {
      Surface$$1.prototype._handleEnterKey.call(this, event);
    }
    this.el.emit('enter', {
      altKey: event.altKey,
      ctrlKey: event.ctrlKey,
      metaKey: event.metaKey,
      shiftKey: event.shiftKey,
      code: event.code
    });
  };

  TextPropertyEditor.prototype.getPath = function getPath () {
    return this.props.path
  };

  return TextPropertyEditor;
}(Surface));

TextPropertyEditor.prototype._isTextPropertyEditor = true;

var CollabSession = (function (EditorSession$$1) {
  function CollabSession(doc, config) {
    EditorSession$$1.call(this, doc, config);
    config = config || {};
    this.config = config;
    this.collabClient = config.collabClient;
    if (config.docVersion) {
      console.warn('config.docVersion is deprecated: Use config.version instead');
    }
    if (config.docVersion) {
      console.warn('config.docId is deprecated: Use config.documentId instead');
    }
    this.version = config.version;
    this.documentId = config.documentId || config.docId;
    if (config.autoSync !== undefined) {
      this.autoSync = config.autoSync;
    } else {
      this.autoSync = true;
    }
    if (!this.documentId) {
      throw new SubstanceError('InvalidArgumentsError', {message: 'documentId is mandatory'})
    }
    if (typeof this.version === undefined) {
      throw new SubstanceError('InvalidArgumentsError', {message: 'version is mandatory'})
    }
    
    this._connected = false; 
    this._nextChange = null; 
    this._pendingChange = null; 
    this._pendingSync = false;
    this._error = null;
    
    this.onUpdate('document', this.afterDocumentChange, this);
    
    this.collabClient.on('connected', this.onCollabClientConnected, this);
    this.collabClient.on('disconnected', this.onCollabClientDisconnected, this);
    this.collabClient.on('message', this._onMessage.bind(this));
    
    
    
    if (this.collabClient.isConnected() && this.autoSync) {
      this.sync();
    }
  }

  if ( EditorSession$$1 ) CollabSession.__proto__ = EditorSession$$1;
  CollabSession.prototype = Object.create( EditorSession$$1 && EditorSession$$1.prototype );
  CollabSession.prototype.constructor = CollabSession;

  
  CollabSession.prototype.dispose = function dispose () {
    this.disconnect();
    this.collabClient.off(this);
  };

  
  CollabSession.prototype.disconnect = function disconnect () {
    
    var msg = {
      type: 'disconnect',
      documentId: this.documentId
    };
    
    this._abortSync();
    this._send(msg);
  };

  
  CollabSession.prototype.sync = function sync () {
    
    if (this.__canSync()) {
      var nextChange = this._nextChange;
      var msg = {
        type: 'sync',
        documentId: this.documentId,
        version: this.version,
        change: nextChange ? this.serializeChange(nextChange) : undefined
      };
      this._send(msg);
      this._pendingSync = true;
      this._pendingChange = nextChange;

      
      
      this.emit('sync');
      this._nextChange = null;
      this._error = null;
    } else {
      console.error('Can not sync. Either collabClient is not connected or already syncing');
    }
  };

  CollabSession.prototype.getCollaborators = function getCollaborators () {
    return this.collaborators
  };

  CollabSession.prototype.isConnected = function isConnected () {
    return this._connected
  };

  CollabSession.prototype.serializeChange = function serializeChange (change) {
    return change.toJSON()
  };

  CollabSession.prototype.deserializeChange = function deserializeChange (serializedChange) {
    return DocumentChange.fromJSON(serializedChange)
  };

  

  
  CollabSession.prototype._onMessage = function _onMessage (msg) {
    
    if (msg.documentId !== this.documentId) {
      return false
    }
    
    msg = cloneDeep(msg);
    switch (msg.type) {
      case 'syncDone':
        this.syncDone(msg);
        break
      case 'syncError':
        this.syncError(msg);
        break
      case 'update':
        this.update(msg);
        break
      case 'disconnectDone':
        this.disconnectDone(msg);
        break
      case 'error':
        this.error(msg);
        break
      default:
        console.error('CollabSession: unsupported message', msg.type, msg);
        return false
    }
    return true
  };

  
  CollabSession.prototype._send = function _send (msg) {
    if (this.collabClient.isConnected()) {
      this.collabClient.send(msg);
      return true
    } else {
      console.warn('Try not to call _send when disconnected. Skipping message', msg);
      return false
    }
  };

  
  CollabSession.prototype.update = function update (args) {
    
    var serverChange = args.change;
    var serverVersion = args.version;

    if (!this._nextChange && !this._pendingSync) {
      if (serverChange) {
        serverChange = this.deserializeChange(serverChange);
        this._applyRemoteChange(serverChange);
      }
      if (serverVersion) {
        this.version = serverVersion;
      }
      this.startFlow();
    } else {
      console.info('skipped remote update. Pending sync or local changes.');
    }
  };

  
  CollabSession.prototype.syncDone = function syncDone (args) {
    
    var serverChange = args.serverChange;
    var serverVersion = args.version;

    if (serverChange) {
      serverChange = this.deserializeChange(serverChange);
      this._applyRemoteChange(serverChange);
    }
    this.version = serverVersion;
    
    
    this._pendingChange = null;
    this._pendingSync = false;
    this._error = null;
    
    this._connected = true;
    this.startFlow();
    this.emit('connected');
    
    this._requestSync();
  };

  
  CollabSession.prototype.syncError = function syncError (error) {
    console.info('SyncError occured. Aborting sync', error);
    this._abortSync();
  };

  CollabSession.prototype.disconnectDone = function disconnectDone () {
    
    
    this._afterDisconnected();
  };

  
  CollabSession.prototype.error = function error (message) {
    var error = message.error;
    var errorFn = this[error.name];
    var err = SubstanceError.fromJSON(error);

    if (!errorFn) {
      error('CollabSession: unsupported error', error.name);
      return false
    }

    this.emit('error', err);
    errorFn = errorFn.bind(this);
    errorFn(err);
  };


  

  CollabSession.prototype.afterDocumentChange = function afterDocumentChange (change, info) {
    
    if (!info.remote) {
      this._recordChange(change);
    }
  };

  
  CollabSession.prototype.onCollabClientConnected = function onCollabClientConnected () {
    
    if (this.autoSync) {
      this.sync();
    }
  };

  
  CollabSession.prototype.onCollabClientDisconnected = function onCollabClientDisconnected () {
    
    this._abortSync();
    if (this._connected) {
      this._afterDisconnected();
    }
  };

  

  CollabSession.prototype._commit = function _commit (change, info) {
    this._commitChange(change, info);
    this.startFlow();
  };

  
  CollabSession.prototype._applyRemoteChange = function _applyRemoteChange (change) {
    
    if (change.ops.length > 0) {
      this._transaction._apply(change);
      this.getDocument()._apply(change);
      this._setDirty('document');
      
      this._transformLocalChangeHistory(change);
      this._setSelection(this._transformSelection(change));
      this._change = change;
      this._info = { remote: true };
      this.startFlow();
    }
  };

  
  CollabSession.prototype._recordChange = function _recordChange (change) {
    if (!this._nextChange) {
      this._nextChange = change;
    } else {
      
      this._nextChange.ops = this._nextChange.ops.concat(change.ops);
      this._nextChange.after = change.after;
    }
    this._requestSync();
  };

  CollabSession.prototype.__canSync = function __canSync () {
    return this.collabClient.isConnected() && !this._pendingSync
  };

  
  CollabSession.prototype._requestSync = function _requestSync () {
    if (this._nextChange && this.__canSync()) {
      this.sync();
    }
  };

  
  CollabSession.prototype._abortSync = function _abortSync () {
    var newNextChange = this._nextChange;

    if (this._pendingChange) {
      newNextChange = this._pendingChange;
      
      if (this._nextChange) {
        newNextChange.ops = newNextChange.ops.concat(this._nextChange.ops);
        newNextChange.after = this._nextChange.after;
      }
      this._pendingChange = null;
    }
    this._pendingSync = false;
    this._error = null;
    this._nextChange = newNextChange;
  };

  
  CollabSession.prototype._afterDisconnected = function _afterDisconnected () {
    this._connected = false;
    this.emit('disconnected');
  };

  
  CollabSession.prototype._hasLocalChanges = function _hasLocalChanges () {
    return this._nextChange && this._nextChange.ops.length > 0
  };

  return CollabSession;
}(EditorSession));

var Button = (function (Component$$1) {
  function Button () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Button.__proto__ = Component$$1;
  Button.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Button.prototype.constructor = Button;

  Button.prototype.render = function render ($$) {
    var el = $$('button')
      .addClass('sc-button');

    if (this.props.icon) {
      el.append(this.renderIcon($$));
    }
    if (this.props.label) {
      el.append(this.renderLabel($$));
    }
    if (this.props.active) {
      el.addClass('sm-active');
    }
    if (this.props.style) {
      el.addClass('sm-style-'+this.props.style);
    }
    if (this.props.disabled) {
      
      el.attr('tabindex', -1)
        .attr('disabled', true);
    } else {
      
      el.attr('tabindex', 1);
    }

    
    el.append(this.props.children);
    return el
  };

  Button.prototype.renderIcon = function renderIcon ($$) {
    var iconEl = this.context.iconProvider.renderIcon($$, this.props.icon);
    return iconEl
  };

  Button.prototype.renderLabel = function renderLabel ($$) {
    return $$('div').addClass('se-label').append(
      this.getLabel(this.props.label)
    )
  };

  Button.prototype.renderHint = function renderHint ($$) {
    return $$('div').addClass('se-hint').append(
      this.getLabel(this.props.hint+'-hint')
    )
  };

  Button.prototype.getLabel = function getLabel (name) {
    var labelProvider = this.context.labelProvider;
    return labelProvider.getLabel(name)
  };

  return Button;
}(Component));

var ButtonPackage = {
  name: 'button',
  configure: function(config) {
    config.addComponent('button', Button);
  }
};

var ContextMenu = (function (Toolbox$$1) {
  function ContextMenu () {
    Toolbox$$1.apply(this, arguments);
  }

  if ( Toolbox$$1 ) ContextMenu.__proto__ = Toolbox$$1;
  ContextMenu.prototype = Object.create( Toolbox$$1 && Toolbox$$1.prototype );
  ContextMenu.prototype.constructor = ContextMenu;

  ContextMenu.prototype.didMount = function didMount () {
    Toolbox$$1.prototype.didMount.call(this);
    if (!this.context.scrollPane) {
      throw new Error('Requires a scrollPane context')
    }
    this.context.scrollPane.on('context-menu:opened', this._onContextMenuOpened, this);
  };

  ContextMenu.prototype.dispose = function dispose () {
    Toolbox$$1.prototype.dispose.call(this);
    this.context.scrollPane.off(this);
  };

  
  ContextMenu.prototype.render = function render ($$) {
    var this$1 = this;

    var el = $$('div').addClass('sc-context-menu sm-hidden');
    var activeToolGroups = this.state.activeToolGroups;

    activeToolGroups.forEach(function (toolGroup) {
      var toolGroupProps = Object.assign({}, toolGroup, {
        toolStyle: this$1.getToolStyle(),
        showLabels: true,
        
      });

      if (toolGroupProps.tools.size > 0) {
        var toolGroupEl = $$(toolGroup.Class, toolGroupProps);
        el.append(toolGroupEl);
      }
    });
    return el
  };

  ContextMenu.prototype.getActiveToolGroupNames = function getActiveToolGroupNames () {
    return ['context-menu-primary', 'context-menu-document']
  };

  ContextMenu.prototype.showDisabled = function showDisabled () {
    return true
  };

  
  ContextMenu.prototype.getToolStyle = function getToolStyle () {
    return 'plain-dark'
  };

  ContextMenu.prototype.hide = function hide () {
    this.el.addClass('sm-hidden');
  };

  
  ContextMenu.prototype._onContextMenuOpened = function _onContextMenuOpened (hints) {
    var mouseBounds = hints.mouseBounds;
    this.el.removeClass('sm-hidden');
    var contextMenuWidth = this.el.htmlProp('offsetWidth');

    
    this.el.css('top', mouseBounds.top);
    var leftPos = mouseBounds.left;
    
    leftPos = Math.max(leftPos, 0);
    
    var maxLeftPos = mouseBounds.left + mouseBounds.right - contextMenuWidth;
    leftPos = Math.min(leftPos, maxLeftPos);
    this.el.css('left', leftPos);
  };

  return ContextMenu;
}(Toolbox));

var ContextMenuPackage = {
  name: 'context-menu',
  configure: function(config) {
    config.addComponent('context-menu', ContextMenu);
  }
};

var Grid = (function (Component$$1) {
  function Grid () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Grid.__proto__ = Component$$1;
  Grid.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Grid.prototype.constructor = Grid;

  Grid.prototype.render = function render ($$) {
    var el = $$('div').addClass('sc-grid');
    if (this.props.mobile) {
      el.addClass('sm-mobile');
    }
    el.append(this.props.children);
    return el
  };

  return Grid;
}(Component));


var Row = (function (Component$$1) {
  function Row () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Row.__proto__ = Component$$1;
  Row.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Row.prototype.constructor = Row;

  Row.prototype.render = function render ($$) {
    var el = $$('div').addClass('se-row');
    el.append(this.props.children);
    return el
  };

  return Row;
}(Component));


var Cell = (function (Component$$1) {
  function Cell () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Cell.__proto__ = Component$$1;
  Cell.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Cell.prototype.constructor = Cell;

  Cell.prototype.render = function render ($$) {
    var el = $$('div').addClass('se-cell');
    el.addClass('sm-column-'+this.props.columns);
    el.append(this.props.children);
    return el
  };

  return Cell;
}(Component));

Grid.Row = Row;
Grid.Cell = Cell;

var GridPackage = {
  name: 'grid',
  configure: function(config) {
    config.addComponent('grid', Grid);
  }
};

var Gutter = (function (Toolbox$$1) {
  function Gutter () {
    Toolbox$$1.apply(this, arguments);
  }

  if ( Toolbox$$1 ) Gutter.__proto__ = Toolbox$$1;
  Gutter.prototype = Object.create( Toolbox$$1 && Toolbox$$1.prototype );
  Gutter.prototype.constructor = Gutter;

  Gutter.prototype.render = function render ($$) {
    var this$1 = this;

    var el = $$('div').addClass(this.getClassNames());
    el.addClass('sm-hidden');
    el.addClass('sm-theme-'+this.getTheme());
    var activeToolGroups = this.state.activeToolGroups;
    var activeToolsEl = $$('div').addClass('se-active-tools');

    activeToolGroups.forEach(function (toolGroup) {
      var toolGroupProps = Object.assign({}, toolGroup, {
        toolStyle: this$1.getToolStyle(),
        showIcons: true
      });
      activeToolsEl.append(
        $$(toolGroup.Class, toolGroupProps)
      );
    });

    el.append(activeToolsEl);
    return el
  };

  
  Gutter.prototype.getToolStyle = function getToolStyle () {
    return 'outline-dark'
  };

  Gutter.prototype.show = function show (hints) {
    this.el.removeClass('sm-hidden');
    this._position(hints);
  };

  Gutter.prototype.hide = function hide () {
    this.el.addClass('sm-hidden');
  };

  Gutter.prototype._position = function _position (hints) {
    if (hints) {
      
      this.el.css('top', hints.rectangle.top + hints.rectangle.height - hints.rectangle.height / 2);
      this.el.css('left', 0);
    }
  };

  Gutter.prototype.getClassNames = function getClassNames () {
    return 'sc-gutter'
  };

  Gutter.prototype.getTheme = function getTheme () {
    return 'dark'
  };

  Gutter.prototype.getActiveToolGroupNames = function getActiveToolGroupNames () {
    return ['gutter']
  };

  return Gutter;
}(Toolbox));

var GutterPackage = {
  name: 'gutter',
  configure: function(config) {
    config.addToolGroup('gutter');
    config.addComponent('gutter', Gutter);
  }
};

var Input = (function (Component$$1) {
  function Input () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Input.__proto__ = Component$$1;
  Input.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Input.prototype.constructor = Input;

  Input.prototype._onChange = function _onChange () {
    var editorSession = this.context.editorSession;
    var path = this.props.path;
    var newVal = this.el.val();

    editorSession.transaction(function(tx) {
      tx.set(path, newVal);
    });
  };

  Input.prototype.render = function render ($$) {
    var val;

    if (this.props.path) {
      var editorSession = this.context.editorSession;
      var doc = editorSession.getDocument();
      val = doc.get(this.props.path);
    } else {
      val = this.props.value;
    }

    var el = $$('input').attr({
      value: val,
      type: this.props.type,
      placeholder: this.props.placeholder
    })
    .addClass('sc-input');

    if (this.props.path) {
      el.on('change', this._onChange);
    }

    if (this.props.centered) {
      el.addClass('sm-centered');
    }

    return el
  };

  return Input;
}(Component));

var InputPackage = {
  name: 'input',
  configure: function(config) {
    config.addComponent('input', Input);
  }
};

var Layout = (function (Component$$1) {
  function Layout () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Layout.__proto__ = Component$$1;
  Layout.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Layout.prototype.constructor = Layout;

  Layout.prototype.render = function render ($$) {
    var el = $$('div').addClass('sc-layout');
    el.addClass('sm-width-'+this.props.width);
    if (this.props.textAlign) {
      el.addClass('sm-text-align-'+this.props.textAlign);
    }

    if (this.props.noPadding) {
      el.addClass('sm-no-padding');
    }

    el.append(this.props.children);
    return el
  };

  return Layout;
}(Component));

var LayoutPackage = {
  name: 'layout',
  configure: function(config) {
    config.addComponent('layout', Layout);
  }
};

var Modal = (function (Component$$1) {
  function Modal () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Modal.__proto__ = Component$$1;
  Modal.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Modal.prototype.constructor = Modal;

  Modal.prototype.render = function render ($$) {
    var el = $$('div').addClass('sc-modal');

    
    
    el.on('click', this._closeModal);

    if (this.props.width) {
      el.addClass('sm-width-'+this.props.width);
    }

    el.append(
      $$('div').addClass('se-body').append(
        this.props.children
      )
    );
    return el
  };

  Modal.prototype._closeModal = function _closeModal (e) {
    var closeSurfaceClick = e.target.classList.contains('sc-modal');
    if (closeSurfaceClick) {
      this.send('closeModal');
    }
  };

  return Modal;
}(Component));

var ModalPackage = {
  name: 'modal',
  configure: function(config) {
    config.addComponent('modal', Modal);
  }
};

var OverlayPackage = {
  name: 'overlay',
  configure: function(config) {
    config.addToolGroup('overlay');
    config.addComponent('overlay', Overlay);
  }
};

var Dropzones = (function (Component$$1) {
  function Dropzones () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Dropzones.__proto__ = Component$$1;
  Dropzones.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Dropzones.prototype.constructor = Dropzones;

  Dropzones.prototype.didMount = function didMount () {
    this.context.dragManager.on('drag:started', this.onDragStarted, this);
    this.context.dragManager.on('drag:finished', this.onDragFinished, this);
  };

  Dropzones.prototype.render = function render ($$) {
    var this$1 = this;

    var el = $$('div').addClass('sc-dropzones');

    if (this.state.dropzones) {
      el.on('dragenter', this.onDrag)
        .on('dragover', this.onDrag);

      
      forEach(this.state.dropzones, function (dropzones, surfaceId) {
        dropzones.forEach(function (dropzone, index) {
          var dropType = dropzone.type;
          var dropzoneEl;
          if (dropType === 'place') {
            dropzoneEl = $$('div').addClass('se-dropzone')
              .attr({
                'data-dropzone-index': index,
                'data-dropzone-surface': surfaceId
              }).append(
                $$('div').addClass('se-drop-teaser').css({
                  top: dropzone.teaserPos
                })
              );
          } else if (dropType === 'custom') {
            dropzoneEl = $$('div').addClass('se-custom-dropzone').attr({
              'data-dropzone-index': index,
              'data-dropzone-surface': surfaceId
            }).append(
              
              
              $$('div').addClass('se-message').append(dropzone.message)
            );
          }
          if (dropzoneEl) {
            var shield = $$('div').addClass('se-drop-shield')
              .on('dragenter', this$1.onDragEnter)
              .on('dragleave', this$1.onDragLeave)
              .on('drop', this$1.onDrop)
              .on('mouseenter', this$1.onDragEnter)
              .on('mouseleave', this$1.onDragLeave)
              .on('mouseup', this$1.onDrop);
            dropzoneEl.append(shield);
            dropzoneEl.css({
              position: 'absolute',
              top: dropzone.top,
              left: dropzone.left,
              width: dropzone.width,
              height: dropzone.height
            });
            el.append(dropzoneEl);
          }
        });
      });
    } else {
      el.addClass('sm-hidden');
    }
    return el
  };

  
  Dropzones.prototype.onDragStarted = function onDragStarted (dragState) {
    var this$1 = this;

    var dropzones = this._computeDropzones(dragState);
    setTimeout(function () {
      this$1.setState({
        dropzones: dropzones
      });
    }, 250);
  };

  
  Dropzones.prototype.onDragFinished = function onDragFinished () {
    this.setState({});
  };

  Dropzones.prototype.onDragEnter = function onDragEnter (e) {
    
    e.target.parentNode.classList.add('sm-over');
  };

  Dropzones.prototype.onDragLeave = function onDragLeave (e) {
    
    e.target.parentNode.classList.remove('sm-over');
  };

  
  Dropzones.prototype.onDrag = function onDrag (e) { 
    
    e.preventDefault();
  };

  Dropzones.prototype.onDrop = function onDrop (e) {
    
    
    e.__reserved__ = true;
    e.preventDefault();
    e.stopPropagation();
    var dropzoneIndex = e.target.parentNode.dataset.dropzoneIndex;
    var dropzoneSurface = e.target.parentNode.dataset.dropzoneSurface;
    var dropzone = this.state.dropzones[dropzoneSurface][dropzoneIndex];
    var dropParams = dropzone.dropParams;
    var dropType = dropzone.type;
    
    var targetSurface = this.context.surfaceManager.getSurface(dropzoneSurface);
    
    var component = dropzone.component;
    var dropzoneComponent = dropzone.dropzoneComponent;
    
    var dragManager = this.context.dragManager;
    dragManager.extendDragState({
      targetSurface: targetSurface,
      dropType: dropType,
      dropParams: dropParams,
      component: component,
      dropzoneComponent: dropzoneComponent
    });
    dragManager._onDragEnd(e);
  };

  
  Dropzones.prototype._getBoundingRect = function _getBoundingRect (comp) {
    var scrollPane = comp.context.scrollPane;
    var contentElement = scrollPane.getContentElement().getNativeElement();
    var rect = getRelativeBoundingRect(comp.getNativeElement(), contentElement);
    return rect
  };

  Dropzones.prototype._computeDropzones = function _computeDropzones (dragState) {
    var this$1 = this;

    var scrollPaneName = this.context.scrollPane.getName();
    var surfaces = dragState.scrollPanes[scrollPaneName].surfaces;
    var scopedDropzones = {};

    forEach(surfaces, function (surface) {
      var components = surface.childNodes;

      
      var numDropzones = components.length + 1;
      var dropzones = [];

      for (var i = 0; i < numDropzones; i++) {
        if (i === 0) {
          
          var firstComp = this$1._getBoundingRect(components[0]);
          dropzones.push({
            type: 'place',
            left: firstComp.left,
            top: firstComp.top,
            width: firstComp.width,
            height: firstComp.height / 2,
            teaserPos: 0,
            dropParams: {
              insertPos: i
            }
          });
        } else if (i === numDropzones - 1) {
          
          var lastComp = this$1._getBoundingRect(components[i - 1]);
          dropzones.push({
            type: 'place',
            left: lastComp.left,
            top: lastComp.top + lastComp.height / 2,
            width: lastComp.width,
            height: lastComp.height / 2,
            teaserPos: lastComp.height / 2,
            dropParams: {
              insertPos: i
            }
          });
        } else {
          
          var upperComp = this$1._getBoundingRect(components[i-1]);
          var lowerComp = this$1._getBoundingRect(components[i]);
          var topBound = upperComp.top + upperComp.height / 2;
          var bottomBound = lowerComp.top + lowerComp.height / 2;

          dropzones.push({
            type: 'place',
            left: upperComp.left,
            top: topBound,
            width: upperComp.width,
            height: bottomBound - topBound,
            teaserPos: (upperComp.top + upperComp.height + lowerComp.top) / 2 - topBound,
            dropParams: {
              insertPos: i
            }
          });
        }

        if (i < numDropzones - 1) {
          var comp = components[i];
          
          if (comp._isIsolatedNodeComponent) {
            comp = comp.getContent();
          }
          
          if (comp.getDropzoneSpecs) {
            var dropzoneSpecs = comp.getDropzoneSpecs();
            dropzoneSpecs.forEach(function (dropzoneSpec) {
              var dropzoneComp = dropzoneSpec.component;
              var rect = this$1._getBoundingRect(dropzoneComp);
              dropzones.push({
                type: 'custom',
                component: comp,
                dropzoneComponent: dropzoneComp,
                left: rect.left,
                top: rect.top,
                width: rect.width,
                height: rect.height,
                message: dropzoneSpec.message,
                dropParams: dropzoneSpec.dropParams
              });
            });
          }
        }
      }
      scopedDropzones[surface.getName()] = dropzones;
    });
    return scopedDropzones
  };

  Dropzones.prototype._renderDropTeaser = function _renderDropTeaser (hints) {
    if (hints.visible) {
      this.el.removeClass('sm-hidden');
      this.el.css('top', hints.rect.top);
      this.el.css('left', hints.rect.left);
      this.el.css('right', hints.rect.right);
    } else {
      this.el.addClass('sm-hidden');
    }
  };

  return Dropzones;
}(Component));

var DropzonesPackage = {
  name: 'dropzones',
  configure: function(config) {
    config.addComponent('dropzones', Dropzones);
  }
};

var Scrollbar = (function (Component$$1) {
  function Scrollbar () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Scrollbar.__proto__ = Component$$1;
  Scrollbar.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Scrollbar.prototype.constructor = Scrollbar;

  Scrollbar.prototype.didMount = function didMount () {
    
    DefaultDOMElement.getBrowserWindow().on('resize', this.onResize, this);
    
    this.props.scrollPane.on('scroll', this.onScroll, this);
    
    setTimeout(function() {
      this.updatePositions();
    }.bind(this));
  };

  Scrollbar.prototype.dispose = function dispose () {
    DefaultDOMElement.getBrowserWindow().off(this);
    this.props.scrollPane.off(this);
  };

  Scrollbar.prototype.didUpdate = function didUpdate () {
    this.updatePositions();
  };

  Scrollbar.prototype.render = function render ($$) {
    var el = $$('div')
      .addClass('sc-scrollbar')
      .on('mousedown', this.onMouseDown);

    if (this.props.highlights) {
      var highlightEls = [];

      forEach(this.props.highlights, function(highlights, scope) {
        forEach(highlights, function(h) {
          highlightEls.push(
            $$('div').ref(h).addClass('se-highlight sm-'+scope)
          );
        });
      });

      el.append(
        $$('div').ref('highlights')
          .addClass('se-highlights')
          .append(highlightEls)
      );
    }
    el.append($$('div').ref('thumb').addClass('se-thumb'));
    return el
  };

  Scrollbar.prototype.updatePositions = function updatePositions () {
    var scrollPane = this.props.scrollPane;
    var scrollableEl = scrollPane.getScrollableElement();
    var contentHeight = scrollPane.getContentHeight();
    var scrollPaneHeight = scrollPane.getHeight();
    var scrollTop = scrollPane.getScrollPosition();
    var contentEl = scrollPane.getContentElement();

    
    this.factor = (contentHeight / scrollPaneHeight);

    if (this.factor <= 1) {
      this.el.addClass('sm-hide-thumb');
    } else {
      this.el.removeClass('sm-hide-thumb');
    }

    this.refs.thumb.css({
      top: scrollTop / this.factor,
      height: scrollPaneHeight / this.factor
    });

    
    if (this.props.highlights) {
      
      forEach(this.props.highlights,function(highlights) {
        forEach(highlights, function(nodeId) {
          var nodeEl = scrollableEl.find('*[data-id="'+nodeId+'"]');

          if (!nodeEl) { return }

          
          var rect = getRelativeBoundingRect(nodeEl.getNativeElement(), contentEl.getNativeElement());
          var top = rect.top / this.factor;
          var height = rect.height / this.factor;

          
          if (height < Scrollbar.overlayMinHeight) {
            height = Scrollbar.overlayMinHeight;
          }

          var highlightEl = this.refs[nodeId];
          if (highlightEl) {
            this.refs[nodeId].css({
              top: top,
              height: height
            });
          } else {
            console.warn('no ref found for highlight', nodeId);
          }
        }.bind(this));
      }.bind(this));
    }
  };

  Scrollbar.prototype.getScrollableElement = function getScrollableElement () {
    return this.props.scrollPane.getScrollableElement()
  };

  Scrollbar.prototype.onResize = function onResize () {
    this.rerender();
  };

  Scrollbar.prototype.onScroll = function onScroll () {
    this.updatePositions();
  };

  Scrollbar.prototype.onMouseDown = function onMouseDown (e) {
    e.stopPropagation();
    e.preventDefault();
    this._mouseDown = true;

    
    
    var _window = DefaultDOMElement.getBrowserWindow();
    _window.on('mousemove', this.onMouseMove, this);
    _window.on('mouseup', this.onMouseUp, this);

    var scrollBarOffset = this.el.getOffset().top;
    var y = e.pageY - scrollBarOffset;
    var thumbEl = this.refs.thumb.el;
    if (e.target !== thumbEl.getNativeElement()) {
      
      this.offset = thumbEl.height / 2;
      this.onMouseMove(e);
    } else {
      this.offset = y - thumbEl.getPosition().top;
    }
  };

  
  Scrollbar.prototype.onMouseUp = function onMouseUp () {
    this._mouseDown = false;
    var _window = DefaultDOMElement.getBrowserWindow();
    _window.off('mousemove', this.onMouseMove, this);
    _window.off('mouseup', this.onMouseUp, this);
  };

  Scrollbar.prototype.onMouseMove = function onMouseMove (e) {
    if (this._mouseDown) {
      var scrollPane = this.props.scrollPane;
      var scrollableEl = scrollPane.getScrollableElement();
      var scrollBarOffset = this.el.getOffset().top;
      var y = e.pageY - scrollBarOffset;

      
      var scroll = (y-this.offset)*this.factor;
      scrollableEl.setProperty('scrollTop', scroll);
    }
  };

  return Scrollbar;
}(Component));

Scrollbar.overlayMinHeight = 2;

var ScrollbarPackage = {
  name: 'scrollbar',
  configure: function(config) {
    config.addComponent('scrollbar', Scrollbar);
  }
};

var ScrollPane = (function (AbstractScrollPane$$2) {
  function ScrollPane () {
    AbstractScrollPane$$2.apply(this, arguments);
  }

  if ( AbstractScrollPane$$2 ) ScrollPane.__proto__ = AbstractScrollPane$$2;
  ScrollPane.prototype = Object.create( AbstractScrollPane$$2 && AbstractScrollPane$$2.prototype );
  ScrollPane.prototype.constructor = ScrollPane;

  ScrollPane.prototype.didMount = function didMount () {
    AbstractScrollPane$$2.prototype.didMount.call(this);
    if (this.refs.scrollbar && this.props.highlights) {
      this.props.highlights.on('highlights:updated', this.onHighlightsUpdated, this);
    }
    if (this.refs.scrollbar) {
      this.domObserver = new window.MutationObserver(this._onContentChanged.bind(this));
      this.domObserver.observe(this.el.getNativeElement(), {
        subtree: true,
        attributes: true,
        characterData: true,
        childList: true,
      });
      this.context.editorSession.onPosition(this._onPosition, this);
    }
  };

  ScrollPane.prototype.dispose = function dispose () {
    AbstractScrollPane$$2.prototype.dispose.call(this);
    if (this.props.highlights) {
      this.props.highlights.off(this);
    }
    this.context.editorSession.off(this);
    this.context.dragManager.off(this);
  };

  ScrollPane.prototype.render = function render ($$) {
    var el = $$('div')
      .addClass('sc-scroll-pane');

    if (platform.isFF) {
      el.addClass('sm-firefox');
    }

    
    
    if (!this.props.noStyle) {
      el.addClass('sm-default-style');
    }

    
    if (this.props.scrollbarType === 'substance') {
      el.addClass('sm-substance-scrollbar');
      el.addClass('sm-scrollbar-position-' + this.props.scrollbarPosition);

      el.append(
        
        
        $$(Scrollbar, {
          scrollPane: this
        }).ref('scrollbar')
          .attr('id', 'content-scrollbar')
      );

      
      el.append(
        $$('div').ref("scanline").addClass('se-scanline')
      );
    }

    el.append(
      $$('div').ref('scrollable').addClass('se-scrollable').append(
        this.renderContent($$)
      ).on('scroll', this.onScroll)
    );
    return el
  };

  ScrollPane.prototype.renderContent = function renderContent ($$) {
    var contentEl = $$('div').ref('content').addClass('se-content');
    contentEl.append(this.props.children);
    if (this.props.contextMenu === 'custom') {
      contentEl.on('contextmenu', this._onContextMenu);
    }
    return contentEl
  };

  ScrollPane.prototype._onContentChanged = function _onContentChanged () {
    this._contentChanged = true;
  };

  ScrollPane.prototype._onPosition = function _onPosition () {
    if (this.refs.scrollbar && this._contentChanged) {
      this._contentChanged = false;
      this._updateScrollbar();
    }
  };

  ScrollPane.prototype._updateScrollbar = function _updateScrollbar () {
    if (this.refs.scrollbar) {
      this.refs.scrollbar.updatePositions();
    }
  };

  ScrollPane.prototype.onHighlightsUpdated = function onHighlightsUpdated (highlights) {
    this.refs.scrollbar.extendProps({
      highlights: highlights
    });
  };

  ScrollPane.prototype.onScroll = function onScroll () {
    var scrollPos = this.getScrollPosition();
    var scrollable = this.refs.scrollable;
    if (this.props.onScroll) {
      this.props.onScroll(scrollPos, scrollable);
    }
    
    if (this.props.tocProvider) {
      this.props.tocProvider.markActiveEntry(this);
    }
    this.emit('scroll', scrollPos, scrollable);
  };

  
  ScrollPane.prototype.getHeight = function getHeight () {
    var scrollableEl = this.getScrollableElement();
    return scrollableEl.height
  };

  
  ScrollPane.prototype.getContentHeight = function getContentHeight () {
    var contentEl = this.refs.content.el.getNativeElement();
    
    
    
    return contentEl.scrollHeight
  };

  
  ScrollPane.prototype.getContentElement = function getContentElement () {
    return this.refs.content.el
  };

  
  ScrollPane.prototype.getScrollableElement = function getScrollableElement () {
    return this.refs.scrollable.el
  };

  
  ScrollPane.prototype.getScrollPosition = function getScrollPosition () {
    var scrollableEl = this.getScrollableElement();
    return scrollableEl.getProperty('scrollTop')
  };

  ScrollPane.prototype.setScrollPosition = function setScrollPosition (scrollPos) {
    var scrollableEl = this.getScrollableElement();
    scrollableEl.setProperty('scrollTop', scrollPos);
  };

  
  ScrollPane.prototype.getPanelOffsetForElement = function getPanelOffsetForElement (el) {
    var nativeEl = el.getNativeElement();
    var contentContainerEl = this.refs.content.getNativeElement();
    var rect = getRelativeBoundingRect(nativeEl, contentContainerEl);
    return rect.top
  };

  
  ScrollPane.prototype.scrollTo = function scrollTo (componentId, onlyIfNotVisible) {
    var scrollableEl = this.getScrollableElement();
    var targetNode = scrollableEl.find('*[data-id="'+componentId+'"]');
    if (targetNode) {
      var offset = this.getPanelOffsetForElement(targetNode);
      var shouldScroll = true;
      if (onlyIfNotVisible) {
        var height = scrollableEl.height;
        var oldOffset = scrollableEl.getProperty('scrollTop');
        shouldScroll = (offset < oldOffset || oldOffset+height<offset);
      }
      if (shouldScroll) {
        this.setScrollPosition(offset);
      }
    } else {
      console.warn(componentId, 'not found in scrollable container');
    }
  };

  
  ScrollPane.prototype.onSelectionPositioned = function onSelectionPositioned () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    AbstractScrollPane$$2.prototype.onSelectionPositioned.apply(this, args);
    this._updateScrollbar();
  };

  ScrollPane.prototype._onContextMenu = function _onContextMenu (e) {
    AbstractScrollPane$$2.prototype._onContextMenu.call(this, e);
    this._updateScrollbar();
  };

  return ScrollPane;
}(AbstractScrollPane$$1));

var ScrollPanePackage = {
  name: 'scroll-pane',
  configure: function(config) {
    config.addComponent('scroll-pane', ScrollPane);
  }
};

var BodyScrollPane = (function (AbstractScrollPane$$2) {
  function BodyScrollPane () {
    AbstractScrollPane$$2.apply(this, arguments);
  }

  if ( AbstractScrollPane$$2 ) BodyScrollPane.__proto__ = AbstractScrollPane$$2;
  BodyScrollPane.prototype = Object.create( AbstractScrollPane$$2 && AbstractScrollPane$$2.prototype );
  BodyScrollPane.prototype.constructor = BodyScrollPane;

  BodyScrollPane.prototype.getChildContext = function getChildContext () {
    return {
      scrollPane: this
    }
  };

  BodyScrollPane.prototype.getName = function getName () {
    return 'body'
  };

  BodyScrollPane.prototype.render = function render ($$) {
    var el = $$('div');
    if (this.props.contextMenu === 'custom') {
      el.on('contextmenu', this._onContextMenu);
    }
    el.append(this.props.children);
    return el
  };

  
  BodyScrollPane.prototype.getHeight = function getHeight () {
    return window.innerHeight
  };

  
  BodyScrollPane.prototype.getContentHeight = function getContentHeight () {
    return document.body.scrollHeight
  };

  BodyScrollPane.prototype.getContentElement = function getContentElement () {
    return DefaultDOMElement.wrapNativeElement(window.document.body)
  };

  
  
  
  BodyScrollPane.prototype.getScrollableElement = function getScrollableElement () {
    return document.body
  };

  
  BodyScrollPane.prototype.getScrollPosition = function getScrollPosition () {
    return document.body.scrollTop
  };

  BodyScrollPane.prototype.setScrollPosition = function setScrollPosition (scrollPos) {
    document.body.scrollTop = scrollPos;
  };

  
  BodyScrollPane.prototype.getPanelOffsetForElement = function getPanelOffsetForElement (el) { 
    console.warn('TODO: implement');
  };

  
  BodyScrollPane.prototype.scrollTo = function scrollTo (componentId, onlyIfNotVisible) { 
    console.warn('TODO: implement');
  };

  return BodyScrollPane;
}(AbstractScrollPane$$1));

var BodyScrollPanePackage = {
  name: 'body-scroll-pane',
  configure: function(config) {
    config.addComponent('body-scroll-pane', BodyScrollPane);
  },
  BodyScrollPane: BodyScrollPane
};

var SplitPane = (function (Component$$1) {
  function SplitPane () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) SplitPane.__proto__ = Component$$1;
  SplitPane.prototype = Object.create( Component$$1 && Component$$1.prototype );
  SplitPane.prototype.constructor = SplitPane;

  SplitPane.prototype.render = function render ($$) {
    if (this.props.children.length !== 2) {
      throw new Error('SplitPane only works with exactly two child elements')
    }

    var el = $$('div').addClass('sc-split-pane');
    if (this.props.splitType === 'horizontal') {
      el.addClass('sm-horizontal');
    } else {
      el.addClass('sm-vertical');
    }

    var paneA = this.props.children[0];
    var paneB = this.props.children[1];

    
    if (this.props.sizeB) {
      paneB.addClass('se-pane sm-sized');
      paneB.css(this.getSizedStyle(this.props.sizeB));
      paneA.addClass('se-pane sm-auto-fill');
    } else {
      paneA.addClass('se-pane sm-sized');
      paneA.css(this.getSizedStyle(this.props.sizeA));
      paneB.addClass('se-pane sm-auto-fill');
    }

    el.append(
      paneA,
      paneB
    );
    return el
  };

  
  SplitPane.prototype.getSizedStyle = function getSizedStyle (size) {
    if (!size || size === 'inherit') { return {} }
    if (this.props.splitType === 'horizontal') {
      return {'height': size}
    } else {
      return {'width': size}
    }
  };

  return SplitPane;
}(Component));

var SplitPanePackage = {
  name: 'split-pane',
  configure: function(config) {
    config.addComponent('split-pane', SplitPane);
  }
};

var TabbedPane = (function (Component$$1) {
  function TabbedPane () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) TabbedPane.__proto__ = Component$$1;
  TabbedPane.prototype = Object.create( Component$$1 && Component$$1.prototype );
  TabbedPane.prototype.constructor = TabbedPane;

  TabbedPane.prototype.render = function render ($$) {
    var el = $$('div').addClass('sc-tabbed-pane');
    var tabsEl = $$('div').addClass('se-tabs');
    forEach(this.props.tabs, function(tab) {
      var tabEl = $$('a')
        .addClass("se-tab")
        .attr({
          href: "#",
          "data-id": tab.id,
        })
        .on('click', this.onTabClicked);
      if (tab.id === this.props.activeTab) {
        tabEl.addClass("sm-active");
      }
      tabEl.append(
        $$('span').addClass('label').append(tab.name)
      );
      tabsEl.append(tabEl);
    }.bind(this));

    el.append(tabsEl);
    
    el.append(
      $$('div').addClass('se-tab-content').ref('tabContent').append(
        this.props.children
      )
    );
    return el
  };

  TabbedPane.prototype.onTabClicked = function onTabClicked (e) {
    e.preventDefault();
    var tabId = e.currentTarget.dataset.id;
    this.send('switchTab', tabId);
  };

  return TabbedPane;
}(Component));

var TabbedPanePackage = {
  name: 'tabbed-pane',
  configure: function(config) {
    config.addComponent('tabbed-pane', TabbedPane);
  }
};

var FilePackage = {
  name: 'file',
  configure: function(config) {
    config.addNode(FileNode);
  }
};

var Undo = (function (Command$$1) {
  function Undo () {
    Command$$1.apply(this, arguments);
  }

  if ( Command$$1 ) Undo.__proto__ = Command$$1;
  Undo.prototype = Object.create( Command$$1 && Command$$1.prototype );
  Undo.prototype.constructor = Undo;

  Undo.prototype.getCommandState = function getCommandState (params) {
    var editorSession = params.editorSession;
    return {
      disabled: !editorSession.canUndo(),
      active: false
    }
  };

  Undo.prototype.execute = function execute (params) {
    var editorSession = params.editorSession;
    if (editorSession.canUndo()) {
      editorSession.undo();
      return true
    }
    return false
  };

  return Undo;
}(Command));

var Redo = (function (Command$$1) {
  function Redo () {
    Command$$1.apply(this, arguments);
  }

  if ( Command$$1 ) Redo.__proto__ = Command$$1;
  Redo.prototype = Object.create( Command$$1 && Command$$1.prototype );
  Redo.prototype.constructor = Redo;

  Redo.prototype.getCommandState = function getCommandState (params) {
    var editorSession = params.editorSession;
    return {
      disabled: !editorSession.canRedo(),
      active: false
    }
  };

  Redo.prototype.execute = function execute (params) {
    var editorSession = params.editorSession;
    if (editorSession.canRedo()) {
      editorSession.redo();
      return true
    } else {
      return false
    }
  };

  return Redo;
}(Command));

var SelectAll = (function (Command$$1) {
  function SelectAll () {
    Command$$1.apply(this, arguments);
  }

  if ( Command$$1 ) SelectAll.__proto__ = Command$$1;
  SelectAll.prototype = Object.create( Command$$1 && Command$$1.prototype );
  SelectAll.prototype.constructor = SelectAll;

  SelectAll.prototype.getCommandState = function getCommandState (params) {
    var editorSession = params.editorSession;
    return {
      disabled: editorSession.getSelection().isNull()
    }
  };

  SelectAll.prototype.execute = function execute (params) {
    var editorSession = params.editorSession;
    var doc = editorSession.getDocument();
    var surface = params.surface || editorSession.getFocusedSurface();
    if (surface) {
      var sel;
      
      if (surface._isContainerEditor) {
        var container = surface.getContainer();
        if (container.nodes.length === 0) {
          return false
        }
        var firstNodeId = container.nodes[0];
        var lastNodeId = last$1(container.nodes);
        sel = editorSession.createSelection({
          type: 'container',
          startPath: [firstNodeId],
          startOffset: 0,
          endPath: [lastNodeId],
          endOffset: 1,
          containerId: container.id,
          surfaceId: surface.id
        });
      } else if (surface._isTextPropertyEditor) {
        var path = surface.getPath();
        var text = doc.get(path);
        sel = editorSession.createSelection({
          type: 'property',
          path: path,
          startOffset: 0,
          endOffset: text.length,
          surfaceId: surface.id
        });
      }
      editorSession.setSelection(sel);
      return true
    }
    return false
  };

  return SelectAll;
}(Command));

var BasePackage = {
  name: 'base',
  configure: function(config) {
    config.import(FilePackage);
    config.import(ScrollPanePackage);
    config.import(BodyScrollPanePackage);
    config.import(SplitPanePackage);
    config.import(TabbedPanePackage);
    config.import(ScrollbarPackage);
    config.import(GridPackage);
    config.import(ModalPackage);
    config.import(InputPackage);
    config.import(ButtonPackage);
    config.import(LayoutPackage);
    config.import(ContextMenuPackage);
    config.import(OverlayPackage);
    config.import(DropzonesPackage);
    config.import(GutterPackage);

    
    config.addToolGroup('document');
    config.addToolGroup('annotations');
    config.addToolGroup('default');
    config.addToolGroup('context-menu-primary');
    config.addToolGroup('context-menu-document');
    config.addToolGroup('insert');

    
    config.addCommand('undo', Undo);
    config.addCommand('redo', Redo);
    config.addCommand('select-all', SelectAll);

    config.addCommand('insert-node', InsertNodeCommand);

    
    config.addTool('undo', Tool, {toolGroup: ['document', 'context-menu-document']});
    config.addTool('redo', Tool, {toolGroup: ['document', 'context-menu-document']});
    config.addTool('select-all', Tool, {toolGroup: ['context-menu-document']});

    
    config.addIcon('undo', { 'fontawesome': 'fa-undo' });
    config.addIcon('redo', { 'fontawesome': 'fa-repeat' });
    config.addIcon('edit', { 'fontawesome': 'fa-cog' });
    config.addIcon('delete', { 'fontawesome': 'fa-times' });
    config.addIcon('expand', { 'fontawesome': 'fa-arrows-h' });
    config.addIcon('truncate', { 'fontawesome': 'fa-arrows-h' });

    
    config.addLabel('undo', {
      en: 'Undo',
      de: 'Rckgngig'
    });
    config.addLabel('redo', {
      en: 'Redo',
      de: 'Wiederherstellen'
    });
    config.addLabel('select-all', {
      en: 'Select All',
      de: 'Alles Auswhlen'
    });
    config.addLabel('container-selection', {
      en: 'Container',
      de: 'Container'
    });
    config.addLabel('container', {
      en: 'Container',
      de: 'Container'
    });
    config.addLabel('insert-container', {
      en: 'Insert Container',
      de: 'Container einfgen'
    });

    if (platform.isMac) {
      config.addKeyboardShortcut('cmd+z', { command: 'undo' });
      config.addKeyboardShortcut('cmd+shift+z', { command: 'redo' });
      config.addKeyboardShortcut('cmd+a', { command: 'select-all' });
    } else {
      config.addKeyboardShortcut('ctrl+z', { command: 'undo' });
      config.addKeyboardShortcut('ctrl+shift+z', { command: 'redo' });
      config.addKeyboardShortcut('ctrl+a', { command: 'select-all' });
    }
  },
  UndoCommand: Undo,
  RedoCommand: Redo,
  SelectAllCommand: SelectAll
};

var Blockquote = (function (TextBlock$$1) {
	function Blockquote () {
		TextBlock$$1.apply(this, arguments);
	}if ( TextBlock$$1 ) Blockquote.__proto__ = TextBlock$$1;
	Blockquote.prototype = Object.create( TextBlock$$1 && TextBlock$$1.prototype );
	Blockquote.prototype.constructor = Blockquote;

	

	return Blockquote;
}(TextBlock));

Blockquote.type = "blockquote";

var BlockquoteComponent = (function (TextBlockComponent$$1) {
  function BlockquoteComponent () {
    TextBlockComponent$$1.apply(this, arguments);
  }

  if ( TextBlockComponent$$1 ) BlockquoteComponent.__proto__ = TextBlockComponent$$1;
  BlockquoteComponent.prototype = Object.create( TextBlockComponent$$1 && TextBlockComponent$$1.prototype );
  BlockquoteComponent.prototype.constructor = BlockquoteComponent;

  BlockquoteComponent.prototype.render = function render ($$) {
    var el = TextBlockComponent$$1.prototype.render.call(this, $$);
    return el.addClass('sc-blockquote')
  };

  return BlockquoteComponent;
}(TextBlockComponent));

var BlockquoteHTMLConverter = {

  type: 'blockquote',
  tagName: 'blockquote',

  import: function(el, node, converter) {
    node.content = converter.annotatedText(el, [node.id, 'content']);
  },

  export: function(node, el, converter) {
    el.append(
      converter.annotatedText([node.id, 'content'])
    );
  }

};

var BlockquotePackage = {
  name: 'blockquote',
  configure: function(config) {
    config.addNode(Blockquote);
    config.addComponent(Blockquote.type, BlockquoteComponent);
    config.addConverter('html', BlockquoteHTMLConverter);
    config.addConverter('xml', BlockquoteHTMLConverter);
    config.addTextType({
      name: 'blockquote',
      data: {type: 'blockquote'}
    });
    config.addLabel('blockquote', {
      en: 'Blockquote',
      de: 'Blockzitat'
    });
  },
  Blockquote: Blockquote,
  BlockquoteComponent: BlockquoteComponent,
  BlockquoteHTMLConverter: BlockquoteHTMLConverter
};

var Code = (function (PropertyAnnotation$$1) {
	function Code () {
		PropertyAnnotation$$1.apply(this, arguments);
	}if ( PropertyAnnotation$$1 ) Code.__proto__ = PropertyAnnotation$$1;
	Code.prototype = Object.create( PropertyAnnotation$$1 && PropertyAnnotation$$1.prototype );
	Code.prototype.constructor = Code;

	

	return Code;
}(PropertyAnnotation));

Code.type = 'code';

var CodeHTMLConverter = {
  type: 'code',
  tagName: 'code'
};

var CodePackage = {
  name: 'code',
  configure: function(config, ref) {
    var toolGroup = ref.toolGroup;
    var disableCollapsedCursor = ref.disableCollapsedCursor;

    config.addNode(Code);
    config.addConverter('html', CodeHTMLConverter);
    config.addConverter('xml', CodeHTMLConverter);
    config.addComponent('code', AnnotationComponent);
    config.addCommand('code', AnnotationCommand, {
      disableCollapsedCursor: disableCollapsedCursor,
      nodeType: Code.type
    });
    config.addTool('code', AnnotationTool, {
      toolGroup: toolGroup || 'annotations'
    });
    config.addIcon('code', { 'fontawesome': 'fa-code' });
    config.addLabel('code', {
      en: 'Code',
      de: 'Code'
    });
  },
  Code: Code,
  CodeHTMLConverter: CodeHTMLConverter
};

var Codeblock = (function (TextBlock$$1) {
	function Codeblock () {
		TextBlock$$1.apply(this, arguments);
	}if ( TextBlock$$1 ) Codeblock.__proto__ = TextBlock$$1;
	Codeblock.prototype = Object.create( TextBlock$$1 && TextBlock$$1.prototype );
	Codeblock.prototype.constructor = Codeblock;

	

	return Codeblock;
}(TextBlock));

Codeblock.type = "codeblock";

var CodeblockComponent = (function (TextBlockComponent$$1) {
  function CodeblockComponent () {
    TextBlockComponent$$1.apply(this, arguments);
  }

  if ( TextBlockComponent$$1 ) CodeblockComponent.__proto__ = TextBlockComponent$$1;
  CodeblockComponent.prototype = Object.create( TextBlockComponent$$1 && TextBlockComponent$$1.prototype );
  CodeblockComponent.prototype.constructor = CodeblockComponent;

  CodeblockComponent.prototype.render = function render ($$) {
    var el = TextBlockComponent$$1.prototype.render.call(this, $$);
    return el.addClass('sc-codeblock')
  };

  return CodeblockComponent;
}(TextBlockComponent));

var CodeblockHTMLConverter = {

  type: 'codeblock',
  tagName: 'pre',

  import: function(el, node, converter) {
    var codeEl = el.find('code');
    if (codeEl) {
      node.content = converter.annotatedText(codeEl, [node.id, 'content'], { preserveWhitespace: true });
    }
  },

  export: function(node, el, converter) {
    var $$ = converter.$$;
    el.append(
      $$('code').append(
        converter.annotatedText([node.id, 'content'])
      )
    );
  }
};

var CodeblockPackage = {
  name: 'codeblock',
  configure: function(config) {
    config.addNode(Codeblock);
    config.addComponent('codeblock', CodeblockComponent);
    config.addConverter('html', CodeblockHTMLConverter);
    config.addConverter('xml', CodeblockHTMLConverter);
    config.addTextType({
      name: 'codeblock',
      data: {type: 'codeblock'}
    });
    config.addLabel('codeblock', {
      en: 'Codeblock',
      de: 'Codeblock'
    });
  },
  Codeblock: Codeblock,
  CodeblockComponent: CodeblockComponent,
  CodeblockHTMLConverter: CodeblockHTMLConverter
};

var Emphasis = (function (PropertyAnnotation$$1) {
	function Emphasis () {
		PropertyAnnotation$$1.apply(this, arguments);
	}if ( PropertyAnnotation$$1 ) Emphasis.__proto__ = PropertyAnnotation$$1;
	Emphasis.prototype = Object.create( PropertyAnnotation$$1 && PropertyAnnotation$$1.prototype );
	Emphasis.prototype.constructor = Emphasis;

	

	return Emphasis;
}(PropertyAnnotation));

Emphasis.type = "emphasis";


Emphasis.fragmentation = Fragmenter.ANY;

var EmphasisHTMLConverter = {

  type: 'emphasis',
  tagName: 'em',

  matchElement: function(el) {
    return el.is('em, i')
  }

};

var EmphasisComponent = (function (AnnotationComponent$$1) {
  function EmphasisComponent () {
    AnnotationComponent$$1.apply(this, arguments);
  }

  if ( AnnotationComponent$$1 ) EmphasisComponent.__proto__ = AnnotationComponent$$1;
  EmphasisComponent.prototype = Object.create( AnnotationComponent$$1 && AnnotationComponent$$1.prototype );
  EmphasisComponent.prototype.constructor = EmphasisComponent;

  EmphasisComponent.prototype.getTagName = function getTagName () {
    return 'em'
  };

  return EmphasisComponent;
}(AnnotationComponent));

var EmphasisPackage = {
  name: 'emphasis',
  configure: function(config, ref) {
    var toolGroup = ref.toolGroup;
    var disableCollapsedCursor = ref.disableCollapsedCursor;

    config.addNode(Emphasis);
    config.addConverter('html', EmphasisHTMLConverter);
    config.addConverter('xml', EmphasisHTMLConverter);
    config.addComponent('emphasis', EmphasisComponent);
    config.addCommand('emphasis', AnnotationCommand, {
      nodeType: Emphasis.type,
      disableCollapsedCursor: disableCollapsedCursor
    });
    config.addTool('emphasis', AnnotationTool, {
      toolGroup: toolGroup || 'annotations'
    });
    config.addIcon('emphasis', { 'fontawesome': 'fa-italic' });
    config.addLabel('emphasis', {
      en: 'Emphasis',
      de: 'Betonung'
    });
    if (platform.isMac) {
      config.addKeyboardShortcut('cmd+i', { command: 'emphasis' });
    } else {
      config.addKeyboardShortcut('ctrl+i', { command: 'emphasis' });
    }
  },
  Emphasis: Emphasis,
  EmphasisComponent: EmphasisComponent,
  EmphasisHTMLConverter: EmphasisHTMLConverter
};

var Heading = (function (TextBlock$$1) {
  function Heading () {
    TextBlock$$1.apply(this, arguments);
  }if ( TextBlock$$1 ) Heading.__proto__ = TextBlock$$1;
  Heading.prototype = Object.create( TextBlock$$1 && TextBlock$$1.prototype );
  Heading.prototype.constructor = Heading;

  

  return Heading;
}(TextBlock));

Heading.schema = {
  type: "heading",
  level: { type: "number", default: 1 }
};

var HeadingComponent = (function (TextBlockComponent$$1) {
  function HeadingComponent () {
    TextBlockComponent$$1.apply(this, arguments);
  }

  if ( TextBlockComponent$$1 ) HeadingComponent.__proto__ = TextBlockComponent$$1;
  HeadingComponent.prototype = Object.create( TextBlockComponent$$1 && TextBlockComponent$$1.prototype );
  HeadingComponent.prototype.constructor = HeadingComponent;

  HeadingComponent.prototype.render = function render ($$) {
    var el = TextBlockComponent$$1.prototype.render.call(this, $$);
    return el.addClass("sc-heading sm-level-"+this.props.node.level)
  };

  HeadingComponent.prototype.getTagName = function getTagName () {
    return 'h'+this.props.node.level
  };

  return HeadingComponent;
}(TextBlockComponent));

var HeadingHTMLConverter = {

  type: "heading",

  matchElement: function(el) {
    return /^h\d$/.exec(el.tagName)
  },

  import: function(el, node, converter) {
    node.level = Number(el.tagName[1]);
    node.textAlign = el.attr('data-text-align');
    node.content = converter.annotatedText(el, [node.id, 'content']);
  },

  export: function(node, el, converter) {
    el.tagName = 'h'+node.level;
    if (node.textAlign) {
      el.attr('data-text-align', node.textAlign);
    }
    el.append(
      converter.annotatedText([node.id, 'content'])
    );
  }

};

var HeadingPackage = {
  name: 'heading',
  configure: function(config) {
    config.addNode(Heading);
    config.addComponent(Heading.type, HeadingComponent);
    config.addConverter('html', HeadingHTMLConverter);
    config.addConverter('xml', HeadingHTMLConverter);
    config.addTextType({
      name: 'heading1',
      data: {type: 'heading', level: 1}
    });
    config.addTextType({
      name: 'heading2',
      data: {type: 'heading', level: 2}
    });
    config.addTextType({
      name: 'heading3',
      data: {type: 'heading', level: 3}
    });
    config.addLabel('heading1', {
      en: 'Heading 1',
      de: 'berschrift 1'
    });
    config.addLabel('heading2', {
      en: 'Heading 2',
      de: 'berschrift 2'
    });
    config.addLabel('heading3', {
      en: 'Heading 3',
      de: 'berschrift 3'
    });
  },
  Heading: Heading,
  HeadingComponent: HeadingComponent,
  HeadingHTMLConverter: HeadingHTMLConverter
};

var ImageNode = (function (DocumentNode$$1) {
  function ImageNode () {
    DocumentNode$$1.apply(this, arguments);
  }

  if ( DocumentNode$$1 ) ImageNode.__proto__ = DocumentNode$$1;
  ImageNode.prototype = Object.create( DocumentNode$$1 && DocumentNode$$1.prototype );
  ImageNode.prototype.constructor = ImageNode;

  ImageNode.prototype.getImageFile = function getImageFile () {
    if (this.imageFile) {
      return this.document.get(this.imageFile)
    }
  };

  ImageNode.prototype.getUrl = function getUrl () {
    var imageFile = this.getImageFile();
    if (imageFile) {
      return imageFile.getUrl()
    }
  };

  return ImageNode;
}(DocumentNode));

ImageNode.schema = {
  type: 'image',
  imageFile: { type: 'file' }
};

var ImageComponent = (function (NodeComponent$$1) {
  function ImageComponent () {
    NodeComponent$$1.apply(this, arguments);
  }

  if ( NodeComponent$$1 ) ImageComponent.__proto__ = NodeComponent$$1;
  ImageComponent.prototype = Object.create( NodeComponent$$1 && NodeComponent$$1.prototype );
  ImageComponent.prototype.constructor = ImageComponent;

  ImageComponent.prototype.didMount = function didMount () {
    NodeComponent$$1.prototype.didMount.call(this);
    this.context.editorSession.onRender('document', this._onDocumentChange, this);
  };

  ImageComponent.prototype.dispose = function dispose () {
    NodeComponent$$1.prototype.dispose.call(this);
    this.context.editorSession.off(this);
  };

  
  ImageComponent.prototype._onDocumentChange = function _onDocumentChange (change) {
    if (change.isAffected(this.props.node.id) ||
      change.isAffected(this.props.node.imageFile)) {
      this.rerender();
    }
  };

  ImageComponent.prototype.render = function render ($$) {
    var el = NodeComponent$$1.prototype.render.call(this, $$);
    el.addClass('sc-image');
    el.append(
      $$('img').attr({
        src: this.props.node.getUrl(),
      }).ref('image')
    );
    return el
  };

  
  ImageComponent.prototype.getDropzoneSpecs = function getDropzoneSpecs () {
    return [
      {
        component: this.refs['image'],
        message: 'Replace Image',
        dropParams: {
          action: 'replace-image',
          nodeId: this.props.node.id,
        }
      }
    ]
  };

  ImageComponent.prototype.handleDrop = function handleDrop (tx, dragState) {
    var newImageFile = dragState.data.files[0];
    if (dragState.external) {
      var imageFile = tx.create({
        type: 'file',
        fileType: 'image',
        mimeType: newImageFile.type,
        url: URL.createObjectURL(newImageFile)
      });
      
      
      tx.set([this.props.node.id, 'imageFile'], imageFile.id);
    } else {
      var nodeId = dragState.sourceSelection.nodeId;
      var node = tx.get(nodeId);
      if (node.type === 'image') {
        
        tx.set([this.props.node.id, 'imageFile'], node.imageFile);
      }
    }


  };

  return ImageComponent;
}(NodeComponent));

var ImageHTMLConverter = {

  type: 'image',
  tagName: 'img',

  import: function(el, node, converter) {
    var imageFile = converter.getDocument().create({
      id: 'file-'+node.id,
      type: 'file',
      fileType: 'image',
      url: el.attr('src')
    });
    node.imageFile = imageFile.id;
  },

  export: function(node, el) {
    var imageFile = node.document.get(node.imageFile);
    el.attr('src', imageFile.getUrl());
  }
};

var insertImage = function(tx, file) {
  
  var imageFile = tx.create({
    type: 'file',
    fileType: 'image',
    mimeType: file.type,
    sourceFile: file
  });
  
  tx.insertBlockNode({
    type: 'image',
    imageFile: imageFile.id
  });
};

var ImageCommand = (function (InsertNodeCommand$$1) {
  function ImageCommand () {
    InsertNodeCommand$$1.apply(this, arguments);
  }

  if ( InsertNodeCommand$$1 ) ImageCommand.__proto__ = InsertNodeCommand$$1;
  ImageCommand.prototype = Object.create( InsertNodeCommand$$1 && InsertNodeCommand$$1.prototype );
  ImageCommand.prototype.constructor = ImageCommand;

  ImageCommand.prototype.execute = function execute (params) {
    var editorSession = params.editorSession;

    editorSession.transaction(function (tx) {
      params.files.forEach(function (file) {
        insertImage(tx, file);
      });
    });
  };

  return ImageCommand;
}(InsertNodeCommand));

var InsertImageTool = (function (Tool$$1) {
  function InsertImageTool () {
    Tool$$1.apply(this, arguments);
  }

  if ( Tool$$1 ) InsertImageTool.__proto__ = Tool$$1;
  InsertImageTool.prototype = Object.create( Tool$$1 && Tool$$1.prototype );
  InsertImageTool.prototype.constructor = InsertImageTool;

  InsertImageTool.prototype.getClassNames = function getClassNames () {
    return 'sc-insert-image-tool'
  };

  InsertImageTool.prototype.renderButton = function renderButton ($$) {
    var button = Tool$$1.prototype.renderButton.call(this, $$);
    var input = $$('input').attr('type', 'file').ref('input')
      .on('change', this.onFileSelect);
    return [button, input]
  };

  InsertImageTool.prototype.onClick = function onClick () {
    this.refs.input.click();
  };

  InsertImageTool.prototype.onFileSelect = function onFileSelect (e) {
    var files = e.currentTarget.files;
    this.executeCommand({
      files: Array.prototype.slice.call(files)
    });
  };

  return InsertImageTool;
}(Tool));

var DropImage = {
  type: 'drop-asset',
  match: function match(params) {
    
    var isImage = params.file.type.indexOf('image/') === 0;
    return params.type === 'file' && isImage
  },
  drop: function drop(tx, params) {
    insertImage(tx, params.file);
  }
};

var ImageProxy = (function (DefaultFileProxy$$1) {
  function ImageProxy () {
    DefaultFileProxy$$1.apply(this, arguments);
  }if ( DefaultFileProxy$$1 ) ImageProxy.__proto__ = DefaultFileProxy$$1;
  ImageProxy.prototype = Object.create( DefaultFileProxy$$1 && DefaultFileProxy$$1.prototype );
  ImageProxy.prototype.constructor = ImageProxy;

  

  return ImageProxy;
}(DefaultFileProxy));


ImageProxy.match = function(fileNode) {
  return fileNode.fileType === 'image'
};

var ImagePackage = {
  name: 'image',
  configure: function(config) {
    config.addNode(ImageNode);
    config.addComponent('image', ImageComponent);
    config.addConverter('html', ImageHTMLConverter);
    config.addConverter('xml', ImageHTMLConverter);
    config.addCommand('insert-image', ImageCommand);
    config.addTool('insert-image', InsertImageTool);
    config.addIcon('insert-image', { 'fontawesome': 'fa-image' });
    config.addLabel('image', {
      en: 'Image',
      de: 'Bild'
    });
    config.addLabel('insert-image', {
      en: 'Insert image',
      de: 'Bild einfgen'
    });

    config.addDropHandler(DropImage);
    config.addFileProxy(ImageProxy);
  },
  ImageNode: ImageNode,
  ImageComponent: ImageComponent,
  ImageHTMLConverter: ImageHTMLConverter,
  InsertImageCommand: ImageCommand,
  InsertImageTool: InsertImageTool,
  DropImage: DropImage
};

var InlineWrapper = (function (InlineNode$$1) {
  function InlineWrapper () {
    InlineNode$$1.apply(this, arguments);
  }

  if ( InlineNode$$1 ) InlineWrapper.__proto__ = InlineNode$$1;
  InlineWrapper.prototype = Object.create( InlineNode$$1 && InlineNode$$1.prototype );
  InlineWrapper.prototype.constructor = InlineWrapper;

  InlineWrapper.prototype.getWrappedNode = function getWrappedNode () {
    return this.getDocument().get(this.wrappedNode)
  };

  return InlineWrapper;
}(InlineNode));

InlineWrapper.schema = {
  type: 'inline-wrapper',
  wrappedNode: 'id'
};

var InlineWrapperComponent = (function (InlineNodeComponent$$1) {
  function InlineWrapperComponent () {
    InlineNodeComponent$$1.apply(this, arguments);
  }

  if ( InlineNodeComponent$$1 ) InlineWrapperComponent.__proto__ = InlineNodeComponent$$1;
  InlineWrapperComponent.prototype = Object.create( InlineNodeComponent$$1 && InlineNodeComponent$$1.prototype );
  InlineWrapperComponent.prototype.constructor = InlineWrapperComponent;

  InlineWrapperComponent.prototype.getClassNames = function getClassNames () {
    
    return 'sc-inline-wrapper sc-inline-node'
  };

  InlineWrapperComponent.prototype.renderContent = function renderContent ($$) {
    var node = this.props.node;
    var doc = node.getDocument();

    var wrappedNode = doc.get(node.wrappedNode);
    var el;
    if (wrappedNode) {
      var componentRegistry = this.context.componentRegistry;
      var ComponentClass = componentRegistry.get(wrappedNode.type);
      if (ComponentClass) {
        el = $$(ComponentClass, {
          disabled: this.props.disabled,
          node: wrappedNode,
        });
      } else {
        console.error('No component registered for node type' + wrappedNode.type);
      }
    } else {
      console.error('Could not find wrapped node: ' + node.wrappedNode);
    }
    return el
  };

  return InlineWrapperComponent;
}(InlineNodeComponent));

var InlineWrapperConverter = {
  type: 'inline-wrapper',

  matchElement: function(el, converter) {
    var blockConverter = converter._getConverterForElement(el, 'block');
    return Boolean(blockConverter)
  },

  import: function(el, node, converter) {
    
    node.id = converter.nextId('inline-wrapper');
    var state = converter.state;
    state.popElementContext();
    state.pushElementContext(state.getCurrentElementContext().tagName);
    node.wrappedNode = converter.convertElement(el).id;
  },

  export: function(node, el, converter) {
    return converter.convertNode(node.wrappedNode)
  }
};

var InlineWrapperPackage = {
  name: 'inline-wrapper',
  configure: function(config, options) {
    config.addNode(InlineWrapper);
    config.addComponent(InlineWrapper.type, InlineWrapperComponent);
    if (options.converters) {
      options.converters.forEach(function(name) {
        config.addConverter(name, InlineWrapperConverter);
      });
    }
  },
  InlineWrapper: InlineWrapper,
  InlineWrapperComponent: InlineWrapperComponent,
  InlineWrapperConverter: InlineWrapperConverter
};

var Link = (function (PropertyAnnotation$$1) {
  function Link () {
    PropertyAnnotation$$1.apply(this, arguments);
  }if ( PropertyAnnotation$$1 ) Link.__proto__ = PropertyAnnotation$$1;
  Link.prototype = Object.create( PropertyAnnotation$$1 && PropertyAnnotation$$1.prototype );
  Link.prototype.constructor = Link;

  

  return Link;
}(PropertyAnnotation));

Link.schema = {
  type: "link",
  title: { type: 'string', optional: true },
  url: { type: 'string', 'default': ''}
};


Link.fragmentation = Fragmenter.SHOULD_NOT_SPLIT;

Link.autoExpandRight = false;

var LinkComponent = (function (AnnotationComponent$$1) {
  function LinkComponent () {
    AnnotationComponent$$1.apply(this, arguments);
  }

  if ( AnnotationComponent$$1 ) LinkComponent.__proto__ = AnnotationComponent$$1;
  LinkComponent.prototype = Object.create( AnnotationComponent$$1 && AnnotationComponent$$1.prototype );
  LinkComponent.prototype.constructor = LinkComponent;

  LinkComponent.prototype.didMount = function didMount () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    AnnotationComponent$$1.prototype.didMount.apply(this, args);

    var node = this.props.node;
    this.context.editorSession.onRender('document', this.rerender, this, {
      path: [node.id, 'url']
    });
  };

  LinkComponent.prototype.dispose = function dispose () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    AnnotationComponent$$1.prototype.dispose.apply(this, args);

    this.context.editorSession.off(this);
  };

  LinkComponent.prototype.render = function render ($$) { 
    var el = AnnotationComponent$$1.prototype.render.call(this, $$);

    el.tagName = 'a';
    el.attr('href', this.props.node.url);

    var titleComps = [this.props.node.url];
    if (this.props.node.title) {
      titleComps.push(this.props.node.title);
    }

    return el.attr("title", titleComps.join(' | '))
  };

  return LinkComponent;
}(AnnotationComponent));

var LinkCommand = (function (AnnotationCommand$$1) {
  function LinkCommand () {
    AnnotationCommand$$1.apply(this, arguments);
  }

  if ( AnnotationCommand$$1 ) LinkCommand.__proto__ = AnnotationCommand$$1;
  LinkCommand.prototype = Object.create( AnnotationCommand$$1 && AnnotationCommand$$1.prototype );
  LinkCommand.prototype.constructor = LinkCommand;

  LinkCommand.prototype.canFuse = function canFuse () { return false };

  
  LinkCommand.prototype.executeCreate = function executeCreate (params) {
    var result = AnnotationCommand$$1.prototype.executeCreate.call(this, params);
    var editorSession = this._getEditorSession(params);
    editorSession.transaction(function (tx) {
      tx.setSelection(tx.selection.collapse());
    });
    return result
  };

  return LinkCommand;
}(AnnotationCommand));

var LinkHTMLConverter = {

  type: "link",
  tagName: 'a',

  import: function(el, node) {
    node.url = el.attr('href');
    node.title = el.attr('title');
  },

  export: function(link, el) {
    el.attr({
      href: link.url,
      title: link.title
    });
  }

};

var EditLinkTool = (function (Tool$$1) {
  function EditLinkTool () {
    Tool$$1.apply(this, arguments);
  }

  if ( Tool$$1 ) EditLinkTool.__proto__ = Tool$$1;
  EditLinkTool.prototype = Object.create( Tool$$1 && Tool$$1.prototype );
  EditLinkTool.prototype.constructor = EditLinkTool;

  EditLinkTool.prototype.getUrlPath = function getUrlPath () {
    var propPath = this.constructor.urlPropertyPath;
    return [this.props.node.id].concat(propPath)
  };

  EditLinkTool.prototype._openLink = function _openLink () {
    var doc = this.context.editorSession.getDocument();
    window.open(doc.get(this.getUrlPath()), '_blank');
  };

  EditLinkTool.prototype.render = function render ($$) {
    var Input = this.getComponent('input');
    var Button = this.getComponent('button');
    var el = $$('div').addClass('sc-edit-link-tool');

    
    if (this.props.disabled) {
      console.warn('Tried to render EditLinkTool while disabled.');
      return el
    }

    var urlPath = this.getUrlPath();

    el.append(
      $$(Input, {
        type: 'url',
        path: urlPath,
        placeholder: 'Paste or type a link url'
      }),
      $$(Button, {
        icon: 'open-link',
        style: this.props.style
      }).attr('title', this.getLabel('open-link'))
        .on('click', this._openLink),

      $$(Button, {
        icon: 'delete',
        style: this.props.style
      }).attr('title', this.getLabel('delete-link'))
        .on('click', this.onDelete)
    );
    return el
  };

  EditLinkTool.prototype.onDelete = function onDelete (e) {
    e.preventDefault();
    var node = this.props.node;
    var sm = this.context.surfaceManager;
    var surface = sm.getFocusedSurface();
    if (!surface) {
      console.warn('No focused surface. Stopping command execution.');
      return
    }
    var editorSession = this.context.editorSession;
    editorSession.transaction(function(tx, args) {
      tx.delete(node.id);
      return args
    });
  };

  return EditLinkTool;
}(Tool));

EditLinkTool.urlPropertyPath = ['url'];

var LinkPackage = {
  name: 'link',
  configure: function(config, ref) {
    var toolGroup = ref.toolGroup;
    var editLinkToolGroup = ref.editLinkToolGroup;

    config.addNode(Link);
    config.addComponent('link', LinkComponent);
    config.addConverter('html', LinkHTMLConverter);
    config.addConverter('xml', LinkHTMLConverter);
    config.addCommand('link', LinkCommand, {
      nodeType: 'link',
      disableCollapsedCursor: true
    });
    config.addCommand('edit-link', EditAnnotationCommand, {
      nodeType: 'link'
    });
    config.addTool('link', AnnotationTool, {
      toolGroup: toolGroup || 'annotations'
    });
    config.addTool('edit-link', EditLinkTool, {
      toolGroup: editLinkToolGroup || 'overlay'
    });
    config.addIcon('link', { 'fontawesome': 'fa-link'});
    config.addIcon('open-link', { 'fontawesome': 'fa-external-link' });
    config.addLabel('link', {
      en: 'Link',
      de: 'Link'
    });
    config.addLabel('open-link', {
      en: 'Open Link',
      de: 'Link ffnen'
    });
    config.addLabel('delete-link', {
      en: 'Remove Link',
      de: 'Link lschen'
    });
    if (platform.isMac) {
      config.addKeyboardShortcut('cmd+k', { command: 'link' });
    } else {
      config.addKeyboardShortcut('ctrl+k', { command: 'link' });
    }
  },
  Link: Link,
  LinkComponent: LinkComponent,
  LinkCommand: LinkCommand,
  LinkHTMLConverter: LinkHTMLConverter,
  EditLinkTool: EditLinkTool
};

var ListNode = (function (DocumentNode$$1) {
  function ListNode () {
    DocumentNode$$1.apply(this, arguments);
  }

  if ( DocumentNode$$1 ) ListNode.__proto__ = DocumentNode$$1;
  ListNode.prototype = Object.create( DocumentNode$$1 && DocumentNode$$1.prototype );
  ListNode.prototype.constructor = ListNode;

  var prototypeAccessors = { length: {} };

  ListNode.prototype.getItemAt = function getItemAt (idx) {
    return this.getDocument().get(this.items[idx])
  };

  ListNode.prototype.getFirstItem = function getFirstItem () {
    return this.getItemAt(0)
  };

  ListNode.prototype.getLastItem = function getLastItem () {
    return this.getItemAt(this.getLength()-1)
  };

  ListNode.prototype.getItems = function getItems () {
    var doc = this.getDocument();
    return this.items.map(function (id) {
      return doc.get(id)
    })
  };

  ListNode.prototype.getItemPosition = function getItemPosition (itemId) {
    if (itemId._isNode) { itemId = itemId.id; }
    var pos = this.items.indexOf(itemId);
    if (pos < 0) { throw new Error('Item is not within this list: ' + itemId) }
    return pos
  };

  ListNode.prototype.insertItemAt = function insertItemAt (pos, itemId) {
    var doc = this.getDocument();
    doc.update([this.id, 'items'], { type: 'insert', pos: pos, value: itemId });
  };

  ListNode.prototype.appendItem = function appendItem (itemId) {
    this.insertItemAt(this.items.length, itemId);
  };

  ListNode.prototype.removeItemAt = function removeItemAt (pos) {
    var doc = this.getDocument();
    doc.update([this.id, 'items'], { type: 'delete', pos: pos });
  };

  ListNode.prototype.remove = function remove (itemId) {
    var doc = this.getDocument();
    var pos = this.getItemPosition(itemId);
    if (pos >= 0) {
      doc.update([this.id, 'items'], { type: 'delete', pos: pos });
    }
  };

  ListNode.prototype.isEmpty = function isEmpty () {
    return this.items.length === 0
  };

  ListNode.prototype.getLength = function getLength () {
    return this.items.length
  };

  prototypeAccessors.length.get = function () {
    return this.getLength()
  };

  Object.defineProperties( ListNode.prototype, prototypeAccessors );

  return ListNode;
}(DocumentNode));

ListNode.isList = true;

ListNode.type = 'list';

ListNode.schema = {
  ordered: { type: 'boolean', default: false },
  
  items: { type: [ 'array', 'id' ], default: [], owned: true }
};

var ListItem = (function (TextNode$$1) {
  function ListItem () {
    TextNode$$1.apply(this, arguments);
  }if ( TextNode$$1 ) ListItem.__proto__ = TextNode$$1;
  ListItem.prototype = Object.create( TextNode$$1 && TextNode$$1.prototype );
  ListItem.prototype.constructor = ListItem;

  

  return ListItem;
}(TextNode));

ListItem.type = 'list-item';

ListItem.schema = {
  level: { type: "number", default: 1 }
};

var ListItemComponent = (function (TextPropertyComponent$$1) {
	function ListItemComponent () {
		TextPropertyComponent$$1.apply(this, arguments);
	}if ( TextPropertyComponent$$1 ) ListItemComponent.__proto__ = TextPropertyComponent$$1;
	ListItemComponent.prototype = Object.create( TextPropertyComponent$$1 && TextPropertyComponent$$1.prototype );
	ListItemComponent.prototype.constructor = ListItemComponent;

	

	return ListItemComponent;
}(TextPropertyComponent));

function getListTagName(node) {
  
  return node.ordered ? 'ol' : 'ul'
}

function renderListNode(node, rootEl, createElement) {
  var items = node.getItems();
  var stack = [rootEl];
  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    if (item.level<stack.length) {
      for (var j = stack.length; j > item.level; j--) {
        stack.pop();
      }
    } else if (item.level>stack.length) {
      for (var j$1 = stack.length; j$1 < item.level; j$1++) {
        
        var sublist = createElement(getListTagName(node));
        last$1(stack).append(sublist);
        stack.push(sublist);
      }
    }
    console.assert(item.level === stack.length, 'item.level should now be the same as stack.length');
    last$1(stack).append(
      createElement(item)
    );
  }
  for(var j$2=stack.length; j$2>1;j$2--) {
    stack.pop();
  }
}

var ListComponent = (function (Component$$1) {
  function ListComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) ListComponent.__proto__ = Component$$1;
  ListComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  ListComponent.prototype.constructor = ListComponent;

  ListComponent.prototype.didMount = function didMount () {
    this.context.editorSession.onRender('document', this._onChange, this);
  };

  ListComponent.prototype.render = function render ($$) {
    var node = this.props.node;
    var el = $$(getListTagName(node))
      .addClass('sc-list')
      .attr('data-id', node.id);
    renderListNode(node, el, function (arg) {
      if (isString$1(arg)) {
        return $$(arg)
      } else if(arg.type === 'list-item') {
        var item = arg;
        return $$(ListItemComponent, {
          path: [item.id, 'content'],
          node: item,
          tagName: 'li'
        })
        
        .ref(item.id)
      }
    });
    return el
  };

  ListComponent.prototype._onChange = function _onChange (change) {
    var this$1 = this;

    var node = this.props.node;
    if (change.isAffected(node.id)) {
      return this.rerender()
    }
    
    var itemIds = node.items;
    for (var i = 0; i < itemIds.length; i++) {
      if (change.isAffected([itemIds[i], 'level'])) {
        return this$1.rerender()
      }
    }
  };

  return ListComponent;
}(Component));


ListComponent.prototype._isCustomNodeComponent = true;

var ListHTMLConverter = {

  type: "list",

  matchElement: function(el) {
    return el.is('ul') || el.is('ol')
  },

  import: function(el, node, converter) {
    var self = this;
    this._santizeNestedLists(el);
    if (el.is('ol')) {
      node.ordered = true;
    }
    node.items = [];
    var itemEls = el.findAll('li');
    itemEls.forEach(function(li) {
      
      var listItem = converter.convertElement(li);
      listItem.level = _getLevel(li);
      node.items.push(listItem.id);
    });
    function _getLevel(li) {
      var _el = li;
      var level = 1;
      while(_el) {
        if (_el.parentNode === el) { return level }
        _el = _el.parentNode;
        if (self.matchElement(_el)) { level++; }
      }
    }
  },

  export: function(node, el, converter) {
    var $$ = converter.$$;
    el.tagName = getListTagName(node);
    renderListNode(node, el, function (arg){
      if (isString$1(arg)) {
        return $$(arg)
      } else {
        var item = arg;
        return $$('li').append(converter.annotatedText(item.getTextPath()))
      }
    });
    return el
  },

  _santizeNestedLists: function _santizeNestedLists(root) {
    var nestedLists = root.findAll('ol,ul');
    nestedLists.forEach(function (el){
      while (!el.parentNode.is('ol,ul')) {
        
        var parent = el.parentNode;
        var grandParent = parent.parentNode;
        var pos = grandParent.getChildIndex(parent);
        grandParent.insertAt(pos+1, el);
      }
    });
  }
};

var ListItemHTMLConverter = {

  type: "list-item",

  matchElement: function(el) {
    return el.is('li')
  },

  import: function(el, node, converter) {
    node.content = converter.annotatedText(el, [node.id, 'content']);
  },

  export: function(node, el, converter) {
    el.append(converter.annotatedText(node.getTextPath()));
  }
};

var InsertListCommand = (function (Command$$1) {
  function InsertListCommand () {
    Command$$1.apply(this, arguments);
  }

  if ( Command$$1 ) InsertListCommand.__proto__ = Command$$1;
  InsertListCommand.prototype = Object.create( Command$$1 && Command$$1.prototype );
  InsertListCommand.prototype.constructor = InsertListCommand;

  InsertListCommand.prototype.getCommandState = function getCommandState (params) {
    var sel = this._getSelection(params);
    var selectionState = params.editorSession.getSelectionState();
    var commandState = { disabled: false };
    var _disabledCollapsedCursor = this.config.disableCollapsedCursor && sel.isCollapsed();
    if (_disabledCollapsedCursor || !sel.isPropertySelection() || selectionState.isInlineNodeSelection()) {
      commandState.disabled = true;
    }
    return commandState
  };
  InsertListCommand.prototype.execute = function execute (params) {
    var ordered = this.config.ordered;
    var editorSession = params.editorSession;
    editorSession.transaction(function (tx) {
      tx.toggleList({ ordered: ordered });
    });
  };

  return InsertListCommand;
}(Command));

var InsertListTool = (function (Tool$$1) {
  function InsertListTool () {
    Tool$$1.apply(this, arguments);
  }

  if ( Tool$$1 ) InsertListTool.__proto__ = Tool$$1;
  InsertListTool.prototype = Object.create( Tool$$1 && Tool$$1.prototype );
  InsertListTool.prototype.constructor = InsertListTool;

  InsertListTool.prototype.getClassNames = function getClassNames () {
    return 'sc-insert-list-tool'
  };
  InsertListTool.prototype.renderButton = function renderButton ($$) {
    var button = Tool$$1.prototype.renderButton.call(this, $$);
    return [ button ]
  };
  InsertListTool.prototype.onClick = function onClick () {
    this.executeCommand({
      context: this.context
    });
  };

  return InsertListTool;
}(Tool));

var ListPackage = {
  name: 'list',
  configure: function(config, ref) {
    var toolGroup = ref.toolGroup;
    var disableCollapsedCursor = ref.disableCollapsedCursor;

    config.addNode(ListNode);
    config.addNode(ListItem);
    config.addComponent('list', ListComponent);

    config.addCommand('insert-unordered-list', InsertListCommand, {
      nodeType: 'list',
      ordered: false,
      disableCollapsedCursor: disableCollapsedCursor
    });
    config.addTool('insert-unordered-list', InsertListTool, { toolGroup: toolGroup });
    config.addLabel('insert-unordered-list', {
      en: 'Unordered list',
      de: 'Aufzhlung'
    });
    config.addIcon('insert-unordered-list', { 'fontawesome': 'fa-list-ul' });

    config.addCommand('insert-ordered-list', InsertListCommand, {
      nodeType: 'list',
      ordered: true,
      disableCollapsedCursor: disableCollapsedCursor
    });
    config.addTool('insert-ordered-list', InsertListTool, { toolGroup: toolGroup });
    config.addLabel('insert-ordered-list', {
      en: 'Ordered list',
      de: 'Nummerierte Liste'
    });
    config.addIcon('insert-ordered-list', { 'fontawesome': 'fa-list-ol' });

    config.addConverter('html', ListHTMLConverter);
    config.addConverter('html', ListItemHTMLConverter);
  }
};

var Paragraph = (function (TextBlock$$1) {
	function Paragraph () {
		TextBlock$$1.apply(this, arguments);
	}if ( TextBlock$$1 ) Paragraph.__proto__ = TextBlock$$1;
	Paragraph.prototype = Object.create( TextBlock$$1 && TextBlock$$1.prototype );
	Paragraph.prototype.constructor = Paragraph;

	

	return Paragraph;
}(TextBlock));

Paragraph.type = "paragraph";

var ParagraphComponent = (function (TextBlockComponent$$1) {
  function ParagraphComponent () {
    TextBlockComponent$$1.apply(this, arguments);
  }

  if ( TextBlockComponent$$1 ) ParagraphComponent.__proto__ = TextBlockComponent$$1;
  ParagraphComponent.prototype = Object.create( TextBlockComponent$$1 && TextBlockComponent$$1.prototype );
  ParagraphComponent.prototype.constructor = ParagraphComponent;

  ParagraphComponent.prototype.render = function render ($$) {
    var el = TextBlockComponent$$1.prototype.render.call(this, $$);
    return el.addClass('sc-paragraph')
  };

  ParagraphComponent.prototype.getTagName = function getTagName () {
    return 'p'
  };

  return ParagraphComponent;
}(TextBlockComponent));

var ParagraphHTMLConverter = {

  type: 'paragraph',
  tagName: 'p',

  import: function(el, node, converter) {
    node.textAlign = el.attr('data-text-align');
    node.content = converter.annotatedText(el, [node.id, 'content']);
  },

  export: function(node, el, converter) {
    if (node.textAlign) {
      el.attr('data-text-align', node.textAlign);
    }
    el.append(converter.annotatedText([node.id, 'content']));
  }

};

var ParagraphPackage = {
  name: 'paragraph',
  configure: function(config) {
    config.addNode(Paragraph);
    config.addComponent(Paragraph.type, ParagraphComponent);
    config.addConverter('html', ParagraphHTMLConverter);
    config.addConverter('xml', ParagraphHTMLConverter);
    config.addTextType({
      name: 'paragraph',
      data: {type: 'paragraph'}
    });
    config.addLabel('paragraph', {
      en: 'Paragraph',
      de: 'Paragraph'
    });
    config.addLabel('paragraph.content', {
      en: 'Paragraph',
      de: 'Paragraph'
    });
  },
  Paragraph: Paragraph,
  ParagraphComponent: ParagraphComponent,
  ParagraphHTMLConverter: ParagraphHTMLConverter
};

var SaveCommand = (function (Command$$1) {
  function SaveCommand() {
    Command$$1.call(this, { name: 'save' });
  }

  if ( Command$$1 ) SaveCommand.__proto__ = Command$$1;
  SaveCommand.prototype = Object.create( Command$$1 && Command$$1.prototype );
  SaveCommand.prototype.constructor = SaveCommand;

  SaveCommand.prototype.getCommandState = function getCommandState (params) {
    var dirty = params.editorSession.hasUnsavedChanges();
    return {
      disabled: !dirty,
      active: false
    }
  };

  SaveCommand.prototype.execute = function execute (params) {
    var editorSession = params.editorSession;
    editorSession.save();
    return {
      status: 'saving-process-started'
    }
  };

  return SaveCommand;
}(Command));

var PersistencePackage = {
  name: 'persistence',
  configure: function(config) {
    config.addCommand('save', SaveCommand);
    config.addTool('save', Tool, {toolGroup: 'document'});
    config.addIcon('save', { 'fontawesome': 'fa-save' });
    config.addLabel('save', {
      en: 'Save',
      de: 'Speichern'
    });
  },
  SaveCommand: SaveCommand
};

var SwitchTextTypeCommand = (function (Command$$1) {
  function SwitchTextTypeCommand () {
    Command$$1.apply(this, arguments);
  }

  if ( Command$$1 ) SwitchTextTypeCommand.__proto__ = Command$$1;
  SwitchTextTypeCommand.prototype = Object.create( Command$$1 && Command$$1.prototype );
  SwitchTextTypeCommand.prototype.constructor = SwitchTextTypeCommand;

  SwitchTextTypeCommand.prototype.getTextTypes = function getTextTypes (params) {
    var surface = params.surface;
    if (surface && surface.isContainerEditor()) {
      return surface.getTextTypes()
    } else {
      return []
    }
  };

  SwitchTextTypeCommand.prototype.getTextType = function getTextType (params) {
    var textTypes = this.getTextTypes(params);
    return find(textTypes, function(t) {
      return t.name === params.textType
    })
  };

  
  
  SwitchTextTypeCommand.prototype.getCurrentTextType = function getCurrentTextType (params, node) {
    var textTypes = this.getTextTypes(params);
    var currentTextType;
    textTypes.forEach(function(textType) {
      var nodeProps = clone(textType.data);
      delete nodeProps.type;
      if (isMatch(node, nodeProps) && node.type === textType.data.type) {
        currentTextType = textType;
      }
    });
    return currentTextType
  };

  SwitchTextTypeCommand.prototype.isDisabled = function isDisabled (ref) {
    var selection = ref.selection;
    var surface = ref.surface;

    if (!surface || !surface.isEnabled() || selection.isNull()) {
      return true
    }
    
    if (selection && this.config.disableCollapsedCursor && selection.isCollapsed()) {
      return true
    }
    return false
  };

  SwitchTextTypeCommand.prototype.getCommandState = function getCommandState (params) {
    var doc = params.editorSession.getDocument();
    var sel = params.selection;

    var node;
    var newState = {
      disabled: false,
      textTypes: this.getTextTypes(params)
    };
    
    if (this.isDisabled(params)) {
      newState.disabled = true;
    } else if (sel.isContainerSelection()) {
      newState.disabled = true;
      newState.currentTextType = {name: 'container-selection'};
    } else if (sel.isPropertySelection()) {
      var path = sel.getPath();
      node = doc.get(path[0]);
      
      
      if (node) {
        if (node.isText() && node.isBlock()) {
          newState.currentTextType = this.getCurrentTextType(params, node);
        }
        if (!newState.currentTextType) {
          
          
          
          newState.currentTextType = {name: [node.type, path[1]].join('.')};
          newState.disabled = true;
        }
      }
    } else if (sel.isNodeSelection()) {
      node = doc.get(sel.getNodeId());
      newState.currentTextType = {name: node.type};
      newState.disabled = true;
    } else if (sel.isCustomSelection()) {
      newState.currentTextType = {name: 'custom'};
      newState.disabled = true;
    }
    return newState
  };

  
  SwitchTextTypeCommand.prototype.execute = function execute (params) {
    var textType = this.getTextType(params);
    var nodeData = textType.data;
    var surface = params.surface;
    var editorSession = params.editorSession;
    if (!surface) {
      console.warn('No focused surface. Stopping command execution.');
      return
    }
    editorSession.transaction(function(tx) {
      return tx.switchTextType(nodeData)
    });
    return nodeData
  };

  return SwitchTextTypeCommand;
}(Command));

var SwitchTextTypeTool = (function (Tool$$1) {
  function SwitchTextTypeTool() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Tool$$1.apply(this, args);

    
    this._navIdx = -1;
  }

  if ( Tool$$1 ) SwitchTextTypeTool.__proto__ = Tool$$1;
  SwitchTextTypeTool.prototype = Object.create( Tool$$1 && Tool$$1.prototype );
  SwitchTextTypeTool.prototype.constructor = SwitchTextTypeTool;

  
  

  SwitchTextTypeTool.prototype.didMount = function didMount () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Tool$$1.prototype.didMount.apply(this, args);
    this._focusToggle();
  };

  SwitchTextTypeTool.prototype.render = function render ($$) {
    var labelProvider = this.context.labelProvider;
    var textTypeName = 'No selection';

    if (this.props.currentTextType) {
      textTypeName = this.props.currentTextType.name;
    }
    var el = $$('div').addClass('sc-switch-text-type');

    var toggleButton = $$('button').ref('toggle')
      .addClass('se-toggle')
      .attr('title', labelProvider.getLabel('switch_text'))
      .append(labelProvider.getLabel(textTypeName))
      .on('click', this.toggleAvailableTextTypes);

    if (this.props.disabled || !this.props.currentTextType) {
      el.addClass('sm-disabled');
      toggleButton.attr('tabindex', -1);
    } else {
      toggleButton.attr('tabindex', 1);
    }

    el.append(toggleButton);

    if (this.state.open) {
      el.addClass('sm-open');

      
      var options = $$('div').addClass("se-options").ref('options');
      forEach(this.props.textTypes, function(textType) {
        var button = $$('button')
            .addClass('se-option sm-'+textType.name)
            .attr('data-type', textType.name)
            .append(labelProvider.getLabel(textType.name))
            .on('click', this.handleClick);
        options.append(button);
      }.bind(this));
      el.append(options);
      el.on('keydown', this.onKeydown);
    }

    return el
  };

  SwitchTextTypeTool.prototype.didUpdate = function didUpdate () {
    this._focusToggle();
  };

  SwitchTextTypeTool.prototype._focusToggle = function _focusToggle () {
    if (this.state.open) {
      this.refs.toggle.el.focus();
    }
  };

  SwitchTextTypeTool.prototype.executeCommand = function executeCommand (textType) {
    this.context.commandManager.executeCommand(this.getCommandName(), {
      textType: textType
    });
  };

  SwitchTextTypeTool.prototype.getTextCommands = function getTextCommands () {
    var surface = this.getSurface();
    if (!this.textCommands && surface) {
      this.textCommands = surface.getTextCommands();
    }
    return this.textCommands || {}
  };

  SwitchTextTypeTool.prototype.handleClick = function handleClick (e) {
    e.preventDefault();
    
    
    this.executeCommand(e.currentTarget.dataset.type);
  };

  SwitchTextTypeTool.prototype.onKeydown = function onKeydown (event) {
    var handled = false;
    switch (event.keyCode) {
      case keys$1.UP:
        this._nav(-1);
        handled = true;
        break
      case keys$1.DOWN:
        this._nav(1);
        handled = true;
        break
      case keys$1.ESCAPE:
        this.toggleDropdown();
        handled = true;
        break
      default:
        
    }
    if (handled) {
      event.preventDefault();
      event.stopPropagation();
    }
  };

  SwitchTextTypeTool.prototype.toggleAvailableTextTypes = function toggleAvailableTextTypes (e) {
    e.preventDefault();
    e.stopPropagation();
    if (this.props.disabled) { return }

    
    
    this.toggleDropdown();
  };

  SwitchTextTypeTool.prototype.toggleDropdown = function toggleDropdown () {
    
    this._navIdx = -1;
    this.extendState({
      open: !this.state.open
    });
  };

  SwitchTextTypeTool.prototype._nav = function _nav (step) {
    this._navIdx += step;
    this._navIdx = Math.max(0, this._navIdx);
    this._navIdx = Math.min(this._getOptionsCount()-1, this._navIdx);

    if (this._navIdx >= 0) {
      var option = this.refs.options.children[this._navIdx];
      option.focus();
    }
  };

  SwitchTextTypeTool.prototype._getOptionsCount = function _getOptionsCount () {
    return this.refs.options.children.length
  };

  return SwitchTextTypeTool;
}(Tool));

SwitchTextTypeTool.command = 'switch-text-type';

var SwitchTextTypePackage = {
  name: 'switch-text-type',
  configure: function(config, options) {
    config.addToolGroup('text');
    config.addCommand('switch-text-type', SwitchTextTypeCommand);
    config.addTool('switch-text-type', SwitchTextTypeTool, {toolGroup: options.toolGroup || 'text'});
  },
  SwitchTextTypeCommand: SwitchTextTypeCommand
};

var Strong = (function (PropertyAnnotation$$1) {
	function Strong () {
		PropertyAnnotation$$1.apply(this, arguments);
	}if ( PropertyAnnotation$$1 ) Strong.__proto__ = PropertyAnnotation$$1;
	Strong.prototype = Object.create( PropertyAnnotation$$1 && PropertyAnnotation$$1.prototype );
	Strong.prototype.constructor = Strong;

	

	return Strong;
}(PropertyAnnotation));

Strong.type = "strong";
Strong.fragmentation = Fragmenter.ANY;

var StrongHTMLConverter = {

  type: "strong",
  tagName: "strong",

  matchElement: function(el) {
    return el.is("strong, b")
  }

};

var StrongComponent = (function (AnnotationComponent$$1) {
  function StrongComponent () {
    AnnotationComponent$$1.apply(this, arguments);
  }

  if ( AnnotationComponent$$1 ) StrongComponent.__proto__ = AnnotationComponent$$1;
  StrongComponent.prototype = Object.create( AnnotationComponent$$1 && AnnotationComponent$$1.prototype );
  StrongComponent.prototype.constructor = StrongComponent;

  StrongComponent.prototype.getTagName = function getTagName () {
    return 'strong'
  };

  return StrongComponent;
}(AnnotationComponent));

var StrongPackage = {
  name: 'strong',
  configure: function(config, ref) {
    var toolGroup = ref.toolGroup;
    var disableCollapsedCursor = ref.disableCollapsedCursor;

    config.addNode(Strong);
    config.addConverter('html', StrongHTMLConverter);
    config.addConverter('xml', StrongHTMLConverter);
    config.addComponent('strong', StrongComponent);

    config.addCommand('strong', AnnotationCommand, {
      nodeType: 'strong',
      disableCollapsedCursor: disableCollapsedCursor
    });
    config.addTool('strong', AnnotationTool, {
      toolGroup: toolGroup || 'annotations'
    });
    config.addIcon('strong', { 'fontawesome': 'fa-bold' });
    config.addLabel('strong', {
      en: 'Strong',
      de: 'Fett'
    });
    if (platform.isMac) {
      config.addKeyboardShortcut('cmd+b', { command: 'strong' });
    } else {
      config.addKeyboardShortcut('ctrl+b', { command: 'strong' });
    }
  },
  Strong: Strong,
  StrongComponent: StrongComponent,
  StrongHTMLConverter: StrongHTMLConverter
};

var Subscript = (function (PropertyAnnotation$$1) {
	function Subscript () {
		PropertyAnnotation$$1.apply(this, arguments);
	}if ( PropertyAnnotation$$1 ) Subscript.__proto__ = PropertyAnnotation$$1;
	Subscript.prototype = Object.create( PropertyAnnotation$$1 && PropertyAnnotation$$1.prototype );
	Subscript.prototype.constructor = Subscript;

	

	return Subscript;
}(PropertyAnnotation));

Subscript.type = 'subscript';


Subscript.fragmentation = Fragmenter.ANY;

var SubscriptHTMLConverter = {
  type: 'subscript',
  tagName: 'sub'
};

var SubscriptPackage = {
  name: 'subscript',
  configure: function(config, ref) {
    var toolGroup = ref.toolGroup;
    var disableCollapsedCursor = ref.disableCollapsedCursor;

    config.addNode(Subscript);
    config.addConverter('html', SubscriptHTMLConverter);
    config.addConverter('xml', SubscriptHTMLConverter);
    config.addComponent('subscript', AnnotationComponent);
    config.addCommand('subscript', AnnotationCommand, {
      nodeType: 'subscript',
      disableCollapsedCursor: disableCollapsedCursor
    });
    config.addTool('subscript', AnnotationTool, {toolGroup: toolGroup || 'annotations'});
    config.addIcon('subscript', { 'fontawesome': 'fa-subscript' });
    config.addLabel('subscript', {
      en: 'Subscript',
      de: 'Tiefgestellt'
    });
  },
  Subscript: Subscript,
  SubscriptHTMLConverter: SubscriptHTMLConverter
};

var Superscript = (function (PropertyAnnotation$$1) {
	function Superscript () {
		PropertyAnnotation$$1.apply(this, arguments);
	}if ( PropertyAnnotation$$1 ) Superscript.__proto__ = PropertyAnnotation$$1;
	Superscript.prototype = Object.create( PropertyAnnotation$$1 && PropertyAnnotation$$1.prototype );
	Superscript.prototype.constructor = Superscript;

	

	return Superscript;
}(PropertyAnnotation));

Superscript.type = 'superscript';


Superscript.fragmentation = Fragmenter.ANY;

var SuperscriptHTMLConverter = {
  type: 'superscript',
  tagName: 'sup'
};

var SuperscriptPackage = {
  name: 'superscript',
  configure: function(config, ref) {
    var toolGroup = ref.toolGroup;
    var disableCollapsedCursor = ref.disableCollapsedCursor;

    config.addNode(Superscript);
    config.addConverter('html', SuperscriptHTMLConverter);
    config.addConverter('xml', SuperscriptHTMLConverter);
    config.addComponent('superscript', AnnotationComponent);
    config.addCommand('superscript', AnnotationCommand, {
      nodeType: 'superscript',
      disableCollapsedCursor: disableCollapsedCursor
    });
    config.addTool('superscript', AnnotationTool, {toolGroup: toolGroup || 'annotations'});
    config.addIcon('superscript', { 'fontawesome': 'fa-superscript' });
    config.addLabel('superscript', {
      en: 'Superscript',
      de: 'Hochgestellt'
    });
  },
  Superscript: Superscript,
  SuperscriptHTMLConverter: SuperscriptHTMLConverter
};

var LEFT_QUOTE = "\u201C";
var RIGHT_QUOTE = "\u201D";

var InsertQuoteMarkCommand = (function (Command$$1) {
  function InsertQuoteMarkCommand () {
    Command$$1.apply(this, arguments);
  }

  if ( Command$$1 ) InsertQuoteMarkCommand.__proto__ = Command$$1;
  InsertQuoteMarkCommand.prototype = Object.create( Command$$1 && Command$$1.prototype );
  InsertQuoteMarkCommand.prototype.constructor = InsertQuoteMarkCommand;

  InsertQuoteMarkCommand.prototype.getCommandState = function getCommandState (params, context) { 
    
    
    return {
      disabled: false
    }
  };

  InsertQuoteMarkCommand.prototype.execute = function execute (params, context) { 
    var editorSession = params.editorSession;
    var sel = editorSession.getSelection();
    var doc = editorSession.getDocument();
    if (sel.isPropertySelection()) {
      var nodeId = sel.start.getNodeId();
      var node = doc.get(nodeId);
      if (node.isText()) {
        var text = node.getText();
        var offset = sel.start.offset;
        var mark;
        if (offset === 0 || /\s/.exec(text.slice(offset-1, offset))) {
          mark = LEFT_QUOTE;
        } else {
          mark = RIGHT_QUOTE;
        }
        editorSession.transaction(function (tx) {
          tx.insertText(mark);
        });
        return true
      }
    }
    return false
  };

  return InsertQuoteMarkCommand;
}(Command));

var QuoteMarksPackage = {

  name: 'quote-marks',

  configure: function(config) {
    config.addCommand('insertQuoteMark', InsertQuoteMarkCommand);
    config.addKeyboardShortcut('"', { type: 'textinput', command: 'insertQuoteMark' });
  }

};

var Table = (function (BlockNode$$1) {
  function Table () {
    BlockNode$$1.apply(this, arguments);
  }

  if ( BlockNode$$1 ) Table.__proto__ = BlockNode$$1;
  Table.prototype = Object.create( BlockNode$$1 && BlockNode$$1.prototype );
  Table.prototype.constructor = Table;

  Table.prototype.getRowCount = function getRowCount () {
    return this.cells.length
  };

  Table.prototype.getColCount = function getColCount () {
    if (this.cells.length > 0) {
      return this.cells[0].length
    } else {
      return 0
    }
  };

  Table.prototype.getCellAt = function getCellAt (row, col) {
    var cellId = this.cells[row][col];
    if (cellId) {
      return this.document.get(cellId)
    }
  };

  return Table;
}(BlockNode));

Table.schema = {
  type: 'table',
  cells: { type: ['array', 'array', 'id'], default: [], owned: true }
};

var TableCell = (function (TextNode$$1) {
  function TableCell () {
    TextNode$$1.apply(this, arguments);
  }if ( TextNode$$1 ) TableCell.__proto__ = TextNode$$1;
  TableCell.prototype = Object.create( TextNode$$1 && TextNode$$1.prototype );
  TableCell.prototype.constructor = TableCell;

  

  return TableCell;
}(TextNode));

TableCell.schema = {
  type: 'table-cell',
  rowspan: { type: 'number', default: 0 },
  colspan: { type: 'number', default: 0 }
};

var TableCellComponent = (function (Component$$1) {
  function TableCellComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) TableCellComponent.__proto__ = Component$$1;
  TableCellComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  TableCellComponent.prototype.constructor = TableCellComponent;

  TableCellComponent.prototype.render = function render ($$) {
    var node = this.props.node;
    var el = $$('td').addClass('sc-table-cell');
    el.append(
      $$(TextPropertyEditor, {
        path: node.getTextPath(),
        disabled: this.props.disabled
      }).ref('editor')
    );
    if (node.rowspan > 0) {
      el.attr('rowspan', node.rowspan);
    }
    if (node.colspan > 0) {
      el.attr('colspan', node.colspan);
    }
    return el
  };

  TableCellComponent.prototype.grabFocus = function grabFocus () {
    var node = this.props.node;
    this.context.editorSession.setSelection({
      type: 'property',
      path: node.getPath(),
      startOffset: node.getLength(),
      surfaceId: this.refs.editor.id
    });
  };

  return TableCellComponent;
}(Component));

TableCellComponent.prototype._isTableCellComponent = true;

var TableComponent = (function (Component$$1) {
  function TableComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) TableComponent.__proto__ = Component$$1;
  TableComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  TableComponent.prototype.constructor = TableComponent;

  TableComponent.prototype.render = function render ($$) {
    var this$1 = this;

    var el = $$('table').addClass('sc-table');
    var node = this.props.node;
    var doc = this.props.node.getDocument();
    var cells = this.props.node.cells;
    var rowCount = node.getRowCount();
    var colCount = node.getColCount();
    for (var i = 0; i < rowCount; i++) {
      var rowEl = $$('tr');
      for (var j = 0; j < colCount; j++) {
        var cellId = cells[i][j];
        
        if (cellId) {
          var cellNode = doc.get(cellId);
          var cellEl = $$(TableCellComponent, {
            node: cellNode,
            disabled: this$1.props.disabled
          }).ref(cellNode.id);
          rowEl.append(cellEl);
        }
      }
      el.append(rowEl);
    }
    el.on('click', this.onClick);
    el.on('dblclick', this.onDblClick);
    return el
  };

  TableComponent.prototype.onClick = function onClick (event) {
    event.stopPropagation();
    
  };

  
  TableComponent.prototype.onDblClick = function onDblClick (event) {
    event.stopPropagation();
    

    
    
    var comp = Component$$1.unwrap(event.target);
    if (comp) {
      var cellComp;
      if (comp._isTableCellComponent) {
        cellComp = comp;
      } else if (comp._isTextPropertyEditor) {
        cellComp = comp.getParent();
      } else if (comp._isTextPropertyComponent) {
        cellComp = comp.getParent().getParent();
      } else {
        console.warn('TODO: find the right cell');
      }
      if (cellComp) {
        cellComp.grabFocus();
      }
    }
  };

  TableComponent.prototype.grabFocus = function grabFocus () {
    var cellId = this.props.node.cells[0][0];
    if (cellId) {
      var comp = this.refs[cellId];
      comp.grabFocus();
    }
  };

  return TableComponent;
}(Component));

TableComponent.hasDropzones = true;

var TableHTMLConverter = {

  type: 'table',
  tagName: 'table',

  
  import: function(el, node, converter) {
    var trs = el.find('tbody').getChildren();
    var colCount = 0;
    var cells = [];
    var rowspans = []; 
    var loop = function ( i ) {
      var tds = trs[i].getChildren();
      var row = [];
      colCount = Math.max(tds.length, colCount);
      for (var j = 0; j < tds.length; j++) {
        var td = tds[j];
        
        if (rowspans[j] > 1) {
          row.push(null);
          rowspans[j] -= 1; 
        }
        var tableCell = converter.convertElement(td);
        row.push(tableCell.id);
        if (tableCell.rowspan > 1) {
          rowspans[j] = tableCell.rowspan;
        }
        if (tableCell.colspan > 1) {
          
          times(tableCell.colspan - 1, function () {
            row.push(null);
          });
        }
      }
      cells.push(row);
    };

    for (var i = 0; i < trs.length; i++) loop( i );
    node.cells = cells;
  },

  export: function(node, el, converter) {
    var $$ = converter.$$;
    var rowCount = node.getRowCount();
    var colCount = node.getColCount();
    for (var i = 0; i < rowCount; i++) {
      var rowEl = $$('tr');
      for (var j = 0; j < colCount; j++) {
        var cellId = node.cells[i][j];
        
        if (cellId) {
          var cellEl = converter.convertNode(cellId);
          rowEl.append(cellEl);
        }
      }
      el.append(rowEl);
    }
    return el
  }
};

var TableCellHTMLConverter = {

  type: 'table-cell',
  tagName: 'td',

  import: function(el, node, converter) {
    node.content = converter.annotatedText(el, [node.id, 'content']);
    var colspan = el.attr('colspan');
    var rowspan = el.attr('rowspan');
    if (colspan) {
      node.colspan = Number(colspan);
    }
    if (rowspan) {
      node.rowspan = Number(rowspan);
    }
  },

  export: function(node, el, converter) {
    el.append(converter.annotatedText([node.id, 'content']));
    if (node.rowspan > 0) {
      el.attr('rowspan', node.rowspan);
    }
    if (node.colspan > 0) {
      el.attr('colspan', node.colspan);
    }
    return el
  }
};

var InsertTableCommand = (function (InsertNodeCommand$$1) {
  function InsertTableCommand () {
    InsertNodeCommand$$1.apply(this, arguments);
  }

  if ( InsertNodeCommand$$1 ) InsertTableCommand.__proto__ = InsertNodeCommand$$1;
  InsertTableCommand.prototype = Object.create( InsertNodeCommand$$1 && InsertNodeCommand$$1.prototype );
  InsertTableCommand.prototype.constructor = InsertTableCommand;

  InsertTableCommand.prototype.createNodeData = function createNodeData (tx) {

    
    var a1 = tx.create({ id: uuid('table-cell'), type: 'table-cell', content: "A1" });
    var b1 = tx.create({ id: uuid('table-cell'), type: 'table-cell', content: "B1" });
    
    var a2 = tx.create({ id: uuid('table-cell'), type: 'table-cell', content: "A2" });
    var b2 = tx.create({ id: uuid('table-cell'), type: 'table-cell', content: "B2" });

    return {
      id: uuid('table'),
      type: 'table',
      
      cells: [
        [a1.id, b1.id ],
        [a2.id, b2.id]
      ]
    }

  };

  return InsertTableCommand;
}(InsertNodeCommand));

var TablePackage = {
  name: 'table',
  configure: function(config) {
    config.addNode(Table);
    config.addNode(TableCell);
    config.addComponent('table', TableComponent);
    config.addConverter('html', TableHTMLConverter);
    config.addConverter('html', TableCellHTMLConverter);
    config.addConverter('xml', TableHTMLConverter);
    config.addConverter('xml', TableCellHTMLConverter);
    config.addCommand('insert-table', InsertTableCommand);
    config.addTool('insert-table', Tool, { toolGroup: 'insert' });
    config.addIcon('insert-table', { 'fontawesome': 'fa-table' });
    config.addLabel('insert-table', {
      en: 'Insert Table',
      de: 'Tabelle einfgen'
    });
    config.addLabel('table', {
      en: 'Table',
      de: 'Tabelle'
    });
    config.addLabel('table-cell.content', {
      en: 'Cell',
      de: 'Zelle'
    });
  }
};

var ProseArticle = (function (Document$$1) {
  function ProseArticle(schema) {
    Document$$1.call(this, schema);
    this._initialize();
  }

  if ( Document$$1 ) ProseArticle.__proto__ = Document$$1;
  ProseArticle.prototype = Object.create( Document$$1 && Document$$1.prototype );
  ProseArticle.prototype.constructor = ProseArticle;

  ProseArticle.prototype._initialize = function _initialize () {
    this.create({
      type: 'container',
      id: 'body',
      nodes: []
    });
  };

  return ProseArticle;
}(Document));

var Toolbar = (function (Toolbox$$1) {
  function Toolbar () {
    Toolbox$$1.apply(this, arguments);
  }

  if ( Toolbox$$1 ) Toolbar.__proto__ = Toolbox$$1;
  Toolbar.prototype = Object.create( Toolbox$$1 && Toolbox$$1.prototype );
  Toolbar.prototype.constructor = Toolbar;

  Toolbar.prototype.render = function render ($$) {
    var this$1 = this;

    var el = $$('div').addClass(this.getClassNames());
    var activeToolGroups = this.state.activeToolGroups;

    activeToolGroups.forEach(function (toolGroup) {
      var toolGroupProps = Object.assign({}, toolGroup, {
        toolStyle: this$1.getToolStyle(),
        layout: 'horizontal',
        showIcons: true
      });
      el.append(
        $$(toolGroup.Class, toolGroupProps)
      );
    });
    return el
  };

  Toolbar.prototype.getActiveToolGroupNames = function getActiveToolGroupNames () {
    return this.props.toolGroups || ['text', 'document', 'annotations', 'default']
  };

  Toolbar.prototype.getClassNames = function getClassNames () {
    return 'sc-toolbar';
  };

  Toolbar.prototype.getToolStyle = function getToolStyle () {
    return 'outline'
  };

  Toolbar.prototype.showDisabled = function showDisabled () {
    return true
  };

  return Toolbar;
}(Toolbox));

var ProseEditor = (function (AbstractEditor$$1) {
  function ProseEditor () {
    AbstractEditor$$1.apply(this, arguments);
  }

  if ( AbstractEditor$$1 ) ProseEditor.__proto__ = AbstractEditor$$1;
  ProseEditor.prototype = Object.create( AbstractEditor$$1 && AbstractEditor$$1.prototype );
  ProseEditor.prototype.constructor = ProseEditor;

  ProseEditor.prototype.render = function render ($$) {
    var SplitPane = this.componentRegistry.get('split-pane');
    var el = $$('div').addClass('sc-prose-editor');
    var toolbar = this._renderToolbar($$);
    var editor = this._renderEditor($$);

    var ScrollPane = this.componentRegistry.get('scroll-pane');
    var Overlay$$1 = this.componentRegistry.get('overlay');
    var ContextMenu = this.componentRegistry.get('context-menu');
    var Dropzones = this.componentRegistry.get('dropzones');

    var contentPanel = $$(ScrollPane, {
      name: 'contentPanel',
      contextMenu: this.props.contextMenu || 'native',
      scrollbarPosition: 'right',
      scrollbarType: this.props.scrollbarType,
    }).append(
      editor,
      $$(Overlay$$1),
      $$(ContextMenu),
      $$(Dropzones)
    ).ref('contentPanel');

    el.append(
      $$(SplitPane, {splitType: 'horizontal'}).append(
        toolbar,
        contentPanel
      )
    );
    return el
  };

  ProseEditor.prototype._renderToolbar = function _renderToolbar ($$) {
    var commandStates = this.commandManager.getCommandStates();
    return $$('div').addClass('se-toolbar-wrapper').append(
      $$(Toolbar, {
        commandStates: commandStates
      }).ref('toolbar')
    )
  };

  ProseEditor.prototype._renderEditor = function _renderEditor ($$) {
    var configurator = this.getConfigurator();
    return $$(ContainerEditor, {
      disabled: this.props.disabled,
      editorSession: this.editorSession,
      node: this.doc.get('body'),
      commands: configurator.getSurfaceCommandNames(),
      textTypes: configurator.getTextTypes()
    }).ref('body')
  };

  return ProseEditor;
}(AbstractEditor));

var ProseEditorPackage = {
  name: 'prose-editor',
  configure: function(config) {
    config.defineSchema({
      name: 'prose-article',
      ArticleClass: ProseArticle,
      defaultTextType: 'paragraph'
    });
    
    config.import(BasePackage);
    config.import(SwitchTextTypePackage);
    config.import(ParagraphPackage);
    config.import(HeadingPackage);
    config.import(CodeblockPackage);
    config.import(BlockquotePackage);
    config.import(EmphasisPackage);
    config.import(StrongPackage);
    config.import(SubscriptPackage);
    config.import(SuperscriptPackage);
    config.import(CodePackage);
    config.import(LinkPackage);
    config.import(QuoteMarksPackage);
    config.import(ListPackage);
    config.import(TablePackage);
  },
  ProseEditor: ProseEditor
};

var SpellError = (function (Marker$$1) {
  function SpellError () {
    Marker$$1.apply(this, arguments);
  }

  if ( Marker$$1 ) SpellError.__proto__ = Marker$$1;
  SpellError.prototype = Object.create( Marker$$1 && Marker$$1.prototype );
  SpellError.prototype.constructor = SpellError;

  SpellError.prototype.invalidate = function invalidate () {
    this.remove();
  };

  return SpellError;
}(Marker));

SpellError.schema = {
  type: 'spell-error',
  suggestions: { type: ['object'], default: [] }
};

SpellError.scope = 'document';

var CorrectionTool = (function (Tool$$1) {
  function CorrectionTool () {
    Tool$$1.apply(this, arguments);
  }

  if ( Tool$$1 ) CorrectionTool.__proto__ = Tool$$1;
  CorrectionTool.prototype = Object.create( Tool$$1 && Tool$$1.prototype );
  CorrectionTool.prototype.constructor = CorrectionTool;

  CorrectionTool.prototype.render = function render ($$) {
    var this$1 = this;

    var node = this.props.node;
    var Button = this.getComponent('button');
    var el = $$('div').addClass('sc-correction-tool');

    if (node && node.suggestions.length > 0) {
      node.suggestions.forEach(function (s) {
        el.append(
          $$(Button, {
            label: s,
            style: this$1.props.style
          }).attr('title', this$1.getLabel('open-link'))
            .attr('data-correction', s)
            .on('click', this$1._applyCorrection.bind(this$1, s))
        );
      });
    } else {
      el.append(
        $$(Button, {
          label: 'No suggestions',
          style: this.props.style,
          disabled: true
        })
      );
    }
    return el
  };

  CorrectionTool.prototype._applyCorrection = function _applyCorrection (suggestion) {
    var editorSession = this.context.editorSession;
    var node = this.props.node;
    editorSession.transaction(function (tx) {
      var sel = tx.getSelection();
      tx.setSelection({
        type: 'property',
        path: node.start.path,
        startOffset: node.start.offset,
        endOffset: node.end.offset,
        containerId: sel.containerId
      });
      tx.insertText(suggestion);
    });
  };

  return CorrectionTool;
}(Tool));

var SpellCheckCommand = (function (Command$$1) {
  function SpellCheckCommand () {
    Command$$1.apply(this, arguments);
  }

  if ( Command$$1 ) SpellCheckCommand.__proto__ = Command$$1;
  SpellCheckCommand.prototype = Object.create( Command$$1 && Command$$1.prototype );
  SpellCheckCommand.prototype.constructor = SpellCheckCommand;

  SpellCheckCommand.prototype.getCommandState = function getCommandState (params) {

    var state = params.selectionState;
    var markers = state.getMarkers();
    if (markers.length === 0) {
      return {
        disabled: true
      }
    }
    markers = markers.filter(function(m) {
      return m.type === 'spell-error'
    });

    if (markers.length > 0) {
      return {
        disabled: false,
        active: false,
        mode: null,
        node: markers[0]
      }
    } else {
      return {
        disabled: true
      }
    }
  };

  return SpellCheckCommand;
}(Command));

var SpellCheckPackage = {
  name: 'spell-check',
  configure: function(config) {
    config.addNode(SpellError);
    config.addCommand('correction', SpellCheckCommand);
    config.addTool('correction', CorrectionTool, {toolGroup: 'context-menu-primary'});
  }
};

var UndoCommand$1 = BasePackage.UndoCommand;
var RedoCommand$1 = BasePackage.RedoCommand;
var SelectAllCommand$1 = BasePackage.SelectAllCommand;




var TextInput = (function (AbstractEditor$$1) {
  function TextInput(parent, props) {
    if ( props === void 0 ) props = {};

    AbstractEditor$$1.call(this, parent, _createEditorSession(props));

    this.doc = this.editorSession.getDocument();
  }

  if ( AbstractEditor$$1 ) TextInput.__proto__ = AbstractEditor$$1;
  TextInput.prototype = Object.create( AbstractEditor$$1 && AbstractEditor$$1.prototype );
  TextInput.prototype.constructor = TextInput;

  TextInput.prototype.render = function render ($$) {
    var el = $$(this._getTagName()).addClass('sc-text-input');
    el.append(
      $$(TextInputEditor, {
        path: ['input', 'content']
      }).ref('input')
        .on('enter', this._onEnter)
        .on('escape', this._onEscape)
    );
    return el
  };

  TextInput.prototype.didMount = function didMount () {
    
    this.refs.input.selectLast();
  };

  TextInput.prototype.dispose = function dispose () {
    AbstractEditor$$1.prototype.dispose.call(this);

    this.doc.dispose();
    this.editorSession.dispose();
  };

  
  TextInput.prototype.shouldRerender = function shouldRerender () {
    return false
  };

  TextInput.prototype.getContent = function getContent () {
    return this.getDocument().getContent()
  };

  TextInput.prototype._getDocument = function _getDocument () {
    return this.context.editorSession.getDocument()
  };

  TextInput.prototype._getTagName = function _getTagName () {
    return this.props.tagName || 'div'
  };

  TextInput.prototype._onEnter = function _onEnter (event) {
    event.stopPropagation();
    this.el.emit('confirm');
  };

  TextInput.prototype._onEscape = function _onEscape (event) {
    event.stopPropagation();
    this.el.emit('cancel');
  };

  return TextInput;
}(AbstractEditor));

function _createEditorSession(props) {
  var config = new Configurator();
  config.addNode(TextNode);
  config.addToolGroup('annotations');
  config.addToolGroup('default');
  config.addCommand('undo', UndoCommand$1);
  config.addCommand('redo', RedoCommand$1);
  config.addCommand('select-all', SelectAllCommand$1);
  if (platform.isMac) {
    config.addKeyboardShortcut('cmd+z', { command: 'undo' });
    config.addKeyboardShortcut('cmd+shift+z', { command: 'redo' });
    config.addKeyboardShortcut('cmd+a', { command: 'select-all' });
  } else {
    config.addKeyboardShortcut('ctrl+z', { command: 'undo' });
    config.addKeyboardShortcut('ctrl+shift+z', { command: 'redo' });
    config.addKeyboardShortcut('ctrl+a', { command: 'select-all' });
  }

  config.defineSchema({
    name: 'text-input',
    
    
    defaultTextType: 'text',
    
    
    ArticleClass: TextInputDocument,
  });
  if (props.package) {
    config.import(props.package);
  }
  var doc = config.createArticle();
  if (props.content) {
    doc.set(['input', 'content'], props.content);
  }
  var editorSession = new EditorSession(doc, {
    configurator: config
  });
  return {
    editorSession: editorSession
  }
}

var TextInputDocument = (function (Document$$1) {
  function TextInputDocument() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Document$$1.apply(this, args);

    this.create({
      type: 'text',
      id: 'input',
      content: ''
    });
  }

  if ( Document$$1 ) TextInputDocument.__proto__ = Document$$1;
  TextInputDocument.prototype = Object.create( Document$$1 && Document$$1.prototype );
  TextInputDocument.prototype.constructor = TextInputDocument;
  TextInputDocument.prototype.getContentNode = function getContentNode () {
    return this.get('input')
  };
  TextInputDocument.prototype.getContent = function getContent () {
    return this.getContentNode().getText()
  };

  return TextInputDocument;
}(Document));



var TextInputEditor = (function (TextPropertyEditor$$1) {
  function TextInputEditor () {
    TextPropertyEditor$$1.apply(this, arguments);
  }

  if ( TextPropertyEditor$$1 ) TextInputEditor.__proto__ = TextPropertyEditor$$1;
  TextInputEditor.prototype = Object.create( TextPropertyEditor$$1 && TextPropertyEditor$$1.prototype );
  TextInputEditor.prototype.constructor = TextInputEditor;

  TextInputEditor.prototype.onKeyDown = function onKeyDown (event) {
    var handled = false;
    if (event.keyCode === 27) {
      handled = true;
      this.el.emit('escape');
    }
    if (handled) {
      event.stopPropagation();
      event.preventDefault();
    } else {
      TextPropertyEditor$$1.prototype.onKeyDown.call(this, event);
    }
  };

  TextInputEditor.prototype.selectLast = function selectLast () {
    var doc = this.getDocument();
    var input = doc.getContentNode();
    this.editorSession.setSelection({
      type: 'property',
      path: input.getTextPath(),
      startOffset: input.getLength(),
      surfaceId: this.id
    });
  };

  TextInputEditor.prototype.selectAll = function selectAll () {
    var doc = this.getDocument();
    var input = doc.getContentNode();
    this.editorSession.setSelection({
      type: 'property',
      path: input.getTextPath(),
      startOffset: 0,
      endffset: input.getLength(),
      surfaceId: this.id
    });
  };

  TextInputEditor.prototype._handleEnterKey = function _handleEnterKey () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    TextPropertyEditor$$1.prototype._handleEnterKey.apply(this, args);
    this.el.emit('enter');
  };

  return TextInputEditor;
}(TextPropertyEditor));

var TextInputPackage = {
  name: 'text-input',
  configure: function configure(config) {
    config.addComponent('text-input', TextInput);
  },
  TextInput: TextInput
};

var ToolDropdown = (function (Component$$1) {
  function ToolDropdown () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) ToolDropdown.__proto__ = Component$$1;
  ToolDropdown.prototype = Object.create( Component$$1 && Component$$1.prototype );
  ToolDropdown.prototype.constructor = ToolDropdown;

  ToolDropdown.prototype.render = function render ($$) {
    var tools = this.props.tools;
    var commandStates = this.props.commandStates;
    var el = $$('div').addClass('sc-tool-dropdown');
    el.addClass('sm-target-'+this.props.name);
    el.append(
      this.renderButton($$)
    );
    if (this.state.open) {
      var optionEls = [];
      tools.forEach(function(tool, name) {
        var toolProps = Object.assign({}, commandStates[name]);
        toolProps.name = name;
        toolProps.label = name;
        toolProps.style = 'plain-dark'; 
        optionEls.push($$(tool.Class, toolProps));
      });
      el.append(
        $$('div').addClass('se-options').append(
          $$('div').addClass('se-arrow'),
          $$('div').addClass('se-content').append(
            optionEls
          )
        )
      );
    }
    return el
  };

  ToolDropdown.prototype.renderButton = function renderButton ($$) {
    var btn = $$(Button, {
      label: this.props.name,
      active: this.state.open,
      disabled: this.props.disabled,
      style: this.props.style
    }).on('click', this.onClick);
    return btn
  };

  ToolDropdown.prototype.onClick = function onClick () {
    var open = !this.state.open;
    this.setState({
      open: open
    });
  };

  return ToolDropdown;
}(Component));

var ToolbarPackage = {
  name: 'toolbar',
  configure: function configure(config) {
    config.addComponent('toolbar', Toolbar);
    config.addComponent('tool-group', ToolGroup);
    config.addComponent('tool-dropdown', ToolDropdown);
  },
  Toolbar: Toolbar,
  ToolGroup: ToolGroup,
  ToolDropdown: ToolDropdown
};

var TEXT_ALIGNMENTS = ['left', 'center', 'right'];

var TextAlignTool = (function (Tool$$1) {
  function TextAlignTool () {
    Tool$$1.apply(this, arguments);
  }

  if ( Tool$$1 ) TextAlignTool.__proto__ = Tool$$1;
  TextAlignTool.prototype = Object.create( Tool$$1 && Tool$$1.prototype );
  TextAlignTool.prototype.constructor = TextAlignTool;

  TextAlignTool.prototype.render = function render ($$) {
    var this$1 = this;

    var Button = this.getComponent('button');
    var el = $$('div').addClass('sc-text-align-tool se-tool');

    var currentTextAlign = this.props.node.textAlign || 'left';

    TEXT_ALIGNMENTS.forEach(function (textAlign) {
      var button = $$(Button, {
        icon: 'align-'+textAlign,
        active: currentTextAlign === textAlign,
        disabled: this$1.props.disabled,
        style: this$1.props.style
      }).attr('data-text-align', textAlign)
        .on('click', this$1.handleClick);
      el.append(button);
    });
    return el
  };

  TextAlignTool.prototype.handleClick = function handleClick (e) {
    var newTextAlign = e.currentTarget.dataset.textAlign;
    e.preventDefault();
    this.context.commandManager.executeCommand(this.getCommandName(), {
      textAlign: newTextAlign
    });
  };

  return TextAlignTool;
}(Tool));

var TextAlignCommand = (function (Command$$1) {
  function TextAlignCommand () {
    Command$$1.apply(this, arguments);
  }

  if ( Command$$1 ) TextAlignCommand.__proto__ = Command$$1;
  TextAlignCommand.prototype = Object.create( Command$$1 && Command$$1.prototype );
  TextAlignCommand.prototype.constructor = TextAlignCommand;

  TextAlignCommand.prototype.getCommandState = function getCommandState (params) {
    var sel = this._getSelection(params);
    var selectionState = params.editorSession.getSelectionState();
    var doc = params.editorSession.getDocument();
    var commandState = { disabled: false };
    var _disabledCollapsedCursor = this.config.disableCollapsedCursor && sel.isCollapsed();
    if (_disabledCollapsedCursor || !sel.isPropertySelection() || selectionState.isInlineNodeSelection()) {
      commandState.disabled = true;
    } else {
      var path = sel.getPath();
      var node = doc.get(path[0]);
      if (node && node.isText() && node.isBlock()) {
        commandState.node = node;
      } else {
        commandState.disabled = true;
      }
    }

    return commandState
  };
  TextAlignCommand.prototype.execute = function execute (params) {
    var node = params.commandState.node;
    var textAlign = params.textAlign;
    var editorSession = params.editorSession;
    editorSession.transaction(function (tx) {
      tx.set([node.id, 'textAlign'], textAlign);
    });
  };

  return TextAlignCommand;
}(Command));

var TextAlignPackage = {
  name: 'text-align',
  configure: function(config) {
    config.addCommand('text-align', TextAlignCommand, {
      disableCollapsedCursor: true
    });
    config.addTool('text-align', TextAlignTool, {
      toolGroup: 'annotations'
    });
    config.addIcon('align-left', { 'fontawesome': 'fa-align-left' });
    config.addIcon('align-center', { 'fontawesome': 'fa-align-center' });
    config.addIcon('align-right', { 'fontawesome': 'fa-align-right' });
  }
};

exports.ChangeStore = ChangeStore;
exports.CollabServer = CollabServer;
exports.DocumentClient = DocumentClient;
exports.ServerRequest = ServerRequest;
exports.WebSocketConnection = WebSocketConnection;
exports.ClientConnection = ClientConnection;
exports.CollabServerConfigurator = CollabServerConfigurator;
exports.DocumentEngine = DocumentEngine;
exports.ServerResponse = ServerResponse;
exports.computeSnapshot = computeSnapshot;
exports.CollabClient = CollabClient;
exports.CollabServerPackage = CollabServerPackage;
exports.DocumentServer = DocumentServer;
exports.SnapshotEngine = SnapshotEngine;
exports.CollabEngine = CollabEngine;
exports.CollabSession = CollabSession;
exports.Server = Server;
exports.SnapshotStore = SnapshotStore;
exports.DOMElement = DOMElement;
exports.DOMEventListener = DOMEventListener;
exports.DefaultDOMElement = DefaultDOMElement;
exports.BrowserDOMElement = BrowserDOMElement;
exports.MemoryDOMElement = MemoryDOMElement;
exports.operationHelpers = operationHelpers;
exports.selectionHelpers = selectionHelpers;
exports.Annotation = Annotation;
exports.annotationHelpers = annotationHelpers;
exports.AnnotationIndex = AnnotationIndex;
exports.ArrayOperation = ArrayOperation;
exports.BlockNode = BlockNode;
exports.ChangeHistory = ChangeHistory;
exports.ChangeRecorder = ChangeRecorder;
exports.Conflict = Conflict;
exports.Container = Container;
exports.ContainerAdapter = ContainerAdapter;
exports.ContainerAddress = ContainerAddress;
exports.ContainerAnnotation = ContainerAnnotation;
exports.ContainerAnnotationIndex = ContainerAnnotationIndex;
exports.ContainerSelection = ContainerSelection;
exports.Coordinate = Coordinate;
exports.CoordinateAdapter = CoordinateAdapter;
exports.CoordinateOperation = CoordinateOperation;
exports.copySelection = copySelection;
exports.createDocumentFactory = createDocumentFactory$$1;
exports.CustomSelection = CustomSelection;
exports.Data = Data;
exports.DefaultChangeCompressor = DefaultChangeCompressor;
exports.DefaultFileProxy = DefaultFileProxy;
exports.Document = Document;
exports.DocumentChange = DocumentChange;
exports.documentHelpers = documentHelpers;
exports.DocumentIndex = DocumentIndex;
exports.DocumentNode = DocumentNode;
exports.DocumentNodeFactory = DocumentNodeFactory;
exports.DocumentSchema = DocumentSchema;
exports.DOMExporter = DOMExporter;
exports.DOMImporter = DOMImporter;
exports.Editing = Editing;
exports.EditingBehavior = EditingBehavior;
exports.EditingInterface = EditingInterface;
exports.FileNode = FileNode;
exports.FileProxy = FileProxy;
exports.Fragmenter = Fragmenter;
exports.HTMLExporter = HTMLExporter;
exports.HTMLImporter = HTMLImporter;
exports.IncrementalData = IncrementalData;
exports.InlineNode = InlineNode;
exports.JSONConverter = JSONConverter;
exports.Marker = Marker;
exports.Node = Node;
exports.NodeIndex = NodeIndex;
exports.NodeRegistry = NodeRegistry;
exports.NodeSelection = NodeSelection;
exports.ObjectOperation = ObjectOperation;
exports.OperationSerializer = OperationSerializer;
exports.ParentNodeHook = ParentNodeHook;
exports.paste = paste;
exports.PathEventProxy = PathEventProxy;
exports.Property = Property;
exports.PropertyAnnotation = PropertyAnnotation;
exports.PropertyIndex = PropertyIndex;
exports.PropertySelection = PropertySelection;
exports.Range = Range;
exports.Schema = Schema;
exports.Selection = Selection;
exports.SelectionState = SelectionState;
exports.TextBlock = TextBlock;
exports.TextNode = TextNode;
exports.TextOperation = TextOperation;
exports.Transaction = Transaction;
exports.TransactionDocument = TransactionDocument;
exports.XMLExporter = XMLExporter;
exports.XMLImporter = XMLImporter;
exports.AbstractEditor = AbstractEditor;
exports.AbstractIsolatedNodeComponent = AbstractIsolatedNodeComponent;
exports.AbstractScrollPane = AbstractScrollPane$$1;
exports.AnnotatedTextComponent = AnnotatedTextComponent;
exports.AnnotationCommand = AnnotationCommand;
exports.AnnotationComponent = AnnotationComponent;
exports.AnnotationTool = AnnotationTool;
exports.BlockNodeComponent = BlockNodeComponent;
exports.Clipboard = Clipboard;
exports.ClipboardExporter = ClipboardExporter;
exports.ClipboardImporter = ClipboardImporter;
exports.Command = Command;
exports.CommandManager = CommandManager;
exports.Component = Component;
exports.ComponentRegistry = ComponentRegistry;
exports.Configurator = Configurator;
exports.ContainerEditor = ContainerEditor;
exports.CursorComponent = CursorComponent;
exports.DefaultLabelProvider = DefaultLabelProvider;
exports.DOMSelection = DOMSelection;
exports.DragAndDropHandler = DragAndDropHandler;
exports.DragManager = DragManager;
exports.EditAnnotationCommand = EditAnnotationCommand;
exports.EditInlineNodeCommand = EditInlineNodeCommand;
exports.EditorSession = EditorSession;
exports.ExecuteCommandHandler = ExecuteCommandHandler;
exports.FileManager = FileManager;
exports.FontAwesomeIcon = FontAwesomeIcon;
exports.FontAwesomeIconProvider = FontAwesomeIconProvider;
exports.GlobalEventHandler = GlobalEventHandler;
exports.Highlights = Highlights;
exports.InlineNodeComponent = InlineNodeComponent;
exports.InsertInlineNodeCommand = InsertInlineNodeCommand;
exports.InsertNodeCommand = InsertNodeCommand;
exports.IsolatedNodeComponent = IsolatedNodeComponent;
exports.KeyboardManager = KeyboardManager;
exports.MacroManager = MacroManager;
exports.MarkersManager = MarkersManager;
exports.NodeComponent = NodeComponent;
exports.Overlay = Overlay;
exports.RenderingEngine = RenderingEngine;
exports.ResourceManager = ResourceManager;
exports.ResponsiveApplication = ResponsiveApplication;
exports.Router = Router;
exports.SelectionFragmentComponent = SelectionFragmentComponent;
exports.Surface = Surface;
exports.SurfaceManager = SurfaceManager;
exports.TextBlockComponent = TextBlockComponent;
exports.TextPropertyComponent = TextPropertyComponent;
exports.TextPropertyEditor = TextPropertyEditor;
exports.Tool = Tool;
exports.Toolbox = Toolbox;
exports.UnsupportedNodeComponent = UnsupportedNodeComponent;
exports.VirtualElement = VirtualElement;
exports.findParentComponent = findParentComponent;
exports.setDOMSelection = setDOMSelection;
exports.async = async;
exports.ArrayIterator = ArrayIterator;
exports.ArrayTree = ArrayTree;
exports.capitalize = capitalize;
exports.clone = clone;
exports.cloneDeep = cloneDeep;
exports.createCountingIdGenerator = createCountingIdGenerator;
exports.debounce = debounce;
exports.deleteFromArray = deleteFromArray;
exports.diff = diff;
exports.encodeXMLEntities = encodeXMLEntities;
exports.EventEmitter = EventEmitter;
exports.extend = extend;
exports.Factory = Factory;
exports.filter = filter;
exports.find = find;
exports.findIndex = findIndex$1;
exports.flatten = flatten;
exports.flattenOften = flattenOften;
exports.forEach = forEach;
exports.getRelativeBoundingRect = getRelativeBoundingRect;
exports.getRelativeMouseBounds = getRelativeMouseBounds;
exports.inBrowser = inBrowser;
exports.includes = includes;
exports.isArray = isArray$1;
exports.isArrayEqual = isArrayEqual;
exports.isBoolean = isBoolean;
exports.isEqual = isEqual;
exports.isFunction = isFunction$1;
exports.isMatch = isMatch;
exports.isNil = isNil;
exports.isNumber = isNumber;
exports.isObject = isObject$1;
exports.isPlainObject = isPlainObject$1;
exports.isString = isString$1;
exports.last = last$1;
exports.levenshtein = levenshtein;
exports.makeMap = makeMap;
exports.map = map;
exports.merge = merge$1;
exports.PathObject = PathObject;
exports.percentage = percentage;
exports.platform = platform;
exports.pluck = pluck;
exports.printStacktrace = printStacktrace;
exports.Registry = Registry;
exports.request = request;
exports.sendRequest = sendRequest;
exports.startsWith = startsWith;
exports.SubstanceError = SubstanceError;
exports.substanceGlobals = substanceGlobals;
exports.times = times;
exports.TreeIndex = TreeIndex;
exports.uniq = uniq;
exports.uuid = uuid;
exports.without = without;
exports.parseKeyEvent = parseKeyEvent;
exports.keys = keys$1;
exports.getDOMRangeFromEvent = getDOMRangeFromEvent;
exports.getSelectionRect = getSelectionRect;
exports.getRelativeRect = getRelativeRect;
exports.isMouseInsideDOMSelection = isMouseInsideDOMSelection;
exports.BasePackage = BasePackage;
exports.BlockquotePackage = BlockquotePackage;
exports.BodyScrollPanePackage = BodyScrollPanePackage;
exports.ButtonPackage = ButtonPackage;
exports.CodePackage = CodePackage;
exports.CodeblockPackage = CodeblockPackage;
exports.ContextMenuPackage = ContextMenuPackage;
exports.DropzonesPackage = DropzonesPackage;
exports.EmphasisPackage = EmphasisPackage;
exports.FilePackage = FilePackage;
exports.GridPackage = GridPackage;
exports.GutterPackage = GutterPackage;
exports.HeadingPackage = HeadingPackage;
exports.ImagePackage = ImagePackage;
exports.InlineWrapperPackage = InlineWrapperPackage;
exports.InputPackage = InputPackage;
exports.LayoutPackage = LayoutPackage;
exports.LinkPackage = LinkPackage;
exports.ListPackage = ListPackage;
exports.ModalPackage = ModalPackage;
exports.OverlayPackage = OverlayPackage;
exports.ParagraphPackage = ParagraphPackage;
exports.PersistencePackage = PersistencePackage;
exports.ProseEditorPackage = ProseEditorPackage;
exports.QuoteMarksPackage = QuoteMarksPackage;
exports.ScrollPanePackage = ScrollPanePackage;
exports.ScrollbarPackage = ScrollbarPackage;
exports.SpellCheckPackage = SpellCheckPackage;
exports.SplitPanePackage = SplitPanePackage;
exports.StrongPackage = StrongPackage;
exports.SubscriptPackage = SubscriptPackage;
exports.SuperscriptPackage = SuperscriptPackage;
exports.SwitchTextTypePackage = SwitchTextTypePackage;
exports.TabbedPanePackage = TabbedPanePackage;
exports.TablePackage = TablePackage;
exports.TextInputPackage = TextInputPackage;
exports.ToolbarPackage = ToolbarPackage;
exports.TextAlignPackage = TextAlignPackage;

Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=./substance.js.map